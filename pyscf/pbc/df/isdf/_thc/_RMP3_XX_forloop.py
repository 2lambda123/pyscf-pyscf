import numpy
import numpy as np
import ctypes
import copy
from pyscf.lib import logger
from pyscf import lib
libpbc = lib.load_library('libpbc')
from pyscf.pbc.df.isdf.isdf_jk import _benchmark_time

from pyscf.pbc.df.isdf.isdf_tools_mpi import rank, comm, comm_size, allgather, bcast, reduce, gather, alltoall, _comm_bunch, allgather_pickle
def RMP3_XX_1_forloop_P_R_determine_bucket_size_forloop(NVIR        : int,
                                                        NOCC        : int,
                                                        N_LAPLACE   : int,
                                                        NTHC_INT    : int,
                                                        P_bunchsize = 8,
                                                        R_bunchsize = 8,
                                                        V_bunchsize = 1,
                                                        W_bunchsize = 1):
    # init
    output = []     
    bucked_0_size    = 0               
    bucked_1_size    = 0               
    bucked_2_size    = 0               
    bucked_3_size    = 0               
    bucked_4_size    = 0               
    bucked_5_size    = 0               
    bucked_6_size    = 0               
    bucked_7_size    = 0               
    bucked_8_size    = 0               
    bucked_9_size    = 0               
    # assign the size of each tensor
    _M3_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M0_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M18_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M2_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M1_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _INPUT_17_sliced_size = (NVIR * N_LAPLACE)
    _INPUT_19_sliced_size = (NOCC * N_LAPLACE)
    _M14_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize)))
    _M6_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M10_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _INPUT_21_sliced_size = (NVIR * N_LAPLACE)
    _M0_sliced_size  = (P_bunchsize * (V_bunchsize * NOCC))
    _INPUT_0_sliced_size = (NTHC_INT * NTHC_INT)
    _M8_size         = (NVIR * (P_bunchsize * (R_bunchsize * V_bunchsize)))
    _M15_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * (R_bunchsize * V_bunchsize))))
    _M16_perm_size   = (R_bunchsize * (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize))))
    _M18_sliced_size = (NTHC_INT * (R_bunchsize * W_bunchsize))
    _INPUT_5_sliced_size = (NTHC_INT * NTHC_INT)
    _M12_size        = (NVIR * (R_bunchsize * (P_bunchsize * V_bunchsize)))
    _M20_size        = (NTHC_INT * (W_bunchsize * (R_bunchsize * (P_bunchsize * V_bunchsize))))
    _M4_size         = (V_bunchsize * (W_bunchsize * NVIR))
    _M5_size         = (W_bunchsize * (P_bunchsize * (V_bunchsize * NOCC)))
    _M6_sliced_size  = (NTHC_INT * (R_bunchsize * V_bunchsize))
    _M9_size         = (W_bunchsize * (P_bunchsize * (R_bunchsize * (V_bunchsize * NVIR))))
    _M16_size        = (R_bunchsize * (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize))))
    _M17_size        = (NTHC_INT * (R_bunchsize * (W_bunchsize * (P_bunchsize * V_bunchsize))))
    _M10_sliced_size = (NTHC_INT * (P_bunchsize * V_bunchsize))
    _INPUT_22_sliced_size = (NVIR * N_LAPLACE)
    _M20_perm_size   = (NTHC_INT * (W_bunchsize * (R_bunchsize * (P_bunchsize * V_bunchsize))))
    _M7_size         = (P_bunchsize * (R_bunchsize * (V_bunchsize * NTHC_INT)))
    _M19_size        = (P_bunchsize * (V_bunchsize * (NTHC_INT * (R_bunchsize * W_bunchsize))))
    _M11_size        = (R_bunchsize * (P_bunchsize * (V_bunchsize * NTHC_INT)))
    _M13_size        = (W_bunchsize * (R_bunchsize * (P_bunchsize * (V_bunchsize * NVIR))))
    # determine the size of each bucket
    # bucket 0
    bucked_0_size    = max(bucked_0_size, _M3_size)
    bucked_0_size    = max(bucked_0_size, _M0_size)
    # bucket 1
    bucked_1_size    = max(bucked_1_size, _M18_size)
    # bucket 2
    bucked_2_size    = max(bucked_2_size, _M2_size)
    bucked_2_size    = max(bucked_2_size, _M1_size)
    bucked_2_size    = max(bucked_2_size, _INPUT_17_sliced_size)
    bucked_2_size    = max(bucked_2_size, _INPUT_19_sliced_size)
    bucked_2_size    = max(bucked_2_size, _M14_size)
    # bucket 3
    bucked_3_size    = max(bucked_3_size, _M6_size)
    # bucket 4
    bucked_4_size    = max(bucked_4_size, _M10_size)
    # bucket 5
    bucked_5_size    = max(bucked_5_size, _INPUT_21_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M0_sliced_size)
    bucked_5_size    = max(bucked_5_size, _INPUT_0_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M8_size)
    bucked_5_size    = max(bucked_5_size, _M15_size)
    bucked_5_size    = max(bucked_5_size, _M16_perm_size)
    bucked_5_size    = max(bucked_5_size, _M18_sliced_size)
    bucked_5_size    = max(bucked_5_size, _INPUT_5_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M12_size)
    bucked_5_size    = max(bucked_5_size, _M20_size)
    # bucket 6
    bucked_6_size    = max(bucked_6_size, _M4_size)
    # bucket 7
    bucked_7_size    = max(bucked_7_size, _M5_size)
    bucked_7_size    = max(bucked_7_size, _M6_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M9_size)
    bucked_7_size    = max(bucked_7_size, _M16_size)
    bucked_7_size    = max(bucked_7_size, _M17_size)
    bucked_7_size    = max(bucked_7_size, _M10_sliced_size)
    bucked_7_size    = max(bucked_7_size, _INPUT_22_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M20_perm_size)
    # bucket 8
    bucked_8_size    = max(bucked_8_size, _M7_size)
    bucked_8_size    = max(bucked_8_size, _M19_size)
    # bucket 9
    bucked_9_size    = max(bucked_9_size, _M11_size)
    bucked_9_size    = max(bucked_9_size, _M13_size)
    # append each bucket size to the output
    output.append(bucked_0_size)
    output.append(bucked_1_size)
    output.append(bucked_2_size)
    output.append(bucked_3_size)
    output.append(bucked_4_size)
    output.append(bucked_5_size)
    output.append(bucked_6_size)
    output.append(bucked_7_size)
    output.append(bucked_8_size)
    output.append(bucked_9_size)
    return output

def RMP3_XX_1_forloop_P_R_naive(Z           : np.ndarray,
                                X_o         : np.ndarray,
                                X_v         : np.ndarray,
                                tau_o       : np.ndarray,
                                tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    t1 = (logger.process_clock(), logger.perf_counter())
    _M3              = np.einsum("kR,kW->RWk"    , _INPUT_7        , _INPUT_20       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.einsum("kU,RWk->URW"   , _INPUT_13       , _M3             )
    del _M3         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M0              = np.einsum("iP,iV->PVi"    , _INPUT_1        , _INPUT_15       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M2              = np.einsum("jR,jV->RVj"    , _INPUT_6        , _INPUT_16       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.einsum("jQ,RVj->QRV"   , _INPUT_3        , _M2             )
    del _M2         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M1              = np.einsum("bP,bV->PVb"    , _INPUT_2        , _INPUT_18       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.einsum("bS,PVb->SPV"   , _INPUT_8        , _M1             )
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M4              = np.einsum("aV,aW->VWa"    , _INPUT_17       , _INPUT_21       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M5              = np.einsum("iW,PVi->WPVi"  , _INPUT_19       , _M0             )
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.einsum("iT,WPVi->TWPV" , _INPUT_11       , _M5             )
    del _M5         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.einsum("PQ,QRV->PRVQ"  , _INPUT_0        , _M6             )
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.einsum("aQ,PRVQ->aPRV" , _INPUT_4        , _M7             )
    del _M7         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9              = np.einsum("VWa,aPRV->WPRVa", _M4             , _M8             )
    del _M4         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.einsum("aT,WPRVa->TWPRV", _INPUT_12       , _M9             )
    del _M9         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.einsum("TWPV,TWPRV->RTWPV", _M14            , _M15            )
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16_perm        = np.transpose(_M16            , (0, 2, 3, 4, 1) )
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.einsum("TU,RWPVT->URWPV", _INPUT_10       , _M16_perm       )
    del _M16_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M19             = np.einsum("URWPV,URW->PVURW", _M17            , _M18            )
    del _M17        
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11             = np.einsum("RS,SPV->RPVS"  , _INPUT_5        , _M10            )
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.einsum("cS,RPVS->cRPV" , _INPUT_9        , _M11            )
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M13             = np.einsum("cW,cRPV->WRPVc", _INPUT_22       , _M12            )
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.einsum("cU,WRPVc->UWRPV", _INPUT_14       , _M13            )
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20_perm        = np.transpose(_M20            , (3, 4, 0, 2, 1) )
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M21             = np.einsum("PVURW,PVURW->" , _M19            , _M20_perm       )
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    return _M21

def RMP3_XX_1_forloop_P_R(Z           : np.ndarray,
                          X_o         : np.ndarray,
                          X_v         : np.ndarray,
                          tau_o       : np.ndarray,
                          tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # step 0 kR,kW->RWk 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_7.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_7.shape[0]),
                                 ctypes.c_int(_INPUT_7.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    # step 1 kU,RWk->URW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_13_reshaped.T, _M3_reshaped.T, c=_M18_reshaped)
    _M18         = _M18_reshaped.reshape(*shape_backup)
    del _M3         
    del _M3_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    # step 2 iP,iV->PVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    # step 3 jR,jV->RVj 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_6.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_6.shape[0]),
                                 ctypes.c_int(_INPUT_6.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    # step 4 jQ,RVj->QRV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6          = _M6_reshaped.reshape(*shape_backup)
    del _M2         
    del _M2_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    # step 5 bP,bV->PVb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    # step 6 bS,PVb->SPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_8.shape[0]
    _INPUT_8_reshaped = _INPUT_8.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_8_reshaped.T, _M1_reshaped.T, c=_M10_reshaped)
    _M10         = _M10_reshaped.reshape(*shape_backup)
    del _M1         
    del _M1_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    # step 7 aV,aW->VWa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M4              = np.ndarray((N_LAPLACE, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_INPUT_21.ctypes.data),
                                 ctypes.c_void_p(_M4.ctypes.data),
                                 ctypes.c_int(_INPUT_17.shape[0]),
                                 ctypes.c_int(_INPUT_17.shape[1]),
                                 ctypes.c_int(_INPUT_21.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    # step 8 iW,PVi->WPVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M5              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19.ctypes.data),
                                   ctypes.c_void_p(_M0.ctypes.data),
                                   ctypes.c_void_p(_M5.ctypes.data),
                                   ctypes.c_int(_INPUT_19.shape[0]),
                                   ctypes.c_int(_INPUT_19.shape[1]),
                                   ctypes.c_int(_M0.shape[0]),
                                   ctypes.c_int(_M0.shape[1]))
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    # step 9 iT,WPVi->TWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M5.shape[0]
    _size_dim_1      = _size_dim_1 * _M5.shape[1]
    _size_dim_1      = _size_dim_1 * _M5.shape[2]
    _M5_reshaped = _M5.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_11_reshaped.T, _M5_reshaped.T, c=_M14_reshaped)
    _M14         = _M14_reshaped.reshape(*shape_backup)
    del _M5         
    del _M5_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    # step 10 PQ,QRV->PRVQ 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                   ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M7.ctypes.data),
                                   ctypes.c_int(_INPUT_0.shape[0]),
                                   ctypes.c_int(_INPUT_0.shape[1]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]))
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    # step 11 aQ,PRVQ->aPRV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.ndarray((NVIR, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _size_dim_1      = _size_dim_1 * _M7.shape[1]
    _size_dim_1      = _size_dim_1 * _M7.shape[2]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M8.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M8.shape[0]
    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_4_reshaped, _M7_reshaped.T, c=_M8_reshaped)
    _M8          = _M8_reshaped.reshape(*shape_backup)
    del _M7         
    del _M7_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    # step 12 VWa,aPRV->WPRVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_2340_13402_wob = getattr(libpbc, "fn_contraction_012_2340_13402_wob", None)
    assert fn_contraction_012_2340_13402_wob is not None
    _M9              = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_012_2340_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                      ctypes.c_void_p(_M8.ctypes.data),
                                      ctypes.c_void_p(_M9.ctypes.data),
                                      ctypes.c_int(_M4.shape[0]),
                                      ctypes.c_int(_M4.shape[1]),
                                      ctypes.c_int(_M4.shape[2]),
                                      ctypes.c_int(_M8.shape[1]),
                                      ctypes.c_int(_M8.shape[2]))
    del _M4         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    # step 13 aT,WPRVa->TWPRV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M9.shape[0]
    _size_dim_1      = _size_dim_1 * _M9.shape[1]
    _size_dim_1      = _size_dim_1 * _M9.shape[2]
    _size_dim_1      = _size_dim_1 * _M9.shape[3]
    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M15.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M15.shape[0]
    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_12_reshaped.T, _M9_reshaped.T, c=_M15_reshaped)
    _M15         = _M15_reshaped.reshape(*shape_backup)
    del _M9         
    del _M9_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    # step 14 TWPV,TWPRV->RTWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_0123_01243_40123_wob = getattr(libpbc, "fn_contraction_0123_01243_40123_wob", None)
    assert fn_contraction_0123_01243_40123_wob is not None
    _M16             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_0123_01243_40123_wob(ctypes.c_void_p(_M14.ctypes.data),
                                        ctypes.c_void_p(_M15.ctypes.data),
                                        ctypes.c_void_p(_M16.ctypes.data),
                                        ctypes.c_int(_M14.shape[0]),
                                        ctypes.c_int(_M14.shape[1]),
                                        ctypes.c_int(_M14.shape[2]),
                                        ctypes.c_int(_M14.shape[3]),
                                        ctypes.c_int(_M15.shape[3]))
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    # step 15 RTWPV->RWPVT 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_02341_wob = getattr(libpbc, "fn_permutation_01234_02341_wob", None)
    assert fn_permutation_01234_02341_wob is not None
    _M16_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_02341_wob(ctypes.c_void_p(_M16.ctypes.data),
                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                   ctypes.c_int(_M16.shape[0]),
                                   ctypes.c_int(_M16.shape[1]),
                                   ctypes.c_int(_M16.shape[2]),
                                   ctypes.c_int(_M16.shape[3]),
                                   ctypes.c_int(_M16.shape[4]))
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    # step 16 TU,RWPVT->URWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M17.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M17.shape[0]
    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
    _M17         = _M17_reshaped.reshape(*shape_backup)
    del _M16_perm   
    del _M16_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    # step 17 URWPV,URW->PVURW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01234_012_34012_wob = getattr(libpbc, "fn_contraction_01234_012_34012_wob", None)
    assert fn_contraction_01234_012_34012_wob is not None
    _M19             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_01234_012_34012_wob(ctypes.c_void_p(_M17.ctypes.data),
                                       ctypes.c_void_p(_M18.ctypes.data),
                                       ctypes.c_void_p(_M19.ctypes.data),
                                       ctypes.c_int(_M17.shape[0]),
                                       ctypes.c_int(_M17.shape[1]),
                                       ctypes.c_int(_M17.shape[2]),
                                       ctypes.c_int(_M17.shape[3]),
                                       ctypes.c_int(_M17.shape[4]))
    del _M17        
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    # step 18 RS,SPV->RPVS 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    _M11             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                   ctypes.c_void_p(_M10.ctypes.data),
                                   ctypes.c_void_p(_M11.ctypes.data),
                                   ctypes.c_int(_INPUT_5.shape[0]),
                                   ctypes.c_int(_INPUT_5.shape[1]),
                                   ctypes.c_int(_M10.shape[1]),
                                   ctypes.c_int(_M10.shape[2]))
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    # step 19 cS,RPVS->cRPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.ndarray((NVIR, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_9.shape[0]
    _INPUT_9_reshaped = _INPUT_9.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M11.shape[0]
    _size_dim_1      = _size_dim_1 * _M11.shape[1]
    _size_dim_1      = _size_dim_1 * _M11.shape[2]
    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M12.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M12.shape[0]
    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_9_reshaped, _M11_reshaped.T, c=_M12_reshaped)
    _M12         = _M12_reshaped.reshape(*shape_backup)
    del _M11        
    del _M11_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    # step 20 cW,cRPV->WRPVc 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    _M13             = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_22.ctypes.data),
                                     ctypes.c_void_p(_M12.ctypes.data),
                                     ctypes.c_void_p(_M13.ctypes.data),
                                     ctypes.c_int(_INPUT_22.shape[0]),
                                     ctypes.c_int(_INPUT_22.shape[1]),
                                     ctypes.c_int(_M12.shape[1]),
                                     ctypes.c_int(_M12.shape[2]),
                                     ctypes.c_int(_M12.shape[3]))
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    # step 21 cU,WRPVc->UWRPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M13.shape[0]
    _size_dim_1      = _size_dim_1 * _M13.shape[1]
    _size_dim_1      = _size_dim_1 * _M13.shape[2]
    _size_dim_1      = _size_dim_1 * _M13.shape[3]
    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_14_reshaped.T, _M13_reshaped.T, c=_M20_reshaped)
    _M20         = _M20_reshaped.reshape(*shape_backup)
    del _M13        
    del _M13_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    # step 22 UWRPV->PVURW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_34021_wob = getattr(libpbc, "fn_permutation_01234_34021_wob", None)
    assert fn_permutation_01234_34021_wob is not None
    _M20_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_permutation_01234_34021_wob(ctypes.c_void_p(_M20.ctypes.data),
                                   ctypes.c_void_p(_M20_perm.ctypes.data),
                                   ctypes.c_int(_M20.shape[0]),
                                   ctypes.c_int(_M20.shape[1]),
                                   ctypes.c_int(_M20.shape[2]),
                                   ctypes.c_int(_M20.shape[3]),
                                   ctypes.c_int(_M20.shape[4]))
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    # step 23 PVURW,PVURW-> 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    _M21             = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20_perm.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(_M21))
    _M21 = _M21.value
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    return _M21

def RMP3_XX_1_forloop_P_R_forloop_P_R(Z           : np.ndarray,
                                      X_o         : np.ndarray,
                                      X_v         : np.ndarray,
                                      tau_o       : np.ndarray,
                                      tau_v       : np.ndarray,
                                      buffer      : np.ndarray,
                                      P_bunchsize = 8,
                                      R_bunchsize = 8,
                                      V_bunchsize = 1,
                                      W_bunchsize = 1,
                                      use_mpi = False):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # fetch function pointers
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    fn_slice_3_1_2 = getattr(libpbc, "fn_slice_3_1_2", None)
    assert fn_slice_3_1_2 is not None
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    fn_contraction_01234_012_34012_wob = getattr(libpbc, "fn_contraction_01234_012_34012_wob", None)
    assert fn_contraction_01234_012_34012_wob is not None
    fn_slice_2_1 = getattr(libpbc, "fn_slice_2_1", None)
    assert fn_slice_2_1 is not None
    fn_slice_2_0 = getattr(libpbc, "fn_slice_2_0", None)
    assert fn_slice_2_0 is not None
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    fn_slice_3_0_1 = getattr(libpbc, "fn_slice_3_0_1", None)
    assert fn_slice_3_0_1 is not None
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    fn_permutation_01234_34021_wob = getattr(libpbc, "fn_permutation_01234_34021_wob", None)
    assert fn_permutation_01234_34021_wob is not None
    fn_permutation_01234_02341_wob = getattr(libpbc, "fn_permutation_01234_02341_wob", None)
    assert fn_permutation_01234_02341_wob is not None
    fn_contraction_012_2340_13402_wob = getattr(libpbc, "fn_contraction_012_2340_13402_wob", None)
    assert fn_contraction_012_2340_13402_wob is not None
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    fn_contraction_0123_01243_40123_wob = getattr(libpbc, "fn_contraction_0123_01243_40123_wob", None)
    assert fn_contraction_0123_01243_40123_wob is not None
    if use_mpi:
        bunchsize = NTHC_INT//comm_size + 1
        P_begin = rank*bunchsize
        P_end = (rank+1)*bunchsize
        P_begin          = min(P_begin, NTHC_INT)
        P_end            = min(P_end, NTHC_INT)
    else:
        P_begin          = 0               
        P_end            = NTHC_INT        
    # preallocate buffer
    bucket_size      = RMP3_XX_1_forloop_P_R_determine_bucket_size_forloop(NVIR = NVIR,
                                                                           NOCC = NOCC,
                                                                           N_LAPLACE = N_LAPLACE,
                                                                           NTHC_INT = NTHC_INT,
                                                                           V_bunchsize = V_bunchsize,
                                                                           W_bunchsize = W_bunchsize,
                                                                           P_bunchsize = P_bunchsize,
                                                                           R_bunchsize = R_bunchsize)
    bufsize_now      = buffer.size     
    _itemsize        = buffer.itemsize 
    offset_now       = 0               
    offset_0         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[0])
    offset_1         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[1])
    offset_2         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[2])
    offset_3         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[3])
    offset_4         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[4])
    offset_5         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[5])
    offset_6         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[6])
    offset_7         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[7])
    offset_8         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[8])
    offset_9         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[9])
    bufsize          = offset_now      
    if (bufsize > bufsize_now):
        buffer           = np.ndarray((bufsize), dtype=np.float64)
    # step   0 start for loop with indices ()
    # step   1 allocate   _M21
    _M21             = 0.0             
    # step   2 kR,kW->RWk
    offset_now       = offset_0        
    _M3_offset       = offset_now      
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M3_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_7.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_7.shape[0]),
                                 ctypes.c_int(_INPUT_7.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    # step   3 kU,RWk->URW
    offset_now       = offset_1        
    _M18_offset      = offset_now      
    _M18             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M18_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_13_reshaped.T, _M3_reshaped.T, c=_M18_reshaped)
    _M18             = _M18_reshaped.reshape(*shape_backup)
    # step   4 iP,iV->PVi
    offset_now       = offset_0        
    _M0_offset       = offset_now      
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M0_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    # step   5 jR,jV->RVj
    offset_now       = offset_2        
    _M2_offset       = offset_now      
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M2_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_6.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_6.shape[0]),
                                 ctypes.c_int(_INPUT_6.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    # step   6 jQ,RVj->QRV
    offset_now       = offset_3        
    _M6_offset       = offset_now      
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M6_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6              = _M6_reshaped.reshape(*shape_backup)
    # step   7 bP,bV->PVb
    offset_now       = offset_2        
    _M1_offset       = offset_now      
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M1_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    # step   8 bS,PVb->SPV
    offset_now       = offset_4        
    _M10_offset      = offset_now      
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M10_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_8.shape[0]
    _INPUT_8_reshaped = _INPUT_8.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_8_reshaped.T, _M1_reshaped.T, c=_M10_reshaped)
    _M10             = _M10_reshaped.reshape(*shape_backup)
    # step   9 start for loop with indices ('V',)
    for V_0, V_1 in lib.prange(0,N_LAPLACE,V_bunchsize):
        # step  10 start for loop with indices ('V', 'W')
        for W_0, W_1 in lib.prange(0,N_LAPLACE,W_bunchsize):
            # step  11 slice _INPUT_17 with indices ['V']
            _INPUT_17_sliced_offset = offset_2        
            _INPUT_17_sliced = np.ndarray((NVIR, (V_1-V_0)), buffer = buffer, offset = _INPUT_17_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_17.ctypes.data),
                         ctypes.c_void_p(_INPUT_17_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_17.shape[0]),
                         ctypes.c_int(_INPUT_17.shape[1]),
                         ctypes.c_int(V_0),
                         ctypes.c_int(V_1))
            # step  12 slice _INPUT_21 with indices ['W']
            _INPUT_21_sliced_offset = offset_5        
            _INPUT_21_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_21_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_21.ctypes.data),
                         ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_21.shape[0]),
                         ctypes.c_int(_INPUT_21.shape[1]),
                         ctypes.c_int(W_0),
                         ctypes.c_int(W_1))
            # step  13 aV,aW->VWa
            offset_now       = offset_6        
            _M4_offset       = offset_now      
            _M4              = np.ndarray(((V_1-V_0), (W_1-W_0), NVIR), buffer = buffer, offset = _M4_offset)
            fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_17_sliced.ctypes.data),
                                         ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                                         ctypes.c_void_p(_M4.ctypes.data),
                                         ctypes.c_int(_INPUT_17_sliced.shape[0]),
                                         ctypes.c_int(_INPUT_17_sliced.shape[1]),
                                         ctypes.c_int(_INPUT_21_sliced.shape[1]))
            # step  14 start for loop with indices ('V', 'W', 'P')
            for P_0, P_1 in lib.prange(P_begin,P_end,P_bunchsize):
                # step  15 slice _INPUT_19 with indices ['W']
                _INPUT_19_sliced_offset = offset_2        
                _INPUT_19_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_19_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_19.ctypes.data),
                             ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_19.shape[0]),
                             ctypes.c_int(_INPUT_19.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  16 slice _M0 with indices ['P', 'V']
                _M0_sliced_offset = offset_5        
                _M0_sliced       = np.ndarray(((P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M0_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M0.ctypes.data),
                               ctypes.c_void_p(_M0_sliced.ctypes.data),
                               ctypes.c_int(_M0.shape[0]),
                               ctypes.c_int(_M0.shape[1]),
                               ctypes.c_int(_M0.shape[2]),
                               ctypes.c_int(P_0),
                               ctypes.c_int(P_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  17 iW,PVi->WPVi
                offset_now       = offset_7        
                _M5_offset       = offset_now      
                _M5              = np.ndarray(((W_1-W_0), (P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M5_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                                               ctypes.c_void_p(_M0_sliced.ctypes.data),
                                               ctypes.c_void_p(_M5.ctypes.data),
                                               ctypes.c_int(_INPUT_19_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_19_sliced.shape[1]),
                                               ctypes.c_int(_M0_sliced.shape[0]),
                                               ctypes.c_int(_M0_sliced.shape[1]))
                # step  18 iT,WPVi->TWPV
                offset_now       = offset_2        
                _M14_offset      = offset_now      
                _M14             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M14_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
                _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M5.shape[0]
                _size_dim_1      = _size_dim_1 * _M5.shape[1]
                _size_dim_1      = _size_dim_1 * _M5.shape[2]
                _M5_reshaped = _M5.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M14.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M14.shape[0]
                _M14_reshaped = _M14.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_11_reshaped.T, _M5_reshaped.T, c=_M14_reshaped)
                _M14             = _M14_reshaped.reshape(*shape_backup)
                # step  19 start for loop with indices ('V', 'W', 'P', 'R')
                for R_0, R_1 in lib.prange(0,NTHC_INT,R_bunchsize):
                    # step  20 slice _INPUT_0 with indices ['P']
                    _INPUT_0_sliced_offset = offset_5        
                    _INPUT_0_sliced  = np.ndarray(((P_1-P_0), NTHC_INT), buffer = buffer, offset = _INPUT_0_sliced_offset)
                    fn_slice_2_0(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                 ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_0.shape[0]),
                                 ctypes.c_int(_INPUT_0.shape[1]),
                                 ctypes.c_int(P_0),
                                 ctypes.c_int(P_1))
                    # step  21 slice _M6 with indices ['R', 'V']
                    _M6_sliced_offset = offset_7        
                    _M6_sliced       = np.ndarray((NTHC_INT, (R_1-R_0), (V_1-V_0)), buffer = buffer, offset = _M6_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                   ctypes.c_int(_M6.shape[0]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]),
                                   ctypes.c_int(R_0),
                                   ctypes.c_int(R_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  22 PQ,QRV->PRVQ
                    offset_now       = offset_8        
                    _M7_offset       = offset_now      
                    _M7              = np.ndarray(((P_1-P_0), (R_1-R_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M7_offset)
                    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M7.ctypes.data),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[2]))
                    # step  23 aQ,PRVQ->aPRV
                    offset_now       = offset_5        
                    _M8_offset       = offset_now      
                    _M8              = np.ndarray((NVIR, (P_1-P_0), (R_1-R_0), (V_1-V_0)), buffer = buffer, offset = _M8_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
                    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M7.shape[0]
                    _size_dim_1      = _size_dim_1 * _M7.shape[1]
                    _size_dim_1      = _size_dim_1 * _M7.shape[2]
                    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M8.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M8.shape[0]
                    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_4_reshaped, _M7_reshaped.T, c=_M8_reshaped)
                    _M8              = _M8_reshaped.reshape(*shape_backup)
                    # step  24 VWa,aPRV->WPRVa
                    offset_now       = offset_7        
                    _M9_offset       = offset_now      
                    _M9              = np.ndarray(((W_1-W_0), (P_1-P_0), (R_1-R_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M9_offset)
                    fn_contraction_012_2340_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                                      ctypes.c_void_p(_M8.ctypes.data),
                                                      ctypes.c_void_p(_M9.ctypes.data),
                                                      ctypes.c_int(_M4.shape[0]),
                                                      ctypes.c_int(_M4.shape[1]),
                                                      ctypes.c_int(_M4.shape[2]),
                                                      ctypes.c_int(_M8.shape[1]),
                                                      ctypes.c_int(_M8.shape[2]))
                    # step  25 aT,WPRVa->TWPRV
                    offset_now       = offset_5        
                    _M15_offset      = offset_now      
                    _M15             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (R_1-R_0), (V_1-V_0)), buffer = buffer, offset = _M15_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
                    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M9.shape[0]
                    _size_dim_1      = _size_dim_1 * _M9.shape[1]
                    _size_dim_1      = _size_dim_1 * _M9.shape[2]
                    _size_dim_1      = _size_dim_1 * _M9.shape[3]
                    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M15.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M15.shape[0]
                    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_12_reshaped.T, _M9_reshaped.T, c=_M15_reshaped)
                    _M15             = _M15_reshaped.reshape(*shape_backup)
                    # step  26 TWPV,TWPRV->RTWPV
                    offset_now       = offset_7        
                    _M16_offset      = offset_now      
                    _M16             = np.ndarray(((R_1-R_0), NTHC_INT, (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M16_offset)
                    fn_contraction_0123_01243_40123_wob(ctypes.c_void_p(_M14.ctypes.data),
                                                        ctypes.c_void_p(_M15.ctypes.data),
                                                        ctypes.c_void_p(_M16.ctypes.data),
                                                        ctypes.c_int(_M14.shape[0]),
                                                        ctypes.c_int(_M14.shape[1]),
                                                        ctypes.c_int(_M14.shape[2]),
                                                        ctypes.c_int(_M14.shape[3]),
                                                        ctypes.c_int(_M15.shape[3]))
                    # step  27 RTWPV->RWPVT
                    _M16_perm_offset = offset_5        
                    _M16_perm        = np.ndarray(((R_1-R_0), (W_1-W_0), (P_1-P_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M16_perm_offset)
                    fn_permutation_01234_02341_wob(ctypes.c_void_p(_M16.ctypes.data),
                                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                                   ctypes.c_int((R_1-R_0)),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  28 TU,RWPVT->URWPV
                    offset_now       = offset_7        
                    _M17_offset      = offset_now      
                    _M17             = np.ndarray((NTHC_INT, (R_1-R_0), (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M17_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
                    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
                    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M17.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M17.shape[0]
                    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
                    _M17             = _M17_reshaped.reshape(*shape_backup)
                    # step  29 slice _M18 with indices ['R', 'W']
                    _M18_sliced_offset = offset_5        
                    _M18_sliced      = np.ndarray((NTHC_INT, (R_1-R_0), (W_1-W_0)), buffer = buffer, offset = _M18_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M18.ctypes.data),
                                   ctypes.c_void_p(_M18_sliced.ctypes.data),
                                   ctypes.c_int(_M18.shape[0]),
                                   ctypes.c_int(_M18.shape[1]),
                                   ctypes.c_int(_M18.shape[2]),
                                   ctypes.c_int(R_0),
                                   ctypes.c_int(R_1),
                                   ctypes.c_int(W_0),
                                   ctypes.c_int(W_1))
                    # step  30 URWPV,URW->PVURW
                    offset_now       = offset_8        
                    _M19_offset      = offset_now      
                    _M19             = np.ndarray(((P_1-P_0), (V_1-V_0), NTHC_INT, (R_1-R_0), (W_1-W_0)), buffer = buffer, offset = _M19_offset)
                    fn_contraction_01234_012_34012_wob(ctypes.c_void_p(_M17.ctypes.data),
                                                       ctypes.c_void_p(_M18_sliced.ctypes.data),
                                                       ctypes.c_void_p(_M19.ctypes.data),
                                                       ctypes.c_int(_M17.shape[0]),
                                                       ctypes.c_int(_M17.shape[1]),
                                                       ctypes.c_int(_M17.shape[2]),
                                                       ctypes.c_int(_M17.shape[3]),
                                                       ctypes.c_int(_M17.shape[4]))
                    # step  31 slice _INPUT_5 with indices ['R']
                    _INPUT_5_sliced_offset = offset_5        
                    _INPUT_5_sliced  = np.ndarray(((R_1-R_0), NTHC_INT), buffer = buffer, offset = _INPUT_5_sliced_offset)
                    fn_slice_2_0(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                 ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_5.shape[0]),
                                 ctypes.c_int(_INPUT_5.shape[1]),
                                 ctypes.c_int(R_0),
                                 ctypes.c_int(R_1))
                    # step  32 slice _M10 with indices ['P', 'V']
                    _M10_sliced_offset = offset_7        
                    _M10_sliced      = np.ndarray((NTHC_INT, (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M10_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M10.ctypes.data),
                                   ctypes.c_void_p(_M10_sliced.ctypes.data),
                                   ctypes.c_int(_M10.shape[0]),
                                   ctypes.c_int(_M10.shape[1]),
                                   ctypes.c_int(_M10.shape[2]),
                                   ctypes.c_int(P_0),
                                   ctypes.c_int(P_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  33 RS,SPV->RPVS
                    offset_now       = offset_9        
                    _M11_offset      = offset_now      
                    _M11             = np.ndarray(((R_1-R_0), (P_1-P_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M11_offset)
                    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M10_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M11.ctypes.data),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[1]),
                                                   ctypes.c_int(_M10_sliced.shape[1]),
                                                   ctypes.c_int(_M10_sliced.shape[2]))
                    # step  34 cS,RPVS->cRPV
                    offset_now       = offset_5        
                    _M12_offset      = offset_now      
                    _M12             = np.ndarray((NVIR, (R_1-R_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M12_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_9.shape[0]
                    _INPUT_9_reshaped = _INPUT_9.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M11.shape[0]
                    _size_dim_1      = _size_dim_1 * _M11.shape[1]
                    _size_dim_1      = _size_dim_1 * _M11.shape[2]
                    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M12.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M12.shape[0]
                    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_9_reshaped, _M11_reshaped.T, c=_M12_reshaped)
                    _M12             = _M12_reshaped.reshape(*shape_backup)
                    # step  35 slice _INPUT_22 with indices ['W']
                    _INPUT_22_sliced_offset = offset_7        
                    _INPUT_22_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_22_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_22.shape[0]),
                                 ctypes.c_int(_INPUT_22.shape[1]),
                                 ctypes.c_int(W_0),
                                 ctypes.c_int(W_1))
                    # step  36 cW,cRPV->WRPVc
                    offset_now       = offset_9        
                    _M13_offset      = offset_now      
                    _M13             = np.ndarray(((W_1-W_0), (R_1-R_0), (P_1-P_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M13_offset)
                    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_22_sliced.ctypes.data),
                                                     ctypes.c_void_p(_M12.ctypes.data),
                                                     ctypes.c_void_p(_M13.ctypes.data),
                                                     ctypes.c_int(_INPUT_22_sliced.shape[0]),
                                                     ctypes.c_int(_INPUT_22_sliced.shape[1]),
                                                     ctypes.c_int(_M12.shape[1]),
                                                     ctypes.c_int(_M12.shape[2]),
                                                     ctypes.c_int(_M12.shape[3]))
                    # step  37 cU,WRPVc->UWRPV
                    offset_now       = offset_5        
                    _M20_offset      = offset_now      
                    _M20             = np.ndarray((NTHC_INT, (W_1-W_0), (R_1-R_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M20_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
                    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M13.shape[0]
                    _size_dim_1      = _size_dim_1 * _M13.shape[1]
                    _size_dim_1      = _size_dim_1 * _M13.shape[2]
                    _size_dim_1      = _size_dim_1 * _M13.shape[3]
                    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M20.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M20.shape[0]
                    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_14_reshaped.T, _M13_reshaped.T, c=_M20_reshaped)
                    _M20             = _M20_reshaped.reshape(*shape_backup)
                    # step  38 UWRPV->PVURW
                    _M20_perm_offset = offset_7        
                    _M20_perm        = np.ndarray(((P_1-P_0), (V_1-V_0), NTHC_INT, (R_1-R_0), (W_1-W_0)), buffer = buffer, offset = _M20_perm_offset)
                    fn_permutation_01234_34021_wob(ctypes.c_void_p(_M20.ctypes.data),
                                                   ctypes.c_void_p(_M20_perm.ctypes.data),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((R_1-R_0)),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  39 PVURW,PVURW->
                    output_tmp       = ctypes.c_double(0.0)
                    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
                           ctypes.c_void_p(_M20_perm.ctypes.data),
                           ctypes.c_int(_M19.size),
                           ctypes.pointer(output_tmp))
                    output_tmp = output_tmp.value
                    _M21 += output_tmp
                # step  40 end   for loop with indices ('V', 'W', 'P', 'R')
            # step  41 end   for loop with indices ('V', 'W', 'P')
        # step  42 end   for loop with indices ('V', 'W')
    # step  43 end   for loop with indices ('V',)
    # clean the final forloop
    # MPI finalize
    if use_mpi:
        _M21 = reduce(_M21, root=0)
        _M21 = bcast(_M21, root=0)
    return _M21

def RMP3_XX_1_forloop_P_U_determine_bucket_size_forloop(NVIR        : int,
                                                        NOCC        : int,
                                                        N_LAPLACE   : int,
                                                        NTHC_INT    : int,
                                                        P_bunchsize = 8,
                                                        U_bunchsize = 8,
                                                        V_bunchsize = 1,
                                                        W_bunchsize = 1):
    # init
    output = []     
    bucked_0_size    = 0               
    bucked_1_size    = 0               
    bucked_2_size    = 0               
    bucked_3_size    = 0               
    bucked_4_size    = 0               
    bucked_5_size    = 0               
    bucked_6_size    = 0               
    bucked_7_size    = 0               
    bucked_8_size    = 0               
    # assign the size of each tensor
    _M2_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M1_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M3_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M0_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M6_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M7_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M8_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _INPUT_17_sliced_size = (NVIR * N_LAPLACE)
    _INPUT_19_sliced_size = (NOCC * N_LAPLACE)
    _M18_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize)))
    _INPUT_21_sliced_size = (NVIR * N_LAPLACE)
    _M0_sliced_size  = (P_bunchsize * (V_bunchsize * NOCC))
    _M7_sliced_size  = (NTHC_INT * (P_bunchsize * V_bunchsize))
    _M10_size        = (NTHC_INT * (P_bunchsize * (V_bunchsize * (U_bunchsize * W_bunchsize))))
    _M11_perm_size   = (P_bunchsize * (V_bunchsize * (NTHC_INT * (U_bunchsize * W_bunchsize))))
    _INPUT_16_sliced_size = (NOCC * N_LAPLACE)
    _M13_perm_size   = (P_bunchsize * (U_bunchsize * (W_bunchsize * (NOCC * V_bunchsize))))
    _INPUT_0_sliced_size = (NTHC_INT * NTHC_INT)
    _M16_size        = (NVIR * (U_bunchsize * (W_bunchsize * (V_bunchsize * P_bunchsize))))
    _M20_size        = (NTHC_INT * (U_bunchsize * (P_bunchsize * (V_bunchsize * W_bunchsize))))
    _INPUT_10_sliced_size = (NTHC_INT * NTHC_INT)
    _M4_size         = (V_bunchsize * (W_bunchsize * NVIR))
    _M5_size         = (W_bunchsize * (P_bunchsize * (V_bunchsize * NOCC)))
    _M8_sliced_size  = (NTHC_INT * (U_bunchsize * W_bunchsize))
    _M6_sliced_size  = (NTHC_INT * (U_bunchsize * W_bunchsize))
    _M12_size        = (NOCC * (P_bunchsize * (V_bunchsize * (U_bunchsize * W_bunchsize))))
    _M14_size        = (NTHC_INT * (P_bunchsize * (U_bunchsize * (W_bunchsize * V_bunchsize))))
    _M17_size        = (U_bunchsize * (P_bunchsize * (V_bunchsize * (W_bunchsize * NVIR))))
    _M20_perm_size   = (NTHC_INT * (U_bunchsize * (P_bunchsize * (V_bunchsize * W_bunchsize))))
    _M9_size         = (P_bunchsize * (V_bunchsize * (U_bunchsize * (W_bunchsize * NTHC_INT))))
    _M11_size        = (P_bunchsize * (V_bunchsize * (NTHC_INT * (U_bunchsize * W_bunchsize))))
    _M13_size        = (P_bunchsize * (U_bunchsize * (W_bunchsize * (NOCC * V_bunchsize))))
    _M15_size        = (U_bunchsize * (W_bunchsize * (V_bunchsize * (P_bunchsize * NTHC_INT))))
    _M19_size        = (U_bunchsize * (W_bunchsize * (P_bunchsize * (V_bunchsize * NTHC_INT))))
    # determine the size of each bucket
    # bucket 0
    bucked_0_size    = max(bucked_0_size, _M2_size)
    bucked_0_size    = max(bucked_0_size, _M1_size)
    bucked_0_size    = max(bucked_0_size, _M3_size)
    bucked_0_size    = max(bucked_0_size, _M0_size)
    # bucket 1
    bucked_1_size    = max(bucked_1_size, _M6_size)
    # bucket 2
    bucked_2_size    = max(bucked_2_size, _M7_size)
    # bucket 3
    bucked_3_size    = max(bucked_3_size, _M8_size)
    # bucket 4
    bucked_4_size    = max(bucked_4_size, _INPUT_17_sliced_size)
    bucked_4_size    = max(bucked_4_size, _INPUT_19_sliced_size)
    bucked_4_size    = max(bucked_4_size, _M18_size)
    # bucket 5
    bucked_5_size    = max(bucked_5_size, _INPUT_21_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M0_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M7_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M10_size)
    bucked_5_size    = max(bucked_5_size, _M11_perm_size)
    bucked_5_size    = max(bucked_5_size, _INPUT_16_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M13_perm_size)
    bucked_5_size    = max(bucked_5_size, _INPUT_0_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M16_size)
    bucked_5_size    = max(bucked_5_size, _M20_size)
    bucked_5_size    = max(bucked_5_size, _INPUT_10_sliced_size)
    # bucket 6
    bucked_6_size    = max(bucked_6_size, _M4_size)
    # bucket 7
    bucked_7_size    = max(bucked_7_size, _M5_size)
    bucked_7_size    = max(bucked_7_size, _M8_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M6_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M12_size)
    bucked_7_size    = max(bucked_7_size, _M14_size)
    bucked_7_size    = max(bucked_7_size, _M17_size)
    bucked_7_size    = max(bucked_7_size, _M20_perm_size)
    # bucket 8
    bucked_8_size    = max(bucked_8_size, _M9_size)
    bucked_8_size    = max(bucked_8_size, _M11_size)
    bucked_8_size    = max(bucked_8_size, _M13_size)
    bucked_8_size    = max(bucked_8_size, _M15_size)
    bucked_8_size    = max(bucked_8_size, _M19_size)
    # append each bucket size to the output
    output.append(bucked_0_size)
    output.append(bucked_1_size)
    output.append(bucked_2_size)
    output.append(bucked_3_size)
    output.append(bucked_4_size)
    output.append(bucked_5_size)
    output.append(bucked_6_size)
    output.append(bucked_7_size)
    output.append(bucked_8_size)
    return output

def RMP3_XX_1_forloop_P_U_naive(Z           : np.ndarray,
                                X_o         : np.ndarray,
                                X_v         : np.ndarray,
                                tau_o       : np.ndarray,
                                tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    t1 = (logger.process_clock(), logger.perf_counter())
    _M2              = np.einsum("kU,kW->UWk"    , _INPUT_13       , _INPUT_20       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.einsum("kR,UWk->RUW"   , _INPUT_7        , _M2             )
    del _M2         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M1              = np.einsum("bP,bV->PVb"    , _INPUT_2        , _INPUT_18       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.einsum("bS,PVb->SPV"   , _INPUT_8        , _M1             )
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M3              = np.einsum("cU,cW->UWc"    , _INPUT_14       , _INPUT_22       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.einsum("cS,UWc->SUW"   , _INPUT_9        , _M3             )
    del _M3         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M0              = np.einsum("iP,iV->PVi"    , _INPUT_1        , _INPUT_15       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M4              = np.einsum("aV,aW->VWa"    , _INPUT_17       , _INPUT_21       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M5              = np.einsum("iW,PVi->WPVi"  , _INPUT_19       , _M0             )
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.einsum("iT,WPVi->TWPV" , _INPUT_11       , _M5             )
    del _M5         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9              = np.einsum("SPV,SUW->PVUWS", _M7             , _M8             )
    del _M7         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.einsum("RS,PVUWS->RPVUW", _INPUT_5        , _M9             )
    del _M9         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11             = np.einsum("RUW,RPVUW->PVRUW", _M6             , _M10            )
    del _M6         
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11_perm        = np.transpose(_M11            , (0, 1, 3, 4, 2) )
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.einsum("jR,PVUWR->jPVUW", _INPUT_6        , _M11_perm       )
    del _M11_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M13             = np.einsum("jV,jPVUW->PUWjV", _INPUT_16       , _M12            )
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M13_perm        = np.transpose(_M13            , (0, 1, 2, 4, 3) )
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.einsum("jQ,PUWVj->QPUWV", _INPUT_3        , _M13_perm       )
    del _M13_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.einsum("PQ,QPUWV->UWVPQ", _INPUT_0        , _M14            )
    del _M14        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.einsum("aQ,UWVPQ->aUWVP", _INPUT_4        , _M15            )
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.einsum("VWa,aUWVP->UPVWa", _M4             , _M16            )
    del _M4         
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.einsum("aT,UPVWa->TUPVW", _INPUT_12       , _M17            )
    del _M17        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20_perm        = np.transpose(_M20            , (1, 4, 2, 3, 0) )
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M19             = np.einsum("TU,TWPV->UWPVT", _INPUT_10       , _M18            )
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M21             = np.einsum("UWPVT,UWPVT->" , _M19            , _M20_perm       )
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 25")
    return _M21

def RMP3_XX_1_forloop_P_U(Z           : np.ndarray,
                          X_o         : np.ndarray,
                          X_v         : np.ndarray,
                          tau_o       : np.ndarray,
                          tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # step 0 kU,kW->UWk 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_13.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_13.shape[0]),
                                 ctypes.c_int(_INPUT_13.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    # step 1 kR,UWk->RUW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_7_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6          = _M6_reshaped.reshape(*shape_backup)
    del _M2         
    del _M2_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    # step 2 bP,bV->PVb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    # step 3 bS,PVb->SPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_8.shape[0]
    _INPUT_8_reshaped = _INPUT_8.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M7.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_8_reshaped.T, _M1_reshaped.T, c=_M7_reshaped)
    _M7          = _M7_reshaped.reshape(*shape_backup)
    del _M1         
    del _M1_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    # step 4 cU,cW->UWc 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_14.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_14.shape[0]),
                                 ctypes.c_int(_INPUT_14.shape[1]),
                                 ctypes.c_int(_INPUT_22.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    # step 5 cS,UWc->SUW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_9.shape[0]
    _INPUT_9_reshaped = _INPUT_9.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M8.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M8.shape[0]
    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_9_reshaped.T, _M3_reshaped.T, c=_M8_reshaped)
    _M8          = _M8_reshaped.reshape(*shape_backup)
    del _M3         
    del _M3_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    # step 6 iP,iV->PVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    # step 7 aV,aW->VWa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M4              = np.ndarray((N_LAPLACE, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_INPUT_21.ctypes.data),
                                 ctypes.c_void_p(_M4.ctypes.data),
                                 ctypes.c_int(_INPUT_17.shape[0]),
                                 ctypes.c_int(_INPUT_17.shape[1]),
                                 ctypes.c_int(_INPUT_21.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    # step 8 iW,PVi->WPVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M5              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19.ctypes.data),
                                   ctypes.c_void_p(_M0.ctypes.data),
                                   ctypes.c_void_p(_M5.ctypes.data),
                                   ctypes.c_int(_INPUT_19.shape[0]),
                                   ctypes.c_int(_INPUT_19.shape[1]),
                                   ctypes.c_int(_M0.shape[0]),
                                   ctypes.c_int(_M0.shape[1]))
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    # step 9 iT,WPVi->TWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M5.shape[0]
    _size_dim_1      = _size_dim_1 * _M5.shape[1]
    _size_dim_1      = _size_dim_1 * _M5.shape[2]
    _M5_reshaped = _M5.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_11_reshaped.T, _M5_reshaped.T, c=_M18_reshaped)
    _M18         = _M18_reshaped.reshape(*shape_backup)
    del _M5         
    del _M5_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    # step 10 SPV,SUW->PVUWS 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_034_12340_wob = getattr(libpbc, "fn_contraction_012_034_12340_wob", None)
    assert fn_contraction_012_034_12340_wob is not None
    _M9              = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_012_034_12340_wob(ctypes.c_void_p(_M7.ctypes.data),
                                     ctypes.c_void_p(_M8.ctypes.data),
                                     ctypes.c_void_p(_M9.ctypes.data),
                                     ctypes.c_int(_M7.shape[0]),
                                     ctypes.c_int(_M7.shape[1]),
                                     ctypes.c_int(_M7.shape[2]),
                                     ctypes.c_int(_M8.shape[1]),
                                     ctypes.c_int(_M8.shape[2]))
    del _M7         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    # step 11 RS,PVUWS->RPVUW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_5.shape[0]
    _INPUT_5_reshaped = _INPUT_5.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M9.shape[0]
    _size_dim_1      = _size_dim_1 * _M9.shape[1]
    _size_dim_1      = _size_dim_1 * _M9.shape[2]
    _size_dim_1      = _size_dim_1 * _M9.shape[3]
    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_5_reshaped, _M9_reshaped.T, c=_M10_reshaped)
    _M10         = _M10_reshaped.reshape(*shape_backup)
    del _M9         
    del _M9_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    # step 12 RUW,RPVUW->PVRUW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_03412_34012_wob = getattr(libpbc, "fn_contraction_012_03412_34012_wob", None)
    assert fn_contraction_012_03412_34012_wob is not None
    _M11             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_012_03412_34012_wob(ctypes.c_void_p(_M6.ctypes.data),
                                       ctypes.c_void_p(_M10.ctypes.data),
                                       ctypes.c_void_p(_M11.ctypes.data),
                                       ctypes.c_int(_M6.shape[0]),
                                       ctypes.c_int(_M6.shape[1]),
                                       ctypes.c_int(_M6.shape[2]),
                                       ctypes.c_int(_M10.shape[1]),
                                       ctypes.c_int(_M10.shape[2]))
    del _M6         
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    # step 13 PVRUW->PVUWR 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_01342_wob = getattr(libpbc, "fn_permutation_01234_01342_wob", None)
    assert fn_permutation_01234_01342_wob is not None
    _M11_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_01342_wob(ctypes.c_void_p(_M11.ctypes.data),
                                   ctypes.c_void_p(_M11_perm.ctypes.data),
                                   ctypes.c_int(_M11.shape[0]),
                                   ctypes.c_int(_M11.shape[1]),
                                   ctypes.c_int(_M11.shape[2]),
                                   ctypes.c_int(_M11.shape[3]),
                                   ctypes.c_int(_M11.shape[4]))
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    # step 14 jR,PVUWR->jPVUW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.ndarray((NOCC, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[3]
    _M11_perm_reshaped = _M11_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M12.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M12.shape[0]
    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_6_reshaped, _M11_perm_reshaped.T, c=_M12_reshaped)
    _M12         = _M12_reshaped.reshape(*shape_backup)
    del _M11_perm   
    del _M11_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    # step 15 jV,jPVUW->PUWjV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02134_23401_wob = getattr(libpbc, "fn_contraction_01_02134_23401_wob", None)
    assert fn_contraction_01_02134_23401_wob is not None
    _M13             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NOCC, N_LAPLACE), dtype=np.float64)
    fn_contraction_01_02134_23401_wob(ctypes.c_void_p(_INPUT_16.ctypes.data),
                                      ctypes.c_void_p(_M12.ctypes.data),
                                      ctypes.c_void_p(_M13.ctypes.data),
                                      ctypes.c_int(_INPUT_16.shape[0]),
                                      ctypes.c_int(_INPUT_16.shape[1]),
                                      ctypes.c_int(_M12.shape[1]),
                                      ctypes.c_int(_M12.shape[3]),
                                      ctypes.c_int(_M12.shape[4]))
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    # step 16 PUWjV->PUWVj 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_01243_wob = getattr(libpbc, "fn_permutation_01234_01243_wob", None)
    assert fn_permutation_01234_01243_wob is not None
    _M13_perm        = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE, NOCC), dtype=np.float64)
    fn_permutation_01234_01243_wob(ctypes.c_void_p(_M13.ctypes.data),
                                   ctypes.c_void_p(_M13_perm.ctypes.data),
                                   ctypes.c_int(_M13.shape[0]),
                                   ctypes.c_int(_M13.shape[1]),
                                   ctypes.c_int(_M13.shape[2]),
                                   ctypes.c_int(_M13.shape[3]),
                                   ctypes.c_int(_M13.shape[4]))
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    # step 17 jQ,PUWVj->QPUWV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.ndarray((NTHC_INT, NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M13_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M13_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M13_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M13_perm.shape[3]
    _M13_perm_reshaped = _M13_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped.T, _M13_perm_reshaped.T, c=_M14_reshaped)
    _M14         = _M14_reshaped.reshape(*shape_backup)
    del _M13_perm   
    del _M13_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    # step 18 PQ,QPUWV->UWVPQ 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_10234_23401_wob = getattr(libpbc, "fn_contraction_01_10234_23401_wob", None)
    assert fn_contraction_01_10234_23401_wob is not None
    _M15             = np.ndarray((NTHC_INT, N_LAPLACE, N_LAPLACE, NTHC_INT, NTHC_INT), dtype=np.float64)
    fn_contraction_01_10234_23401_wob(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                      ctypes.c_void_p(_M14.ctypes.data),
                                      ctypes.c_void_p(_M15.ctypes.data),
                                      ctypes.c_int(_INPUT_0.shape[0]),
                                      ctypes.c_int(_INPUT_0.shape[1]),
                                      ctypes.c_int(_M14.shape[2]),
                                      ctypes.c_int(_M14.shape[3]),
                                      ctypes.c_int(_M14.shape[4]))
    del _M14        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    # step 19 aQ,UWVPQ->aUWVP 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.ndarray((NVIR, NTHC_INT, N_LAPLACE, N_LAPLACE, NTHC_INT), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M15.shape[0]
    _size_dim_1      = _size_dim_1 * _M15.shape[1]
    _size_dim_1      = _size_dim_1 * _M15.shape[2]
    _size_dim_1      = _size_dim_1 * _M15.shape[3]
    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M16.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M16.shape[0]
    _M16_reshaped = _M16.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_4_reshaped, _M15_reshaped.T, c=_M16_reshaped)
    _M16         = _M16_reshaped.reshape(*shape_backup)
    del _M15        
    del _M15_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    # step 20 VWa,aUWVP->UPVWa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_23104_34012_wob = getattr(libpbc, "fn_contraction_012_23104_34012_wob", None)
    assert fn_contraction_012_23104_34012_wob is not None
    _M17             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_012_23104_34012_wob(ctypes.c_void_p(_M4.ctypes.data),
                                       ctypes.c_void_p(_M16.ctypes.data),
                                       ctypes.c_void_p(_M17.ctypes.data),
                                       ctypes.c_int(_M4.shape[0]),
                                       ctypes.c_int(_M4.shape[1]),
                                       ctypes.c_int(_M4.shape[2]),
                                       ctypes.c_int(_M16.shape[1]),
                                       ctypes.c_int(_M16.shape[4]))
    del _M4         
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    # step 21 aT,UPVWa->TUPVW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.ndarray((NTHC_INT, NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M17.shape[0]
    _size_dim_1      = _size_dim_1 * _M17.shape[1]
    _size_dim_1      = _size_dim_1 * _M17.shape[2]
    _size_dim_1      = _size_dim_1 * _M17.shape[3]
    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_12_reshaped.T, _M17_reshaped.T, c=_M20_reshaped)
    _M20         = _M20_reshaped.reshape(*shape_backup)
    del _M17        
    del _M17_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    # step 22 TUPVW->UWPVT 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_14230_wob = getattr(libpbc, "fn_permutation_01234_14230_wob", None)
    assert fn_permutation_01234_14230_wob is not None
    _M20_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_14230_wob(ctypes.c_void_p(_M20.ctypes.data),
                                   ctypes.c_void_p(_M20_perm.ctypes.data),
                                   ctypes.c_int(_M20.shape[0]),
                                   ctypes.c_int(_M20.shape[1]),
                                   ctypes.c_int(_M20.shape[2]),
                                   ctypes.c_int(_M20.shape[3]),
                                   ctypes.c_int(_M20.shape[4]))
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    # step 23 TU,TWPV->UWPVT 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    _M19             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_10.ctypes.data),
                                     ctypes.c_void_p(_M18.ctypes.data),
                                     ctypes.c_void_p(_M19.ctypes.data),
                                     ctypes.c_int(_INPUT_10.shape[0]),
                                     ctypes.c_int(_INPUT_10.shape[1]),
                                     ctypes.c_int(_M18.shape[1]),
                                     ctypes.c_int(_M18.shape[2]),
                                     ctypes.c_int(_M18.shape[3]))
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    # step 24 UWPVT,UWPVT-> 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    _M21             = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20_perm.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(_M21))
    _M21 = _M21.value
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 25")
    return _M21

def RMP3_XX_1_forloop_P_U_forloop_P_U(Z           : np.ndarray,
                                      X_o         : np.ndarray,
                                      X_v         : np.ndarray,
                                      tau_o       : np.ndarray,
                                      tau_v       : np.ndarray,
                                      buffer      : np.ndarray,
                                      P_bunchsize = 8,
                                      U_bunchsize = 8,
                                      V_bunchsize = 1,
                                      W_bunchsize = 1,
                                      use_mpi = False):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # fetch function pointers
    fn_contraction_012_23104_34012_wob = getattr(libpbc, "fn_contraction_012_23104_34012_wob", None)
    assert fn_contraction_012_23104_34012_wob is not None
    fn_permutation_01234_01342_wob = getattr(libpbc, "fn_permutation_01234_01342_wob", None)
    assert fn_permutation_01234_01342_wob is not None
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    fn_slice_3_1_2 = getattr(libpbc, "fn_slice_3_1_2", None)
    assert fn_slice_3_1_2 is not None
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    fn_slice_2_1 = getattr(libpbc, "fn_slice_2_1", None)
    assert fn_slice_2_1 is not None
    fn_slice_2_0 = getattr(libpbc, "fn_slice_2_0", None)
    assert fn_slice_2_0 is not None
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    fn_slice_3_0_1 = getattr(libpbc, "fn_slice_3_0_1", None)
    assert fn_slice_3_0_1 is not None
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    fn_contraction_01_10234_23401_wob = getattr(libpbc, "fn_contraction_01_10234_23401_wob", None)
    assert fn_contraction_01_10234_23401_wob is not None
    fn_contraction_01_02134_23401_wob = getattr(libpbc, "fn_contraction_01_02134_23401_wob", None)
    assert fn_contraction_01_02134_23401_wob is not None
    fn_permutation_01234_14230_wob = getattr(libpbc, "fn_permutation_01234_14230_wob", None)
    assert fn_permutation_01234_14230_wob is not None
    fn_permutation_01234_01243_wob = getattr(libpbc, "fn_permutation_01234_01243_wob", None)
    assert fn_permutation_01234_01243_wob is not None
    fn_contraction_012_034_12340_wob = getattr(libpbc, "fn_contraction_012_034_12340_wob", None)
    assert fn_contraction_012_034_12340_wob is not None
    fn_contraction_012_03412_34012_wob = getattr(libpbc, "fn_contraction_012_03412_34012_wob", None)
    assert fn_contraction_012_03412_34012_wob is not None
    if use_mpi:
        bunchsize = NTHC_INT//comm_size + 1
        P_begin = rank*bunchsize
        P_end = (rank+1)*bunchsize
        P_begin          = min(P_begin, NTHC_INT)
        P_end            = min(P_end, NTHC_INT)
    else:
        P_begin          = 0               
        P_end            = NTHC_INT        
    # preallocate buffer
    bucket_size      = RMP3_XX_1_forloop_P_U_determine_bucket_size_forloop(NVIR = NVIR,
                                                                           NOCC = NOCC,
                                                                           N_LAPLACE = N_LAPLACE,
                                                                           NTHC_INT = NTHC_INT,
                                                                           V_bunchsize = V_bunchsize,
                                                                           W_bunchsize = W_bunchsize,
                                                                           P_bunchsize = P_bunchsize,
                                                                           U_bunchsize = U_bunchsize)
    bufsize_now      = buffer.size     
    _itemsize        = buffer.itemsize 
    offset_now       = 0               
    offset_0         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[0])
    offset_1         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[1])
    offset_2         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[2])
    offset_3         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[3])
    offset_4         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[4])
    offset_5         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[5])
    offset_6         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[6])
    offset_7         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[7])
    offset_8         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[8])
    bufsize          = offset_now      
    if (bufsize > bufsize_now):
        buffer           = np.ndarray((bufsize), dtype=np.float64)
    # step   0 start for loop with indices ()
    # step   1 allocate   _M21
    _M21             = 0.0             
    # step   2 kU,kW->UWk
    offset_now       = offset_0        
    _M2_offset       = offset_now      
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M2_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_13.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_13.shape[0]),
                                 ctypes.c_int(_INPUT_13.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    # step   3 kR,UWk->RUW
    offset_now       = offset_1        
    _M6_offset       = offset_now      
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M6_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_7_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6              = _M6_reshaped.reshape(*shape_backup)
    # step   4 bP,bV->PVb
    offset_now       = offset_0        
    _M1_offset       = offset_now      
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M1_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    # step   5 bS,PVb->SPV
    offset_now       = offset_2        
    _M7_offset       = offset_now      
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M7_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_8.shape[0]
    _INPUT_8_reshaped = _INPUT_8.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M7.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_8_reshaped.T, _M1_reshaped.T, c=_M7_reshaped)
    _M7              = _M7_reshaped.reshape(*shape_backup)
    # step   6 cU,cW->UWc
    offset_now       = offset_0        
    _M3_offset       = offset_now      
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M3_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_14.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_14.shape[0]),
                                 ctypes.c_int(_INPUT_14.shape[1]),
                                 ctypes.c_int(_INPUT_22.shape[1]))
    # step   7 cS,UWc->SUW
    offset_now       = offset_3        
    _M8_offset       = offset_now      
    _M8              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M8_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_9.shape[0]
    _INPUT_9_reshaped = _INPUT_9.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M8.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M8.shape[0]
    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_9_reshaped.T, _M3_reshaped.T, c=_M8_reshaped)
    _M8              = _M8_reshaped.reshape(*shape_backup)
    # step   8 iP,iV->PVi
    offset_now       = offset_0        
    _M0_offset       = offset_now      
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M0_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    # step   9 start for loop with indices ('V',)
    for V_0, V_1 in lib.prange(0,N_LAPLACE,V_bunchsize):
        # step  10 start for loop with indices ('V', 'W')
        for W_0, W_1 in lib.prange(0,N_LAPLACE,W_bunchsize):
            # step  11 slice _INPUT_17 with indices ['V']
            _INPUT_17_sliced_offset = offset_4        
            _INPUT_17_sliced = np.ndarray((NVIR, (V_1-V_0)), buffer = buffer, offset = _INPUT_17_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_17.ctypes.data),
                         ctypes.c_void_p(_INPUT_17_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_17.shape[0]),
                         ctypes.c_int(_INPUT_17.shape[1]),
                         ctypes.c_int(V_0),
                         ctypes.c_int(V_1))
            # step  12 slice _INPUT_21 with indices ['W']
            _INPUT_21_sliced_offset = offset_5        
            _INPUT_21_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_21_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_21.ctypes.data),
                         ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_21.shape[0]),
                         ctypes.c_int(_INPUT_21.shape[1]),
                         ctypes.c_int(W_0),
                         ctypes.c_int(W_1))
            # step  13 aV,aW->VWa
            offset_now       = offset_6        
            _M4_offset       = offset_now      
            _M4              = np.ndarray(((V_1-V_0), (W_1-W_0), NVIR), buffer = buffer, offset = _M4_offset)
            fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_17_sliced.ctypes.data),
                                         ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                                         ctypes.c_void_p(_M4.ctypes.data),
                                         ctypes.c_int(_INPUT_17_sliced.shape[0]),
                                         ctypes.c_int(_INPUT_17_sliced.shape[1]),
                                         ctypes.c_int(_INPUT_21_sliced.shape[1]))
            # step  14 start for loop with indices ('V', 'W', 'P')
            for P_0, P_1 in lib.prange(P_begin,P_end,P_bunchsize):
                # step  15 slice _INPUT_19 with indices ['W']
                _INPUT_19_sliced_offset = offset_4        
                _INPUT_19_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_19_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_19.ctypes.data),
                             ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_19.shape[0]),
                             ctypes.c_int(_INPUT_19.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  16 slice _M0 with indices ['P', 'V']
                _M0_sliced_offset = offset_5        
                _M0_sliced       = np.ndarray(((P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M0_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M0.ctypes.data),
                               ctypes.c_void_p(_M0_sliced.ctypes.data),
                               ctypes.c_int(_M0.shape[0]),
                               ctypes.c_int(_M0.shape[1]),
                               ctypes.c_int(_M0.shape[2]),
                               ctypes.c_int(P_0),
                               ctypes.c_int(P_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  17 iW,PVi->WPVi
                offset_now       = offset_7        
                _M5_offset       = offset_now      
                _M5              = np.ndarray(((W_1-W_0), (P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M5_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                                               ctypes.c_void_p(_M0_sliced.ctypes.data),
                                               ctypes.c_void_p(_M5.ctypes.data),
                                               ctypes.c_int(_INPUT_19_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_19_sliced.shape[1]),
                                               ctypes.c_int(_M0_sliced.shape[0]),
                                               ctypes.c_int(_M0_sliced.shape[1]))
                # step  18 iT,WPVi->TWPV
                offset_now       = offset_4        
                _M18_offset      = offset_now      
                _M18             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M18_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
                _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M5.shape[0]
                _size_dim_1      = _size_dim_1 * _M5.shape[1]
                _size_dim_1      = _size_dim_1 * _M5.shape[2]
                _M5_reshaped = _M5.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M18.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M18.shape[0]
                _M18_reshaped = _M18.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_11_reshaped.T, _M5_reshaped.T, c=_M18_reshaped)
                _M18             = _M18_reshaped.reshape(*shape_backup)
                # step  19 start for loop with indices ('V', 'W', 'P', 'U')
                for U_0, U_1 in lib.prange(0,NTHC_INT,U_bunchsize):
                    # step  20 slice _M7 with indices ['P', 'V']
                    _M7_sliced_offset = offset_5        
                    _M7_sliced       = np.ndarray((NTHC_INT, (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M7_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M7.ctypes.data),
                                   ctypes.c_void_p(_M7_sliced.ctypes.data),
                                   ctypes.c_int(_M7.shape[0]),
                                   ctypes.c_int(_M7.shape[1]),
                                   ctypes.c_int(_M7.shape[2]),
                                   ctypes.c_int(P_0),
                                   ctypes.c_int(P_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  21 slice _M8 with indices ['U', 'W']
                    _M8_sliced_offset = offset_7        
                    _M8_sliced       = np.ndarray((NTHC_INT, (U_1-U_0), (W_1-W_0)), buffer = buffer, offset = _M8_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M8.ctypes.data),
                                   ctypes.c_void_p(_M8_sliced.ctypes.data),
                                   ctypes.c_int(_M8.shape[0]),
                                   ctypes.c_int(_M8.shape[1]),
                                   ctypes.c_int(_M8.shape[2]),
                                   ctypes.c_int(U_0),
                                   ctypes.c_int(U_1),
                                   ctypes.c_int(W_0),
                                   ctypes.c_int(W_1))
                    # step  22 SPV,SUW->PVUWS
                    offset_now       = offset_8        
                    _M9_offset       = offset_now      
                    _M9              = np.ndarray(((P_1-P_0), (V_1-V_0), (U_1-U_0), (W_1-W_0), NTHC_INT), buffer = buffer, offset = _M9_offset)
                    fn_contraction_012_034_12340_wob(ctypes.c_void_p(_M7_sliced.ctypes.data),
                                                     ctypes.c_void_p(_M8_sliced.ctypes.data),
                                                     ctypes.c_void_p(_M9.ctypes.data),
                                                     ctypes.c_int(_M7_sliced.shape[0]),
                                                     ctypes.c_int(_M7_sliced.shape[1]),
                                                     ctypes.c_int(_M7_sliced.shape[2]),
                                                     ctypes.c_int(_M8_sliced.shape[1]),
                                                     ctypes.c_int(_M8_sliced.shape[2]))
                    # step  23 RS,PVUWS->RPVUW
                    offset_now       = offset_5        
                    _M10_offset      = offset_now      
                    _M10             = np.ndarray((NTHC_INT, (P_1-P_0), (V_1-V_0), (U_1-U_0), (W_1-W_0)), buffer = buffer, offset = _M10_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_5.shape[0]
                    _INPUT_5_reshaped = _INPUT_5.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M9.shape[0]
                    _size_dim_1      = _size_dim_1 * _M9.shape[1]
                    _size_dim_1      = _size_dim_1 * _M9.shape[2]
                    _size_dim_1      = _size_dim_1 * _M9.shape[3]
                    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M10.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M10.shape[0]
                    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_5_reshaped, _M9_reshaped.T, c=_M10_reshaped)
                    _M10             = _M10_reshaped.reshape(*shape_backup)
                    # step  24 slice _M6 with indices ['U', 'W']
                    _M6_sliced_offset = offset_7        
                    _M6_sliced       = np.ndarray((NTHC_INT, (U_1-U_0), (W_1-W_0)), buffer = buffer, offset = _M6_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                   ctypes.c_int(_M6.shape[0]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]),
                                   ctypes.c_int(U_0),
                                   ctypes.c_int(U_1),
                                   ctypes.c_int(W_0),
                                   ctypes.c_int(W_1))
                    # step  25 RUW,RPVUW->PVRUW
                    offset_now       = offset_8        
                    _M11_offset      = offset_now      
                    _M11             = np.ndarray(((P_1-P_0), (V_1-V_0), NTHC_INT, (U_1-U_0), (W_1-W_0)), buffer = buffer, offset = _M11_offset)
                    fn_contraction_012_03412_34012_wob(ctypes.c_void_p(_M6_sliced.ctypes.data),
                                                       ctypes.c_void_p(_M10.ctypes.data),
                                                       ctypes.c_void_p(_M11.ctypes.data),
                                                       ctypes.c_int(_M6_sliced.shape[0]),
                                                       ctypes.c_int(_M6_sliced.shape[1]),
                                                       ctypes.c_int(_M6_sliced.shape[2]),
                                                       ctypes.c_int(_M10.shape[1]),
                                                       ctypes.c_int(_M10.shape[2]))
                    # step  26 PVRUW->PVUWR
                    _M11_perm_offset = offset_5        
                    _M11_perm        = np.ndarray(((P_1-P_0), (V_1-V_0), (U_1-U_0), (W_1-W_0), NTHC_INT), buffer = buffer, offset = _M11_perm_offset)
                    fn_permutation_01234_01342_wob(ctypes.c_void_p(_M11.ctypes.data),
                                                   ctypes.c_void_p(_M11_perm.ctypes.data),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((V_1-V_0)),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((U_1-U_0)),
                                                   ctypes.c_int((W_1-W_0)))
                    # step  27 jR,PVUWR->jPVUW
                    offset_now       = offset_7        
                    _M12_offset      = offset_now      
                    _M12             = np.ndarray((NOCC, (P_1-P_0), (V_1-V_0), (U_1-U_0), (W_1-W_0)), buffer = buffer, offset = _M12_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
                    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[3]
                    _M11_perm_reshaped = _M11_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M12.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M12.shape[0]
                    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_6_reshaped, _M11_perm_reshaped.T, c=_M12_reshaped)
                    _M12             = _M12_reshaped.reshape(*shape_backup)
                    # step  28 slice _INPUT_16 with indices ['V']
                    _INPUT_16_sliced_offset = offset_5        
                    _INPUT_16_sliced = np.ndarray((NOCC, (V_1-V_0)), buffer = buffer, offset = _INPUT_16_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_16.shape[0]),
                                 ctypes.c_int(_INPUT_16.shape[1]),
                                 ctypes.c_int(V_0),
                                 ctypes.c_int(V_1))
                    # step  29 jV,jPVUW->PUWjV
                    offset_now       = offset_8        
                    _M13_offset      = offset_now      
                    _M13             = np.ndarray(((P_1-P_0), (U_1-U_0), (W_1-W_0), NOCC, (V_1-V_0)), buffer = buffer, offset = _M13_offset)
                    fn_contraction_01_02134_23401_wob(ctypes.c_void_p(_INPUT_16_sliced.ctypes.data),
                                                      ctypes.c_void_p(_M12.ctypes.data),
                                                      ctypes.c_void_p(_M13.ctypes.data),
                                                      ctypes.c_int(_INPUT_16_sliced.shape[0]),
                                                      ctypes.c_int(_INPUT_16_sliced.shape[1]),
                                                      ctypes.c_int(_M12.shape[1]),
                                                      ctypes.c_int(_M12.shape[3]),
                                                      ctypes.c_int(_M12.shape[4]))
                    # step  30 PUWjV->PUWVj
                    _M13_perm_offset = offset_5        
                    _M13_perm        = np.ndarray(((P_1-P_0), (U_1-U_0), (W_1-W_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M13_perm_offset)
                    fn_permutation_01234_01243_wob(ctypes.c_void_p(_M13.ctypes.data),
                                                   ctypes.c_void_p(_M13_perm.ctypes.data),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((U_1-U_0)),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int(NOCC),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  31 jQ,PUWVj->QPUWV
                    offset_now       = offset_7        
                    _M14_offset      = offset_now      
                    _M14             = np.ndarray((NTHC_INT, (P_1-P_0), (U_1-U_0), (W_1-W_0), (V_1-V_0)), buffer = buffer, offset = _M14_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
                    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M13_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M13_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M13_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M13_perm.shape[3]
                    _M13_perm_reshaped = _M13_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M14.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M14.shape[0]
                    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_3_reshaped.T, _M13_perm_reshaped.T, c=_M14_reshaped)
                    _M14             = _M14_reshaped.reshape(*shape_backup)
                    # step  32 slice _INPUT_0 with indices ['P']
                    _INPUT_0_sliced_offset = offset_5        
                    _INPUT_0_sliced  = np.ndarray(((P_1-P_0), NTHC_INT), buffer = buffer, offset = _INPUT_0_sliced_offset)
                    fn_slice_2_0(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                 ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_0.shape[0]),
                                 ctypes.c_int(_INPUT_0.shape[1]),
                                 ctypes.c_int(P_0),
                                 ctypes.c_int(P_1))
                    # step  33 PQ,QPUWV->UWVPQ
                    offset_now       = offset_8        
                    _M15_offset      = offset_now      
                    _M15             = np.ndarray(((U_1-U_0), (W_1-W_0), (V_1-V_0), (P_1-P_0), NTHC_INT), buffer = buffer, offset = _M15_offset)
                    fn_contraction_01_10234_23401_wob(ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                                      ctypes.c_void_p(_M14.ctypes.data),
                                                      ctypes.c_void_p(_M15.ctypes.data),
                                                      ctypes.c_int(_INPUT_0_sliced.shape[0]),
                                                      ctypes.c_int(_INPUT_0_sliced.shape[1]),
                                                      ctypes.c_int(_M14.shape[2]),
                                                      ctypes.c_int(_M14.shape[3]),
                                                      ctypes.c_int(_M14.shape[4]))
                    # step  34 aQ,UWVPQ->aUWVP
                    offset_now       = offset_5        
                    _M16_offset      = offset_now      
                    _M16             = np.ndarray((NVIR, (U_1-U_0), (W_1-W_0), (V_1-V_0), (P_1-P_0)), buffer = buffer, offset = _M16_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
                    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M15.shape[0]
                    _size_dim_1      = _size_dim_1 * _M15.shape[1]
                    _size_dim_1      = _size_dim_1 * _M15.shape[2]
                    _size_dim_1      = _size_dim_1 * _M15.shape[3]
                    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M16.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M16.shape[0]
                    _M16_reshaped = _M16.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_4_reshaped, _M15_reshaped.T, c=_M16_reshaped)
                    _M16             = _M16_reshaped.reshape(*shape_backup)
                    # step  35 VWa,aUWVP->UPVWa
                    offset_now       = offset_7        
                    _M17_offset      = offset_now      
                    _M17             = np.ndarray(((U_1-U_0), (P_1-P_0), (V_1-V_0), (W_1-W_0), NVIR), buffer = buffer, offset = _M17_offset)
                    fn_contraction_012_23104_34012_wob(ctypes.c_void_p(_M4.ctypes.data),
                                                       ctypes.c_void_p(_M16.ctypes.data),
                                                       ctypes.c_void_p(_M17.ctypes.data),
                                                       ctypes.c_int(_M4.shape[0]),
                                                       ctypes.c_int(_M4.shape[1]),
                                                       ctypes.c_int(_M4.shape[2]),
                                                       ctypes.c_int(_M16.shape[1]),
                                                       ctypes.c_int(_M16.shape[4]))
                    # step  36 aT,UPVWa->TUPVW
                    offset_now       = offset_5        
                    _M20_offset      = offset_now      
                    _M20             = np.ndarray((NTHC_INT, (U_1-U_0), (P_1-P_0), (V_1-V_0), (W_1-W_0)), buffer = buffer, offset = _M20_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
                    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M17.shape[0]
                    _size_dim_1      = _size_dim_1 * _M17.shape[1]
                    _size_dim_1      = _size_dim_1 * _M17.shape[2]
                    _size_dim_1      = _size_dim_1 * _M17.shape[3]
                    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M20.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M20.shape[0]
                    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_12_reshaped.T, _M17_reshaped.T, c=_M20_reshaped)
                    _M20             = _M20_reshaped.reshape(*shape_backup)
                    # step  37 TUPVW->UWPVT
                    _M20_perm_offset = offset_7        
                    _M20_perm        = np.ndarray(((U_1-U_0), (W_1-W_0), (P_1-P_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M20_perm_offset)
                    fn_permutation_01234_14230_wob(ctypes.c_void_p(_M20.ctypes.data),
                                                   ctypes.c_void_p(_M20_perm.ctypes.data),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((U_1-U_0)),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((V_1-V_0)),
                                                   ctypes.c_int((W_1-W_0)))
                    # step  38 slice _INPUT_10 with indices ['U']
                    _INPUT_10_sliced_offset = offset_5        
                    _INPUT_10_sliced = np.ndarray((NTHC_INT, (U_1-U_0)), buffer = buffer, offset = _INPUT_10_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_10.ctypes.data),
                                 ctypes.c_void_p(_INPUT_10_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_10.shape[0]),
                                 ctypes.c_int(_INPUT_10.shape[1]),
                                 ctypes.c_int(U_0),
                                 ctypes.c_int(U_1))
                    # step  39 TU,TWPV->UWPVT
                    offset_now       = offset_8        
                    _M19_offset      = offset_now      
                    _M19             = np.ndarray(((U_1-U_0), (W_1-W_0), (P_1-P_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M19_offset)
                    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_10_sliced.ctypes.data),
                                                     ctypes.c_void_p(_M18.ctypes.data),
                                                     ctypes.c_void_p(_M19.ctypes.data),
                                                     ctypes.c_int(_INPUT_10_sliced.shape[0]),
                                                     ctypes.c_int(_INPUT_10_sliced.shape[1]),
                                                     ctypes.c_int(_M18.shape[1]),
                                                     ctypes.c_int(_M18.shape[2]),
                                                     ctypes.c_int(_M18.shape[3]))
                    # step  40 UWPVT,UWPVT->
                    output_tmp       = ctypes.c_double(0.0)
                    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
                           ctypes.c_void_p(_M20_perm.ctypes.data),
                           ctypes.c_int(_M19.size),
                           ctypes.pointer(output_tmp))
                    output_tmp = output_tmp.value
                    _M21 += output_tmp
                # step  41 end   for loop with indices ('V', 'W', 'P', 'U')
            # step  42 end   for loop with indices ('V', 'W', 'P')
        # step  43 end   for loop with indices ('V', 'W')
    # step  44 end   for loop with indices ('V',)
    # clean the final forloop
    # MPI finalize
    if use_mpi:
        _M21 = reduce(_M21, root=0)
        _M21 = bcast(_M21, root=0)
    return _M21

def RMP3_XX_1_forloop_Q_S_determine_bucket_size_forloop(NVIR        : int,
                                                        NOCC        : int,
                                                        N_LAPLACE   : int,
                                                        NTHC_INT    : int,
                                                        Q_bunchsize = 8,
                                                        S_bunchsize = 8,
                                                        V_bunchsize = 1,
                                                        W_bunchsize = 1):
    # init
    output = []     
    bucked_0_size    = 0               
    bucked_1_size    = 0               
    bucked_2_size    = 0               
    bucked_3_size    = 0               
    bucked_4_size    = 0               
    bucked_5_size    = 0               
    bucked_6_size    = 0               
    bucked_7_size    = 0               
    bucked_8_size    = 0               
    bucked_9_size    = 0               
    bucked_10_size   = 0               
    # assign the size of each tensor
    _M3_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M19_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M20_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M1_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M2_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M0_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _INPUT_15_sliced_size = (NOCC * N_LAPLACE)
    _INPUT_21_sliced_size = (NVIR * N_LAPLACE)
    _M15_size        = (NTHC_INT * (W_bunchsize * (Q_bunchsize * V_bunchsize)))
    _M6_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M10_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _INPUT_19_sliced_size = (NOCC * N_LAPLACE)
    _M1_sliced_size  = (Q_bunchsize * (V_bunchsize * NVIR))
    _INPUT_0_sliced_size = (NTHC_INT * NTHC_INT)
    _M8_size         = (NOCC * (Q_bunchsize * (S_bunchsize * V_bunchsize)))
    _M14_size        = (NTHC_INT * (W_bunchsize * (Q_bunchsize * (S_bunchsize * V_bunchsize))))
    _M16_perm_size   = (S_bunchsize * (NTHC_INT * (W_bunchsize * (Q_bunchsize * V_bunchsize))))
    _INPUT_5_sliced_size = (NTHC_INT * NTHC_INT)
    _M12_size        = (NOCC * (S_bunchsize * (Q_bunchsize * V_bunchsize)))
    _M18_size        = (NTHC_INT * (W_bunchsize * (S_bunchsize * (Q_bunchsize * V_bunchsize))))
    _M4_size         = (V_bunchsize * (W_bunchsize * NOCC))
    _M5_size         = (W_bunchsize * (Q_bunchsize * (V_bunchsize * NVIR)))
    _M6_sliced_size  = (NTHC_INT * (S_bunchsize * V_bunchsize))
    _M9_size         = (W_bunchsize * (Q_bunchsize * (S_bunchsize * (V_bunchsize * NOCC))))
    _M16_size        = (S_bunchsize * (NTHC_INT * (W_bunchsize * (Q_bunchsize * V_bunchsize))))
    _M17_size        = (NTHC_INT * (S_bunchsize * (W_bunchsize * (Q_bunchsize * V_bunchsize))))
    _M7_size         = (Q_bunchsize * (S_bunchsize * (V_bunchsize * NTHC_INT)))
    _M10_sliced_size = (NTHC_INT * (Q_bunchsize * V_bunchsize))
    _INPUT_20_sliced_size = (NOCC * N_LAPLACE)
    _M18_perm_size   = (NTHC_INT * (W_bunchsize * (S_bunchsize * (Q_bunchsize * V_bunchsize))))
    _M11_size        = (S_bunchsize * (Q_bunchsize * (V_bunchsize * NTHC_INT)))
    _M13_size        = (W_bunchsize * (S_bunchsize * (Q_bunchsize * (V_bunchsize * NOCC))))
    _M19_packed_size = (NTHC_INT * (S_bunchsize * W_bunchsize))
    # determine the size of each bucket
    # bucket 0
    bucked_0_size    = max(bucked_0_size, _M3_size)
    bucked_0_size    = max(bucked_0_size, _M19_size)
    # bucket 1
    bucked_1_size    = max(bucked_1_size, _M20_size)
    # bucket 2
    bucked_2_size    = max(bucked_2_size, _M1_size)
    # bucket 3
    bucked_3_size    = max(bucked_3_size, _M2_size)
    bucked_3_size    = max(bucked_3_size, _M0_size)
    bucked_3_size    = max(bucked_3_size, _INPUT_15_sliced_size)
    bucked_3_size    = max(bucked_3_size, _INPUT_21_sliced_size)
    bucked_3_size    = max(bucked_3_size, _M15_size)
    # bucket 4
    bucked_4_size    = max(bucked_4_size, _M6_size)
    # bucket 5
    bucked_5_size    = max(bucked_5_size, _M10_size)
    # bucket 6
    bucked_6_size    = max(bucked_6_size, _INPUT_19_sliced_size)
    bucked_6_size    = max(bucked_6_size, _M1_sliced_size)
    bucked_6_size    = max(bucked_6_size, _INPUT_0_sliced_size)
    bucked_6_size    = max(bucked_6_size, _M8_size)
    bucked_6_size    = max(bucked_6_size, _M14_size)
    bucked_6_size    = max(bucked_6_size, _M16_perm_size)
    bucked_6_size    = max(bucked_6_size, _INPUT_5_sliced_size)
    bucked_6_size    = max(bucked_6_size, _M12_size)
    bucked_6_size    = max(bucked_6_size, _M18_size)
    # bucket 7
    bucked_7_size    = max(bucked_7_size, _M4_size)
    # bucket 8
    bucked_8_size    = max(bucked_8_size, _M5_size)
    bucked_8_size    = max(bucked_8_size, _M6_sliced_size)
    bucked_8_size    = max(bucked_8_size, _M9_size)
    bucked_8_size    = max(bucked_8_size, _M16_size)
    bucked_8_size    = max(bucked_8_size, _M17_size)
    # bucket 9
    bucked_9_size    = max(bucked_9_size, _M7_size)
    bucked_9_size    = max(bucked_9_size, _M10_sliced_size)
    bucked_9_size    = max(bucked_9_size, _INPUT_20_sliced_size)
    bucked_9_size    = max(bucked_9_size, _M18_perm_size)
    # bucket 10
    bucked_10_size   = max(bucked_10_size, _M11_size)
    bucked_10_size   = max(bucked_10_size, _M13_size)
    bucked_10_size   = max(bucked_10_size, _M19_packed_size)
    # append each bucket size to the output
    output.append(bucked_0_size)
    output.append(bucked_1_size)
    output.append(bucked_2_size)
    output.append(bucked_3_size)
    output.append(bucked_4_size)
    output.append(bucked_5_size)
    output.append(bucked_6_size)
    output.append(bucked_7_size)
    output.append(bucked_8_size)
    output.append(bucked_9_size)
    output.append(bucked_10_size)
    return output

def RMP3_XX_1_forloop_Q_S_naive(Z           : np.ndarray,
                                X_o         : np.ndarray,
                                X_v         : np.ndarray,
                                tau_o       : np.ndarray,
                                tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    t1 = (logger.process_clock(), logger.perf_counter())
    _M3              = np.einsum("cS,cW->SWc"    , _INPUT_9        , _INPUT_22       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.einsum("cU,SWc->USW"   , _INPUT_14       , _M3             )
    del _M3         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M1              = np.einsum("aQ,aV->QVa"    , _INPUT_4        , _INPUT_17       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M2              = np.einsum("bS,bV->SVb"    , _INPUT_8        , _INPUT_18       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.einsum("bP,SVb->PSV"   , _INPUT_2        , _M2             )
    del _M2         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M0              = np.einsum("jQ,jV->QVj"    , _INPUT_3        , _INPUT_16       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.einsum("jR,QVj->RQV"   , _INPUT_6        , _M0             )
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M4              = np.einsum("iV,iW->VWi"    , _INPUT_15       , _INPUT_19       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M5              = np.einsum("aW,QVa->WQVa"  , _INPUT_21       , _M1             )
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.einsum("aT,WQVa->TWQV" , _INPUT_12       , _M5             )
    del _M5         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.einsum("PQ,PSV->QSVP"  , _INPUT_0        , _M6             )
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.einsum("iP,QSVP->iQSV" , _INPUT_1        , _M7             )
    del _M7         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9              = np.einsum("VWi,iQSV->WQSVi", _M4             , _M8             )
    del _M4         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.einsum("iT,WQSVi->TWQSV", _INPUT_11       , _M9             )
    del _M9         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.einsum("TWQSV,TWQV->STWQV", _M14            , _M15            )
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16_perm        = np.transpose(_M16            , (0, 2, 3, 4, 1) )
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.einsum("TU,SWQVT->USWQV", _INPUT_10       , _M16_perm       )
    del _M16_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11             = np.einsum("RS,RQV->SQVR"  , _INPUT_5        , _M10            )
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.einsum("kR,SQVR->kSQV" , _INPUT_7        , _M11            )
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M13             = np.einsum("kW,kSQV->WSQVk", _INPUT_20       , _M12            )
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.einsum("kU,WSQVk->UWSQV", _INPUT_13       , _M13            )
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18_perm        = np.transpose(_M18            , (0, 2, 1, 3, 4) )
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M19             = np.einsum("USWQV,USWQV->USW", _M17            , _M18_perm       )
    del _M17        
    del _M18_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M21             = np.einsum("USW,USW->"     , _M19            , _M20            )
    del _M19        
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    return _M21

def RMP3_XX_1_forloop_Q_S(Z           : np.ndarray,
                          X_o         : np.ndarray,
                          X_v         : np.ndarray,
                          tau_o       : np.ndarray,
                          tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # step 0 cS,cW->SWc 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_9.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_9.shape[0]),
                                 ctypes.c_int(_INPUT_9.shape[1]),
                                 ctypes.c_int(_INPUT_22.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    # step 1 cU,SWc->USW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_14_reshaped.T, _M3_reshaped.T, c=_M20_reshaped)
    _M20         = _M20_reshaped.reshape(*shape_backup)
    del _M3         
    del _M3_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    # step 2 aQ,aV->QVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_4.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_4.shape[0]),
                                 ctypes.c_int(_INPUT_4.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    # step 3 bS,bV->SVb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_8.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_8.shape[0]),
                                 ctypes.c_int(_INPUT_8.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    # step 4 bP,SVb->PSV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_2.shape[0]
    _INPUT_2_reshaped = _INPUT_2.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_2_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6          = _M6_reshaped.reshape(*shape_backup)
    del _M2         
    del _M2_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    # step 5 jQ,jV->QVj 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_3.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_3.shape[0]),
                                 ctypes.c_int(_INPUT_3.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    # step 6 jR,QVj->RQV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M0.shape[0]
    _size_dim_1      = _size_dim_1 * _M0.shape[1]
    _M0_reshaped = _M0.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_6_reshaped.T, _M0_reshaped.T, c=_M10_reshaped)
    _M10         = _M10_reshaped.reshape(*shape_backup)
    del _M0         
    del _M0_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    # step 7 iV,iW->VWi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M4              = np.ndarray((N_LAPLACE, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_INPUT_19.ctypes.data),
                                 ctypes.c_void_p(_M4.ctypes.data),
                                 ctypes.c_int(_INPUT_15.shape[0]),
                                 ctypes.c_int(_INPUT_15.shape[1]),
                                 ctypes.c_int(_INPUT_19.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    # step 8 aW,QVa->WQVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M5              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_21.ctypes.data),
                                   ctypes.c_void_p(_M1.ctypes.data),
                                   ctypes.c_void_p(_M5.ctypes.data),
                                   ctypes.c_int(_INPUT_21.shape[0]),
                                   ctypes.c_int(_INPUT_21.shape[1]),
                                   ctypes.c_int(_M1.shape[0]),
                                   ctypes.c_int(_M1.shape[1]))
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    # step 9 aT,WQVa->TWQV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M5.shape[0]
    _size_dim_1      = _size_dim_1 * _M5.shape[1]
    _size_dim_1      = _size_dim_1 * _M5.shape[2]
    _M5_reshaped = _M5.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M15.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M15.shape[0]
    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_12_reshaped.T, _M5_reshaped.T, c=_M15_reshaped)
    _M15         = _M15_reshaped.reshape(*shape_backup)
    del _M5         
    del _M5_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    # step 10 PQ,PSV->QSVP 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_023_1230_wob = getattr(libpbc, "fn_contraction_01_023_1230_wob", None)
    assert fn_contraction_01_023_1230_wob is not None
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_023_1230_wob(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                   ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M7.ctypes.data),
                                   ctypes.c_int(_INPUT_0.shape[0]),
                                   ctypes.c_int(_INPUT_0.shape[1]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]))
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    # step 11 iP,QSVP->iQSV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.ndarray((NOCC, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_1.shape[0]
    _INPUT_1_reshaped = _INPUT_1.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _size_dim_1      = _size_dim_1 * _M7.shape[1]
    _size_dim_1      = _size_dim_1 * _M7.shape[2]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M8.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M8.shape[0]
    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_1_reshaped, _M7_reshaped.T, c=_M8_reshaped)
    _M8          = _M8_reshaped.reshape(*shape_backup)
    del _M7         
    del _M7_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    # step 12 VWi,iQSV->WQSVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_2340_13402_wob = getattr(libpbc, "fn_contraction_012_2340_13402_wob", None)
    assert fn_contraction_012_2340_13402_wob is not None
    _M9              = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_012_2340_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                      ctypes.c_void_p(_M8.ctypes.data),
                                      ctypes.c_void_p(_M9.ctypes.data),
                                      ctypes.c_int(_M4.shape[0]),
                                      ctypes.c_int(_M4.shape[1]),
                                      ctypes.c_int(_M4.shape[2]),
                                      ctypes.c_int(_M8.shape[1]),
                                      ctypes.c_int(_M8.shape[2]))
    del _M4         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    # step 13 iT,WQSVi->TWQSV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M9.shape[0]
    _size_dim_1      = _size_dim_1 * _M9.shape[1]
    _size_dim_1      = _size_dim_1 * _M9.shape[2]
    _size_dim_1      = _size_dim_1 * _M9.shape[3]
    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_11_reshaped.T, _M9_reshaped.T, c=_M14_reshaped)
    _M14         = _M14_reshaped.reshape(*shape_backup)
    del _M9         
    del _M9_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    # step 14 TWQSV,TWQV->STWQV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01234_0124_30124_wob = getattr(libpbc, "fn_contraction_01234_0124_30124_wob", None)
    assert fn_contraction_01234_0124_30124_wob is not None
    _M16             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_01234_0124_30124_wob(ctypes.c_void_p(_M14.ctypes.data),
                                        ctypes.c_void_p(_M15.ctypes.data),
                                        ctypes.c_void_p(_M16.ctypes.data),
                                        ctypes.c_int(_M14.shape[0]),
                                        ctypes.c_int(_M14.shape[1]),
                                        ctypes.c_int(_M14.shape[2]),
                                        ctypes.c_int(_M14.shape[3]),
                                        ctypes.c_int(_M14.shape[4]))
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    # step 15 STWQV->SWQVT 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_02341_wob = getattr(libpbc, "fn_permutation_01234_02341_wob", None)
    assert fn_permutation_01234_02341_wob is not None
    _M16_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_02341_wob(ctypes.c_void_p(_M16.ctypes.data),
                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                   ctypes.c_int(_M16.shape[0]),
                                   ctypes.c_int(_M16.shape[1]),
                                   ctypes.c_int(_M16.shape[2]),
                                   ctypes.c_int(_M16.shape[3]),
                                   ctypes.c_int(_M16.shape[4]))
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    # step 16 TU,SWQVT->USWQV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M17.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M17.shape[0]
    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
    _M17         = _M17_reshaped.reshape(*shape_backup)
    del _M16_perm   
    del _M16_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    # step 17 RS,RQV->SQVR 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_023_1230_wob = getattr(libpbc, "fn_contraction_01_023_1230_wob", None)
    assert fn_contraction_01_023_1230_wob is not None
    _M11             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_023_1230_wob(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                   ctypes.c_void_p(_M10.ctypes.data),
                                   ctypes.c_void_p(_M11.ctypes.data),
                                   ctypes.c_int(_INPUT_5.shape[0]),
                                   ctypes.c_int(_INPUT_5.shape[1]),
                                   ctypes.c_int(_M10.shape[1]),
                                   ctypes.c_int(_M10.shape[2]))
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    # step 18 kR,SQVR->kSQV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.ndarray((NOCC, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M11.shape[0]
    _size_dim_1      = _size_dim_1 * _M11.shape[1]
    _size_dim_1      = _size_dim_1 * _M11.shape[2]
    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M12.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M12.shape[0]
    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_7_reshaped, _M11_reshaped.T, c=_M12_reshaped)
    _M12         = _M12_reshaped.reshape(*shape_backup)
    del _M11        
    del _M11_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    # step 19 kW,kSQV->WSQVk 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    _M13             = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_20.ctypes.data),
                                     ctypes.c_void_p(_M12.ctypes.data),
                                     ctypes.c_void_p(_M13.ctypes.data),
                                     ctypes.c_int(_INPUT_20.shape[0]),
                                     ctypes.c_int(_INPUT_20.shape[1]),
                                     ctypes.c_int(_M12.shape[1]),
                                     ctypes.c_int(_M12.shape[2]),
                                     ctypes.c_int(_M12.shape[3]))
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    # step 20 kU,WSQVk->UWSQV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M13.shape[0]
    _size_dim_1      = _size_dim_1 * _M13.shape[1]
    _size_dim_1      = _size_dim_1 * _M13.shape[2]
    _size_dim_1      = _size_dim_1 * _M13.shape[3]
    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_13_reshaped.T, _M13_reshaped.T, c=_M18_reshaped)
    _M18         = _M18_reshaped.reshape(*shape_backup)
    del _M13        
    del _M13_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    # step 21 UWSQV->USWQV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_02134_wob = getattr(libpbc, "fn_permutation_01234_02134_wob", None)
    assert fn_permutation_01234_02134_wob is not None
    _M18_perm        = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_permutation_01234_02134_wob(ctypes.c_void_p(_M18.ctypes.data),
                                   ctypes.c_void_p(_M18_perm.ctypes.data),
                                   ctypes.c_int(_M18.shape[0]),
                                   ctypes.c_int(_M18.shape[1]),
                                   ctypes.c_int(_M18.shape[2]),
                                   ctypes.c_int(_M18.shape[3]),
                                   ctypes.c_int(_M18.shape[4]))
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    # step 22 USWQV,USWQV->USW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01234_01234_012_wob = getattr(libpbc, "fn_contraction_01234_01234_012_wob", None)
    assert fn_contraction_01234_01234_012_wob is not None
    _M19             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_01234_01234_012_wob(ctypes.c_void_p(_M17.ctypes.data),
                                       ctypes.c_void_p(_M18_perm.ctypes.data),
                                       ctypes.c_void_p(_M19.ctypes.data),
                                       ctypes.c_int(_M17.shape[0]),
                                       ctypes.c_int(_M17.shape[1]),
                                       ctypes.c_int(_M17.shape[2]),
                                       ctypes.c_int(_M17.shape[3]),
                                       ctypes.c_int(_M17.shape[4]))
    del _M17        
    del _M18_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    # step 23 USW,USW-> 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    _M21             = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(_M21))
    _M21 = _M21.value
    del _M19        
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    return _M21

def RMP3_XX_1_forloop_Q_S_forloop_Q_S(Z           : np.ndarray,
                                      X_o         : np.ndarray,
                                      X_v         : np.ndarray,
                                      tau_o       : np.ndarray,
                                      tau_v       : np.ndarray,
                                      buffer      : np.ndarray,
                                      Q_bunchsize = 8,
                                      S_bunchsize = 8,
                                      V_bunchsize = 1,
                                      W_bunchsize = 1,
                                      use_mpi = False):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # fetch function pointers
    fn_contraction_01234_01234_012_wob = getattr(libpbc, "fn_contraction_01234_01234_012_wob", None)
    assert fn_contraction_01234_01234_012_wob is not None
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    fn_slice_3_1_2 = getattr(libpbc, "fn_slice_3_1_2", None)
    assert fn_slice_3_1_2 is not None
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    fn_packadd_3_1_2 = getattr(libpbc, "fn_packadd_3_1_2", None)
    assert fn_packadd_3_1_2 is not None
    fn_slice_2_1 = getattr(libpbc, "fn_slice_2_1", None)
    assert fn_slice_2_1 is not None
    fn_permutation_01234_02134_wob = getattr(libpbc, "fn_permutation_01234_02134_wob", None)
    assert fn_permutation_01234_02134_wob is not None
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    fn_slice_3_0_1 = getattr(libpbc, "fn_slice_3_0_1", None)
    assert fn_slice_3_0_1 is not None
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    fn_contraction_01_023_1230_wob = getattr(libpbc, "fn_contraction_01_023_1230_wob", None)
    assert fn_contraction_01_023_1230_wob is not None
    fn_contraction_01234_0124_30124_wob = getattr(libpbc, "fn_contraction_01234_0124_30124_wob", None)
    assert fn_contraction_01234_0124_30124_wob is not None
    fn_permutation_01234_02341_wob = getattr(libpbc, "fn_permutation_01234_02341_wob", None)
    assert fn_permutation_01234_02341_wob is not None
    fn_contraction_012_2340_13402_wob = getattr(libpbc, "fn_contraction_012_2340_13402_wob", None)
    assert fn_contraction_012_2340_13402_wob is not None
    if use_mpi:
        bunchsize = NTHC_INT//comm_size + 1
        Q_begin = rank*bunchsize
        Q_end = (rank+1)*bunchsize
        Q_begin          = min(Q_begin, NTHC_INT)
        Q_end            = min(Q_end, NTHC_INT)
    else:
        Q_begin          = 0               
        Q_end            = NTHC_INT        
    # preallocate buffer
    bucket_size      = RMP3_XX_1_forloop_Q_S_determine_bucket_size_forloop(NVIR = NVIR,
                                                                           NOCC = NOCC,
                                                                           N_LAPLACE = N_LAPLACE,
                                                                           NTHC_INT = NTHC_INT,
                                                                           V_bunchsize = V_bunchsize,
                                                                           W_bunchsize = W_bunchsize,
                                                                           Q_bunchsize = Q_bunchsize,
                                                                           S_bunchsize = S_bunchsize)
    bufsize_now      = buffer.size     
    _itemsize        = buffer.itemsize 
    offset_now       = 0               
    offset_0         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[0])
    offset_1         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[1])
    offset_2         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[2])
    offset_3         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[3])
    offset_4         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[4])
    offset_5         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[5])
    offset_6         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[6])
    offset_7         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[7])
    offset_8         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[8])
    offset_9         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[9])
    offset_10        = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[10])
    bufsize          = offset_now      
    if (bufsize > bufsize_now):
        buffer           = np.ndarray((bufsize), dtype=np.float64)
    # step   0 start for loop with indices ()
    # step   1 cS,cW->SWc
    offset_now       = offset_0        
    _M3_offset       = offset_now      
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M3_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_9.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_9.shape[0]),
                                 ctypes.c_int(_INPUT_9.shape[1]),
                                 ctypes.c_int(_INPUT_22.shape[1]))
    # step   2 cU,SWc->USW
    offset_now       = offset_1        
    _M20_offset      = offset_now      
    _M20             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M20_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_14_reshaped.T, _M3_reshaped.T, c=_M20_reshaped)
    _M20             = _M20_reshaped.reshape(*shape_backup)
    # step   3 allocate   _M19
    offset_now       = offset_0        
    _M19             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = offset_now)
    _M19_offset      = offset_now      
    _M19.ravel()[:] = 0.0
    # step   4 aQ,aV->QVa
    offset_now       = offset_2        
    _M1_offset       = offset_now      
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M1_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_4.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_4.shape[0]),
                                 ctypes.c_int(_INPUT_4.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    # step   5 bS,bV->SVb
    offset_now       = offset_3        
    _M2_offset       = offset_now      
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M2_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_8.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_8.shape[0]),
                                 ctypes.c_int(_INPUT_8.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    # step   6 bP,SVb->PSV
    offset_now       = offset_4        
    _M6_offset       = offset_now      
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M6_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_2.shape[0]
    _INPUT_2_reshaped = _INPUT_2.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_2_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6              = _M6_reshaped.reshape(*shape_backup)
    # step   7 jQ,jV->QVj
    offset_now       = offset_3        
    _M0_offset       = offset_now      
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M0_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_3.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_3.shape[0]),
                                 ctypes.c_int(_INPUT_3.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    # step   8 jR,QVj->RQV
    offset_now       = offset_5        
    _M10_offset      = offset_now      
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M10_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M0.shape[0]
    _size_dim_1      = _size_dim_1 * _M0.shape[1]
    _M0_reshaped = _M0.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_6_reshaped.T, _M0_reshaped.T, c=_M10_reshaped)
    _M10             = _M10_reshaped.reshape(*shape_backup)
    # step   9 start for loop with indices ('V',)
    for V_0, V_1 in lib.prange(0,N_LAPLACE,V_bunchsize):
        # step  10 start for loop with indices ('V', 'W')
        for W_0, W_1 in lib.prange(0,N_LAPLACE,W_bunchsize):
            # step  11 slice _INPUT_15 with indices ['V']
            _INPUT_15_sliced_offset = offset_3        
            _INPUT_15_sliced = np.ndarray((NOCC, (V_1-V_0)), buffer = buffer, offset = _INPUT_15_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_15.ctypes.data),
                         ctypes.c_void_p(_INPUT_15_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_15.shape[0]),
                         ctypes.c_int(_INPUT_15.shape[1]),
                         ctypes.c_int(V_0),
                         ctypes.c_int(V_1))
            # step  12 slice _INPUT_19 with indices ['W']
            _INPUT_19_sliced_offset = offset_6        
            _INPUT_19_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_19_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_19.ctypes.data),
                         ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_19.shape[0]),
                         ctypes.c_int(_INPUT_19.shape[1]),
                         ctypes.c_int(W_0),
                         ctypes.c_int(W_1))
            # step  13 iV,iW->VWi
            offset_now       = offset_7        
            _M4_offset       = offset_now      
            _M4              = np.ndarray(((V_1-V_0), (W_1-W_0), NOCC), buffer = buffer, offset = _M4_offset)
            fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_15_sliced.ctypes.data),
                                         ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                                         ctypes.c_void_p(_M4.ctypes.data),
                                         ctypes.c_int(_INPUT_15_sliced.shape[0]),
                                         ctypes.c_int(_INPUT_15_sliced.shape[1]),
                                         ctypes.c_int(_INPUT_19_sliced.shape[1]))
            # step  14 start for loop with indices ('V', 'W', 'Q')
            for Q_0, Q_1 in lib.prange(Q_begin,Q_end,Q_bunchsize):
                # step  15 slice _INPUT_21 with indices ['W']
                _INPUT_21_sliced_offset = offset_3        
                _INPUT_21_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_21_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_21.ctypes.data),
                             ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_21.shape[0]),
                             ctypes.c_int(_INPUT_21.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  16 slice _M1 with indices ['Q', 'V']
                _M1_sliced_offset = offset_6        
                _M1_sliced       = np.ndarray(((Q_1-Q_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M1_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M1.ctypes.data),
                               ctypes.c_void_p(_M1_sliced.ctypes.data),
                               ctypes.c_int(_M1.shape[0]),
                               ctypes.c_int(_M1.shape[1]),
                               ctypes.c_int(_M1.shape[2]),
                               ctypes.c_int(Q_0),
                               ctypes.c_int(Q_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  17 aW,QVa->WQVa
                offset_now       = offset_8        
                _M5_offset       = offset_now      
                _M5              = np.ndarray(((W_1-W_0), (Q_1-Q_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M5_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                                               ctypes.c_void_p(_M1_sliced.ctypes.data),
                                               ctypes.c_void_p(_M5.ctypes.data),
                                               ctypes.c_int(_INPUT_21_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_21_sliced.shape[1]),
                                               ctypes.c_int(_M1_sliced.shape[0]),
                                               ctypes.c_int(_M1_sliced.shape[1]))
                # step  18 aT,WQVa->TWQV
                offset_now       = offset_3        
                _M15_offset      = offset_now      
                _M15             = np.ndarray((NTHC_INT, (W_1-W_0), (Q_1-Q_0), (V_1-V_0)), buffer = buffer, offset = _M15_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
                _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M5.shape[0]
                _size_dim_1      = _size_dim_1 * _M5.shape[1]
                _size_dim_1      = _size_dim_1 * _M5.shape[2]
                _M5_reshaped = _M5.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M15.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M15.shape[0]
                _M15_reshaped = _M15.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_12_reshaped.T, _M5_reshaped.T, c=_M15_reshaped)
                _M15             = _M15_reshaped.reshape(*shape_backup)
                # step  19 start for loop with indices ('V', 'W', 'Q', 'S')
                for S_0, S_1 in lib.prange(0,NTHC_INT,S_bunchsize):
                    # step  20 slice _INPUT_0 with indices ['Q']
                    _INPUT_0_sliced_offset = offset_6        
                    _INPUT_0_sliced  = np.ndarray((NTHC_INT, (Q_1-Q_0)), buffer = buffer, offset = _INPUT_0_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                 ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_0.shape[0]),
                                 ctypes.c_int(_INPUT_0.shape[1]),
                                 ctypes.c_int(Q_0),
                                 ctypes.c_int(Q_1))
                    # step  21 slice _M6 with indices ['S', 'V']
                    _M6_sliced_offset = offset_8        
                    _M6_sliced       = np.ndarray((NTHC_INT, (S_1-S_0), (V_1-V_0)), buffer = buffer, offset = _M6_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                   ctypes.c_int(_M6.shape[0]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]),
                                   ctypes.c_int(S_0),
                                   ctypes.c_int(S_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  22 PQ,PSV->QSVP
                    offset_now       = offset_9        
                    _M7_offset       = offset_now      
                    _M7              = np.ndarray(((Q_1-Q_0), (S_1-S_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M7_offset)
                    fn_contraction_01_023_1230_wob(ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M7.ctypes.data),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[2]))
                    # step  23 iP,QSVP->iQSV
                    offset_now       = offset_6        
                    _M8_offset       = offset_now      
                    _M8              = np.ndarray((NOCC, (Q_1-Q_0), (S_1-S_0), (V_1-V_0)), buffer = buffer, offset = _M8_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_1.shape[0]
                    _INPUT_1_reshaped = _INPUT_1.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M7.shape[0]
                    _size_dim_1      = _size_dim_1 * _M7.shape[1]
                    _size_dim_1      = _size_dim_1 * _M7.shape[2]
                    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M8.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M8.shape[0]
                    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_1_reshaped, _M7_reshaped.T, c=_M8_reshaped)
                    _M8              = _M8_reshaped.reshape(*shape_backup)
                    # step  24 VWi,iQSV->WQSVi
                    offset_now       = offset_8        
                    _M9_offset       = offset_now      
                    _M9              = np.ndarray(((W_1-W_0), (Q_1-Q_0), (S_1-S_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M9_offset)
                    fn_contraction_012_2340_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                                      ctypes.c_void_p(_M8.ctypes.data),
                                                      ctypes.c_void_p(_M9.ctypes.data),
                                                      ctypes.c_int(_M4.shape[0]),
                                                      ctypes.c_int(_M4.shape[1]),
                                                      ctypes.c_int(_M4.shape[2]),
                                                      ctypes.c_int(_M8.shape[1]),
                                                      ctypes.c_int(_M8.shape[2]))
                    # step  25 iT,WQSVi->TWQSV
                    offset_now       = offset_6        
                    _M14_offset      = offset_now      
                    _M14             = np.ndarray((NTHC_INT, (W_1-W_0), (Q_1-Q_0), (S_1-S_0), (V_1-V_0)), buffer = buffer, offset = _M14_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
                    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M9.shape[0]
                    _size_dim_1      = _size_dim_1 * _M9.shape[1]
                    _size_dim_1      = _size_dim_1 * _M9.shape[2]
                    _size_dim_1      = _size_dim_1 * _M9.shape[3]
                    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M14.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M14.shape[0]
                    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_11_reshaped.T, _M9_reshaped.T, c=_M14_reshaped)
                    _M14             = _M14_reshaped.reshape(*shape_backup)
                    # step  26 TWQSV,TWQV->STWQV
                    offset_now       = offset_8        
                    _M16_offset      = offset_now      
                    _M16             = np.ndarray(((S_1-S_0), NTHC_INT, (W_1-W_0), (Q_1-Q_0), (V_1-V_0)), buffer = buffer, offset = _M16_offset)
                    fn_contraction_01234_0124_30124_wob(ctypes.c_void_p(_M14.ctypes.data),
                                                        ctypes.c_void_p(_M15.ctypes.data),
                                                        ctypes.c_void_p(_M16.ctypes.data),
                                                        ctypes.c_int(_M14.shape[0]),
                                                        ctypes.c_int(_M14.shape[1]),
                                                        ctypes.c_int(_M14.shape[2]),
                                                        ctypes.c_int(_M14.shape[3]),
                                                        ctypes.c_int(_M14.shape[4]))
                    # step  27 STWQV->SWQVT
                    _M16_perm_offset = offset_6        
                    _M16_perm        = np.ndarray(((S_1-S_0), (W_1-W_0), (Q_1-Q_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M16_perm_offset)
                    fn_permutation_01234_02341_wob(ctypes.c_void_p(_M16.ctypes.data),
                                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                                   ctypes.c_int((S_1-S_0)),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((Q_1-Q_0)),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  28 TU,SWQVT->USWQV
                    offset_now       = offset_8        
                    _M17_offset      = offset_now      
                    _M17             = np.ndarray((NTHC_INT, (S_1-S_0), (W_1-W_0), (Q_1-Q_0), (V_1-V_0)), buffer = buffer, offset = _M17_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
                    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
                    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M17.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M17.shape[0]
                    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
                    _M17             = _M17_reshaped.reshape(*shape_backup)
                    # step  29 slice _INPUT_5 with indices ['S']
                    _INPUT_5_sliced_offset = offset_6        
                    _INPUT_5_sliced  = np.ndarray((NTHC_INT, (S_1-S_0)), buffer = buffer, offset = _INPUT_5_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                 ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_5.shape[0]),
                                 ctypes.c_int(_INPUT_5.shape[1]),
                                 ctypes.c_int(S_0),
                                 ctypes.c_int(S_1))
                    # step  30 slice _M10 with indices ['Q', 'V']
                    _M10_sliced_offset = offset_9        
                    _M10_sliced      = np.ndarray((NTHC_INT, (Q_1-Q_0), (V_1-V_0)), buffer = buffer, offset = _M10_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M10.ctypes.data),
                                   ctypes.c_void_p(_M10_sliced.ctypes.data),
                                   ctypes.c_int(_M10.shape[0]),
                                   ctypes.c_int(_M10.shape[1]),
                                   ctypes.c_int(_M10.shape[2]),
                                   ctypes.c_int(Q_0),
                                   ctypes.c_int(Q_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  31 RS,RQV->SQVR
                    offset_now       = offset_10       
                    _M11_offset      = offset_now      
                    _M11             = np.ndarray(((S_1-S_0), (Q_1-Q_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M11_offset)
                    fn_contraction_01_023_1230_wob(ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M10_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M11.ctypes.data),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[1]),
                                                   ctypes.c_int(_M10_sliced.shape[1]),
                                                   ctypes.c_int(_M10_sliced.shape[2]))
                    # step  32 kR,SQVR->kSQV
                    offset_now       = offset_6        
                    _M12_offset      = offset_now      
                    _M12             = np.ndarray((NOCC, (S_1-S_0), (Q_1-Q_0), (V_1-V_0)), buffer = buffer, offset = _M12_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
                    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M11.shape[0]
                    _size_dim_1      = _size_dim_1 * _M11.shape[1]
                    _size_dim_1      = _size_dim_1 * _M11.shape[2]
                    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M12.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M12.shape[0]
                    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_7_reshaped, _M11_reshaped.T, c=_M12_reshaped)
                    _M12             = _M12_reshaped.reshape(*shape_backup)
                    # step  33 slice _INPUT_20 with indices ['W']
                    _INPUT_20_sliced_offset = offset_9        
                    _INPUT_20_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_20_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_20.shape[0]),
                                 ctypes.c_int(_INPUT_20.shape[1]),
                                 ctypes.c_int(W_0),
                                 ctypes.c_int(W_1))
                    # step  34 kW,kSQV->WSQVk
                    offset_now       = offset_10       
                    _M13_offset      = offset_now      
                    _M13             = np.ndarray(((W_1-W_0), (S_1-S_0), (Q_1-Q_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M13_offset)
                    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_20_sliced.ctypes.data),
                                                     ctypes.c_void_p(_M12.ctypes.data),
                                                     ctypes.c_void_p(_M13.ctypes.data),
                                                     ctypes.c_int(_INPUT_20_sliced.shape[0]),
                                                     ctypes.c_int(_INPUT_20_sliced.shape[1]),
                                                     ctypes.c_int(_M12.shape[1]),
                                                     ctypes.c_int(_M12.shape[2]),
                                                     ctypes.c_int(_M12.shape[3]))
                    # step  35 kU,WSQVk->UWSQV
                    offset_now       = offset_6        
                    _M18_offset      = offset_now      
                    _M18             = np.ndarray((NTHC_INT, (W_1-W_0), (S_1-S_0), (Q_1-Q_0), (V_1-V_0)), buffer = buffer, offset = _M18_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
                    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M13.shape[0]
                    _size_dim_1      = _size_dim_1 * _M13.shape[1]
                    _size_dim_1      = _size_dim_1 * _M13.shape[2]
                    _size_dim_1      = _size_dim_1 * _M13.shape[3]
                    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M18.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M18.shape[0]
                    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_13_reshaped.T, _M13_reshaped.T, c=_M18_reshaped)
                    _M18             = _M18_reshaped.reshape(*shape_backup)
                    # step  36 UWSQV->USWQV
                    _M18_perm_offset = offset_9        
                    _M18_perm        = np.ndarray((NTHC_INT, (S_1-S_0), (W_1-W_0), (Q_1-Q_0), (V_1-V_0)), buffer = buffer, offset = _M18_perm_offset)
                    fn_permutation_01234_02134_wob(ctypes.c_void_p(_M18.ctypes.data),
                                                   ctypes.c_void_p(_M18_perm.ctypes.data),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((S_1-S_0)),
                                                   ctypes.c_int((Q_1-Q_0)),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  37 USWQV,USWQV->USW
                    offset_now       = offset_10       
                    _M19_packed_offset = offset_now      
                    _M19_packed      = np.ndarray((NTHC_INT, (S_1-S_0), (W_1-W_0)), buffer = buffer, offset = _M19_packed_offset)
                    fn_contraction_01234_01234_012_wob(ctypes.c_void_p(_M17.ctypes.data),
                                                       ctypes.c_void_p(_M18_perm.ctypes.data),
                                                       ctypes.c_void_p(_M19_packed.ctypes.data),
                                                       ctypes.c_int(_M17.shape[0]),
                                                       ctypes.c_int(_M17.shape[1]),
                                                       ctypes.c_int(_M17.shape[2]),
                                                       ctypes.c_int(_M17.shape[3]),
                                                       ctypes.c_int(_M17.shape[4]))
                    # step  38 pack  _M19 with indices ['W', 'S']
                    fn_packadd_3_1_2(ctypes.c_void_p(_M19.ctypes.data),
                                     ctypes.c_void_p(_M19_packed.ctypes.data),
                                     ctypes.c_int(_M19.shape[0]),
                                     ctypes.c_int(_M19.shape[1]),
                                     ctypes.c_int(_M19.shape[2]),
                                     ctypes.c_int(S_0),
                                     ctypes.c_int(S_1),
                                     ctypes.c_int(W_0),
                                     ctypes.c_int(W_1))
                # step  39 end   for loop with indices ('V', 'W', 'Q', 'S')
                # step  40 deallocate ['_M15']
            # step  41 end   for loop with indices ('V', 'W', 'Q')
            # step  42 deallocate ['_M4']
        # step  43 end   for loop with indices ('V', 'W')
    # step  44 end   for loop with indices ('V',)
    # step  45 deallocate ['_M1', '_M6', '_M10']
    # step  46 USW,USW->
    output_tmp       = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(output_tmp))
    _M21 = output_tmp.value
    # clean the final forloop
    # MPI finalize
    if use_mpi:
        _M21 = reduce(_M21, root=0)
        _M21 = bcast(_M21, root=0)
    return _M21

def RMP3_XX_1_forloop_Q_U_determine_bucket_size_forloop(NVIR        : int,
                                                        NOCC        : int,
                                                        N_LAPLACE   : int,
                                                        NTHC_INT    : int,
                                                        Q_bunchsize = 8,
                                                        U_bunchsize = 8,
                                                        V_bunchsize = 1,
                                                        W_bunchsize = 1):
    # init
    output = []     
    bucked_0_size    = 0               
    bucked_1_size    = 0               
    bucked_2_size    = 0               
    bucked_3_size    = 0               
    bucked_4_size    = 0               
    bucked_5_size    = 0               
    bucked_6_size    = 0               
    bucked_7_size    = 0               
    bucked_8_size    = 0               
    bucked_9_size    = 0               
    # assign the size of each tensor
    _M1_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M3_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M0_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M2_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _INPUT_15_sliced_size = (NOCC * N_LAPLACE)
    _INPUT_21_sliced_size = (NVIR * N_LAPLACE)
    _M20_size        = (NTHC_INT * (W_bunchsize * (Q_bunchsize * V_bunchsize)))
    _M6_sliced_size  = (NTHC_INT * (Q_bunchsize * V_bunchsize))
    _M9_size         = (NTHC_INT * (Q_bunchsize * (V_bunchsize * (U_bunchsize * W_bunchsize))))
    _M11_perm_size   = (Q_bunchsize * (V_bunchsize * (NTHC_INT * (U_bunchsize * W_bunchsize))))
    _INPUT_18_sliced_size = (NVIR * N_LAPLACE)
    _M13_perm_size   = (Q_bunchsize * (U_bunchsize * (W_bunchsize * (NVIR * V_bunchsize))))
    _INPUT_0_sliced_size = (NTHC_INT * NTHC_INT)
    _M15_perm_size   = (U_bunchsize * (W_bunchsize * (V_bunchsize * (NTHC_INT * Q_bunchsize))))
    _M17_size        = (U_bunchsize * (Q_bunchsize * (V_bunchsize * (W_bunchsize * NOCC))))
    _INPUT_10_sliced_size = (NTHC_INT * NTHC_INT)
    _M10_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M6_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M7_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _INPUT_19_sliced_size = (NOCC * N_LAPLACE)
    _M1_sliced_size  = (Q_bunchsize * (V_bunchsize * NVIR))
    _M19_size        = (NTHC_INT * (Q_bunchsize * (V_bunchsize * W_bunchsize)))
    _M4_size         = (V_bunchsize * (W_bunchsize * NOCC))
    _M5_size         = (W_bunchsize * (Q_bunchsize * (V_bunchsize * NVIR)))
    _M20_perm_size   = (NTHC_INT * (W_bunchsize * (Q_bunchsize * V_bunchsize)))
    _M7_sliced_size  = (NTHC_INT * (U_bunchsize * W_bunchsize))
    _M10_sliced_size = (NTHC_INT * (U_bunchsize * W_bunchsize))
    _M12_size        = (NVIR * (Q_bunchsize * (V_bunchsize * (U_bunchsize * W_bunchsize))))
    _M14_size        = (NTHC_INT * (Q_bunchsize * (U_bunchsize * (W_bunchsize * V_bunchsize))))
    _M16_size        = (NOCC * (U_bunchsize * (W_bunchsize * (V_bunchsize * Q_bunchsize))))
    _M18_size        = (NTHC_INT * (U_bunchsize * (Q_bunchsize * (V_bunchsize * W_bunchsize))))
    _M8_size         = (Q_bunchsize * (V_bunchsize * (U_bunchsize * (W_bunchsize * NTHC_INT))))
    _M11_size        = (Q_bunchsize * (V_bunchsize * (NTHC_INT * (U_bunchsize * W_bunchsize))))
    _M13_size        = (Q_bunchsize * (U_bunchsize * (W_bunchsize * (NVIR * V_bunchsize))))
    _M15_size        = (U_bunchsize * (W_bunchsize * (V_bunchsize * (NTHC_INT * Q_bunchsize))))
    # determine the size of each bucket
    # bucket 0
    bucked_0_size    = max(bucked_0_size, _M1_size)
    # bucket 1
    bucked_1_size    = max(bucked_1_size, _M3_size)
    bucked_1_size    = max(bucked_1_size, _M0_size)
    bucked_1_size    = max(bucked_1_size, _M2_size)
    bucked_1_size    = max(bucked_1_size, _INPUT_15_sliced_size)
    bucked_1_size    = max(bucked_1_size, _INPUT_21_sliced_size)
    bucked_1_size    = max(bucked_1_size, _M20_size)
    bucked_1_size    = max(bucked_1_size, _M6_sliced_size)
    bucked_1_size    = max(bucked_1_size, _M9_size)
    bucked_1_size    = max(bucked_1_size, _M11_perm_size)
    bucked_1_size    = max(bucked_1_size, _INPUT_18_sliced_size)
    bucked_1_size    = max(bucked_1_size, _M13_perm_size)
    bucked_1_size    = max(bucked_1_size, _INPUT_0_sliced_size)
    bucked_1_size    = max(bucked_1_size, _M15_perm_size)
    bucked_1_size    = max(bucked_1_size, _M17_size)
    bucked_1_size    = max(bucked_1_size, _INPUT_10_sliced_size)
    # bucket 2
    bucked_2_size    = max(bucked_2_size, _M10_size)
    # bucket 3
    bucked_3_size    = max(bucked_3_size, _M6_size)
    # bucket 4
    bucked_4_size    = max(bucked_4_size, _M7_size)
    # bucket 5
    bucked_5_size    = max(bucked_5_size, _INPUT_19_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M1_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M19_size)
    # bucket 6
    bucked_6_size    = max(bucked_6_size, _M4_size)
    # bucket 7
    bucked_7_size    = max(bucked_7_size, _M5_size)
    bucked_7_size    = max(bucked_7_size, _M20_perm_size)
    # bucket 8
    bucked_8_size    = max(bucked_8_size, _M7_sliced_size)
    bucked_8_size    = max(bucked_8_size, _M10_sliced_size)
    bucked_8_size    = max(bucked_8_size, _M12_size)
    bucked_8_size    = max(bucked_8_size, _M14_size)
    bucked_8_size    = max(bucked_8_size, _M16_size)
    bucked_8_size    = max(bucked_8_size, _M18_size)
    # bucket 9
    bucked_9_size    = max(bucked_9_size, _M8_size)
    bucked_9_size    = max(bucked_9_size, _M11_size)
    bucked_9_size    = max(bucked_9_size, _M13_size)
    bucked_9_size    = max(bucked_9_size, _M15_size)
    # append each bucket size to the output
    output.append(bucked_0_size)
    output.append(bucked_1_size)
    output.append(bucked_2_size)
    output.append(bucked_3_size)
    output.append(bucked_4_size)
    output.append(bucked_5_size)
    output.append(bucked_6_size)
    output.append(bucked_7_size)
    output.append(bucked_8_size)
    output.append(bucked_9_size)
    return output

def RMP3_XX_1_forloop_Q_U_naive(Z           : np.ndarray,
                                X_o         : np.ndarray,
                                X_v         : np.ndarray,
                                tau_o       : np.ndarray,
                                tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    t1 = (logger.process_clock(), logger.perf_counter())
    _M1              = np.einsum("aQ,aV->QVa"    , _INPUT_4        , _INPUT_17       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M3              = np.einsum("cU,cW->UWc"    , _INPUT_14       , _INPUT_22       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.einsum("cS,UWc->SUW"   , _INPUT_9        , _M3             )
    del _M3         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M0              = np.einsum("jQ,jV->QVj"    , _INPUT_3        , _INPUT_16       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.einsum("jR,QVj->RQV"   , _INPUT_6        , _M0             )
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M2              = np.einsum("kU,kW->UWk"    , _INPUT_13       , _INPUT_20       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.einsum("kR,UWk->RUW"   , _INPUT_7        , _M2             )
    del _M2         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M4              = np.einsum("iV,iW->VWi"    , _INPUT_15       , _INPUT_19       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M5              = np.einsum("aW,QVa->WQVa"  , _INPUT_21       , _M1             )
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.einsum("aT,WQVa->TWQV" , _INPUT_12       , _M5             )
    del _M5         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20_perm        = np.transpose(_M20            , (0, 2, 3, 1)    )
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.einsum("RQV,RUW->QVUWR", _M6             , _M7             )
    del _M6         
    del _M7         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9              = np.einsum("RS,QVUWR->SQVUW", _INPUT_5        , _M8             )
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11             = np.einsum("SQVUW,SUW->QVSUW", _M9             , _M10            )
    del _M9         
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11_perm        = np.transpose(_M11            , (0, 1, 3, 4, 2) )
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.einsum("bS,QVUWS->bQVUW", _INPUT_8        , _M11_perm       )
    del _M11_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M13             = np.einsum("bV,bQVUW->QUWbV", _INPUT_18       , _M12            )
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M13_perm        = np.transpose(_M13            , (0, 1, 2, 4, 3) )
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.einsum("bP,QUWVb->PQUWV", _INPUT_2        , _M13_perm       )
    del _M13_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.einsum("PQ,PQUWV->UWVPQ", _INPUT_0        , _M14            )
    del _M14        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15_perm        = np.transpose(_M15            , (0, 1, 2, 4, 3) )
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.einsum("iP,UWVQP->iUWVQ", _INPUT_1        , _M15_perm       )
    del _M15_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.einsum("VWi,iUWVQ->UQVWi", _M4             , _M16            )
    del _M4         
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.einsum("iT,UQVWi->TUQVW", _INPUT_11       , _M17            )
    del _M17        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M19             = np.einsum("TU,TUQVW->TQVW", _INPUT_10       , _M18            )
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 25")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M21             = np.einsum("TQVW,TQVW->"   , _M19            , _M20_perm       )
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 26")
    return _M21

def RMP3_XX_1_forloop_Q_U(Z           : np.ndarray,
                          X_o         : np.ndarray,
                          X_v         : np.ndarray,
                          tau_o       : np.ndarray,
                          tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # step 0 aQ,aV->QVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_4.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_4.shape[0]),
                                 ctypes.c_int(_INPUT_4.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    # step 1 cU,cW->UWc 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_14.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_14.shape[0]),
                                 ctypes.c_int(_INPUT_14.shape[1]),
                                 ctypes.c_int(_INPUT_22.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    # step 2 cS,UWc->SUW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_9.shape[0]
    _INPUT_9_reshaped = _INPUT_9.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_9_reshaped.T, _M3_reshaped.T, c=_M10_reshaped)
    _M10         = _M10_reshaped.reshape(*shape_backup)
    del _M3         
    del _M3_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    # step 3 jQ,jV->QVj 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_3.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_3.shape[0]),
                                 ctypes.c_int(_INPUT_3.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    # step 4 jR,QVj->RQV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M0.shape[0]
    _size_dim_1      = _size_dim_1 * _M0.shape[1]
    _M0_reshaped = _M0.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_6_reshaped.T, _M0_reshaped.T, c=_M6_reshaped)
    _M6          = _M6_reshaped.reshape(*shape_backup)
    del _M0         
    del _M0_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    # step 5 kU,kW->UWk 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_13.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_13.shape[0]),
                                 ctypes.c_int(_INPUT_13.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    # step 6 kR,UWk->RUW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M7.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_7_reshaped.T, _M2_reshaped.T, c=_M7_reshaped)
    _M7          = _M7_reshaped.reshape(*shape_backup)
    del _M2         
    del _M2_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    # step 7 iV,iW->VWi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M4              = np.ndarray((N_LAPLACE, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_INPUT_19.ctypes.data),
                                 ctypes.c_void_p(_M4.ctypes.data),
                                 ctypes.c_int(_INPUT_15.shape[0]),
                                 ctypes.c_int(_INPUT_15.shape[1]),
                                 ctypes.c_int(_INPUT_19.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    # step 8 aW,QVa->WQVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M5              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_21.ctypes.data),
                                   ctypes.c_void_p(_M1.ctypes.data),
                                   ctypes.c_void_p(_M5.ctypes.data),
                                   ctypes.c_int(_INPUT_21.shape[0]),
                                   ctypes.c_int(_INPUT_21.shape[1]),
                                   ctypes.c_int(_M1.shape[0]),
                                   ctypes.c_int(_M1.shape[1]))
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    # step 9 aT,WQVa->TWQV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M5.shape[0]
    _size_dim_1      = _size_dim_1 * _M5.shape[1]
    _size_dim_1      = _size_dim_1 * _M5.shape[2]
    _M5_reshaped = _M5.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_12_reshaped.T, _M5_reshaped.T, c=_M20_reshaped)
    _M20         = _M20_reshaped.reshape(*shape_backup)
    del _M5         
    del _M5_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    # step 10 TWQV->TQVW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_0123_0231_wob = getattr(libpbc, "fn_permutation_0123_0231_wob", None)
    assert fn_permutation_0123_0231_wob is not None
    _M20_perm        = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE), dtype=np.float64)
    fn_permutation_0123_0231_wob(ctypes.c_void_p(_M20.ctypes.data),
                                 ctypes.c_void_p(_M20_perm.ctypes.data),
                                 ctypes.c_int(_M20.shape[0]),
                                 ctypes.c_int(_M20.shape[1]),
                                 ctypes.c_int(_M20.shape[2]),
                                 ctypes.c_int(_M20.shape[3]))
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    # step 11 RQV,RUW->QVUWR 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_034_12340_wob = getattr(libpbc, "fn_contraction_012_034_12340_wob", None)
    assert fn_contraction_012_034_12340_wob is not None
    _M8              = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_012_034_12340_wob(ctypes.c_void_p(_M6.ctypes.data),
                                     ctypes.c_void_p(_M7.ctypes.data),
                                     ctypes.c_void_p(_M8.ctypes.data),
                                     ctypes.c_int(_M6.shape[0]),
                                     ctypes.c_int(_M6.shape[1]),
                                     ctypes.c_int(_M6.shape[2]),
                                     ctypes.c_int(_M7.shape[1]),
                                     ctypes.c_int(_M7.shape[2]))
    del _M6         
    del _M7         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    # step 12 RS,QVUWR->SQVUW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_5.shape[0]
    _INPUT_5_reshaped = _INPUT_5.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M8.shape[0]
    _size_dim_1      = _size_dim_1 * _M8.shape[1]
    _size_dim_1      = _size_dim_1 * _M8.shape[2]
    _size_dim_1      = _size_dim_1 * _M8.shape[3]
    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M9.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M9.shape[0]
    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_5_reshaped.T, _M8_reshaped.T, c=_M9_reshaped)
    _M9          = _M9_reshaped.reshape(*shape_backup)
    del _M8         
    del _M8_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    # step 13 SQVUW,SUW->QVSUW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01234_034_12034_wob = getattr(libpbc, "fn_contraction_01234_034_12034_wob", None)
    assert fn_contraction_01234_034_12034_wob is not None
    _M11             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_01234_034_12034_wob(ctypes.c_void_p(_M9.ctypes.data),
                                       ctypes.c_void_p(_M10.ctypes.data),
                                       ctypes.c_void_p(_M11.ctypes.data),
                                       ctypes.c_int(_M9.shape[0]),
                                       ctypes.c_int(_M9.shape[1]),
                                       ctypes.c_int(_M9.shape[2]),
                                       ctypes.c_int(_M9.shape[3]),
                                       ctypes.c_int(_M9.shape[4]))
    del _M9         
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    # step 14 QVSUW->QVUWS 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_01342_wob = getattr(libpbc, "fn_permutation_01234_01342_wob", None)
    assert fn_permutation_01234_01342_wob is not None
    _M11_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_01342_wob(ctypes.c_void_p(_M11.ctypes.data),
                                   ctypes.c_void_p(_M11_perm.ctypes.data),
                                   ctypes.c_int(_M11.shape[0]),
                                   ctypes.c_int(_M11.shape[1]),
                                   ctypes.c_int(_M11.shape[2]),
                                   ctypes.c_int(_M11.shape[3]),
                                   ctypes.c_int(_M11.shape[4]))
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    # step 15 bS,QVUWS->bQVUW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.ndarray((NVIR, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_8.shape[0]
    _INPUT_8_reshaped = _INPUT_8.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[3]
    _M11_perm_reshaped = _M11_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M12.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M12.shape[0]
    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_8_reshaped, _M11_perm_reshaped.T, c=_M12_reshaped)
    _M12         = _M12_reshaped.reshape(*shape_backup)
    del _M11_perm   
    del _M11_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    # step 16 bV,bQVUW->QUWbV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02134_23401_wob = getattr(libpbc, "fn_contraction_01_02134_23401_wob", None)
    assert fn_contraction_01_02134_23401_wob is not None
    _M13             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NVIR, N_LAPLACE), dtype=np.float64)
    fn_contraction_01_02134_23401_wob(ctypes.c_void_p(_INPUT_18.ctypes.data),
                                      ctypes.c_void_p(_M12.ctypes.data),
                                      ctypes.c_void_p(_M13.ctypes.data),
                                      ctypes.c_int(_INPUT_18.shape[0]),
                                      ctypes.c_int(_INPUT_18.shape[1]),
                                      ctypes.c_int(_M12.shape[1]),
                                      ctypes.c_int(_M12.shape[3]),
                                      ctypes.c_int(_M12.shape[4]))
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    # step 17 QUWbV->QUWVb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_01243_wob = getattr(libpbc, "fn_permutation_01234_01243_wob", None)
    assert fn_permutation_01234_01243_wob is not None
    _M13_perm        = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE, NVIR), dtype=np.float64)
    fn_permutation_01234_01243_wob(ctypes.c_void_p(_M13.ctypes.data),
                                   ctypes.c_void_p(_M13_perm.ctypes.data),
                                   ctypes.c_int(_M13.shape[0]),
                                   ctypes.c_int(_M13.shape[1]),
                                   ctypes.c_int(_M13.shape[2]),
                                   ctypes.c_int(_M13.shape[3]),
                                   ctypes.c_int(_M13.shape[4]))
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    # step 18 bP,QUWVb->PQUWV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.ndarray((NTHC_INT, NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_2.shape[0]
    _INPUT_2_reshaped = _INPUT_2.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M13_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M13_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M13_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M13_perm.shape[3]
    _M13_perm_reshaped = _M13_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_2_reshaped.T, _M13_perm_reshaped.T, c=_M14_reshaped)
    _M14         = _M14_reshaped.reshape(*shape_backup)
    del _M13_perm   
    del _M13_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    # step 19 PQ,PQUWV->UWVPQ 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_01234_23401_wob = getattr(libpbc, "fn_contraction_01_01234_23401_wob", None)
    assert fn_contraction_01_01234_23401_wob is not None
    _M15             = np.ndarray((NTHC_INT, N_LAPLACE, N_LAPLACE, NTHC_INT, NTHC_INT), dtype=np.float64)
    fn_contraction_01_01234_23401_wob(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                      ctypes.c_void_p(_M14.ctypes.data),
                                      ctypes.c_void_p(_M15.ctypes.data),
                                      ctypes.c_int(_INPUT_0.shape[0]),
                                      ctypes.c_int(_INPUT_0.shape[1]),
                                      ctypes.c_int(_M14.shape[2]),
                                      ctypes.c_int(_M14.shape[3]),
                                      ctypes.c_int(_M14.shape[4]))
    del _M14        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    # step 20 UWVPQ->UWVQP 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_01243_wob = getattr(libpbc, "fn_permutation_01234_01243_wob", None)
    assert fn_permutation_01234_01243_wob is not None
    _M15_perm        = np.ndarray((NTHC_INT, N_LAPLACE, N_LAPLACE, NTHC_INT, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_01243_wob(ctypes.c_void_p(_M15.ctypes.data),
                                   ctypes.c_void_p(_M15_perm.ctypes.data),
                                   ctypes.c_int(_M15.shape[0]),
                                   ctypes.c_int(_M15.shape[1]),
                                   ctypes.c_int(_M15.shape[2]),
                                   ctypes.c_int(_M15.shape[3]),
                                   ctypes.c_int(_M15.shape[4]))
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    # step 21 iP,UWVQP->iUWVQ 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.ndarray((NOCC, NTHC_INT, N_LAPLACE, N_LAPLACE, NTHC_INT), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_1.shape[0]
    _INPUT_1_reshaped = _INPUT_1.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M15_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M15_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M15_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M15_perm.shape[3]
    _M15_perm_reshaped = _M15_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M16.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M16.shape[0]
    _M16_reshaped = _M16.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_1_reshaped, _M15_perm_reshaped.T, c=_M16_reshaped)
    _M16         = _M16_reshaped.reshape(*shape_backup)
    del _M15_perm   
    del _M15_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    # step 22 VWi,iUWVQ->UQVWi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_23104_34012_wob = getattr(libpbc, "fn_contraction_012_23104_34012_wob", None)
    assert fn_contraction_012_23104_34012_wob is not None
    _M17             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_012_23104_34012_wob(ctypes.c_void_p(_M4.ctypes.data),
                                       ctypes.c_void_p(_M16.ctypes.data),
                                       ctypes.c_void_p(_M17.ctypes.data),
                                       ctypes.c_int(_M4.shape[0]),
                                       ctypes.c_int(_M4.shape[1]),
                                       ctypes.c_int(_M4.shape[2]),
                                       ctypes.c_int(_M16.shape[1]),
                                       ctypes.c_int(_M16.shape[4]))
    del _M4         
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    # step 23 iT,UQVWi->TUQVW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.ndarray((NTHC_INT, NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M17.shape[0]
    _size_dim_1      = _size_dim_1 * _M17.shape[1]
    _size_dim_1      = _size_dim_1 * _M17.shape[2]
    _size_dim_1      = _size_dim_1 * _M17.shape[3]
    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_11_reshaped.T, _M17_reshaped.T, c=_M18_reshaped)
    _M18         = _M18_reshaped.reshape(*shape_backup)
    del _M17        
    del _M17_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    # step 24 TU,TUQVW->TQVW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_01234_0234_wob = getattr(libpbc, "fn_contraction_01_01234_0234_wob", None)
    assert fn_contraction_01_01234_0234_wob is not None
    _M19             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE), dtype=np.float64)
    fn_contraction_01_01234_0234_wob(ctypes.c_void_p(_INPUT_10.ctypes.data),
                                     ctypes.c_void_p(_M18.ctypes.data),
                                     ctypes.c_void_p(_M19.ctypes.data),
                                     ctypes.c_int(_INPUT_10.shape[0]),
                                     ctypes.c_int(_INPUT_10.shape[1]),
                                     ctypes.c_int(_M18.shape[2]),
                                     ctypes.c_int(_M18.shape[3]),
                                     ctypes.c_int(_M18.shape[4]))
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 25")
    # step 25 TQVW,TQVW-> 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    _M21             = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20_perm.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(_M21))
    _M21 = _M21.value
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 26")
    return _M21

def RMP3_XX_1_forloop_Q_U_forloop_Q_U(Z           : np.ndarray,
                                      X_o         : np.ndarray,
                                      X_v         : np.ndarray,
                                      tau_o       : np.ndarray,
                                      tau_v       : np.ndarray,
                                      buffer      : np.ndarray,
                                      Q_bunchsize = 8,
                                      U_bunchsize = 8,
                                      V_bunchsize = 1,
                                      W_bunchsize = 1,
                                      use_mpi = False):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # fetch function pointers
    fn_contraction_01234_034_12034_wob = getattr(libpbc, "fn_contraction_01234_034_12034_wob", None)
    assert fn_contraction_01234_034_12034_wob is not None
    fn_contraction_012_23104_34012_wob = getattr(libpbc, "fn_contraction_012_23104_34012_wob", None)
    assert fn_contraction_012_23104_34012_wob is not None
    fn_permutation_01234_01342_wob = getattr(libpbc, "fn_permutation_01234_01342_wob", None)
    assert fn_permutation_01234_01342_wob is not None
    fn_slice_3_1_2 = getattr(libpbc, "fn_slice_3_1_2", None)
    assert fn_slice_3_1_2 is not None
    fn_contraction_01_01234_0234_plus_wob = getattr(libpbc, "fn_contraction_01_01234_0234_plus_wob", None)
    assert fn_contraction_01_01234_0234_plus_wob is not None
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    fn_slice_2_1 = getattr(libpbc, "fn_slice_2_1", None)
    assert fn_slice_2_1 is not None
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    fn_slice_3_0_1 = getattr(libpbc, "fn_slice_3_0_1", None)
    assert fn_slice_3_0_1 is not None
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    fn_contraction_01_01234_23401_wob = getattr(libpbc, "fn_contraction_01_01234_23401_wob", None)
    assert fn_contraction_01_01234_23401_wob is not None
    fn_contraction_01_02134_23401_wob = getattr(libpbc, "fn_contraction_01_02134_23401_wob", None)
    assert fn_contraction_01_02134_23401_wob is not None
    fn_permutation_0123_0231_wob = getattr(libpbc, "fn_permutation_0123_0231_wob", None)
    assert fn_permutation_0123_0231_wob is not None
    fn_permutation_01234_01243_wob = getattr(libpbc, "fn_permutation_01234_01243_wob", None)
    assert fn_permutation_01234_01243_wob is not None
    fn_contraction_012_034_12340_wob = getattr(libpbc, "fn_contraction_012_034_12340_wob", None)
    assert fn_contraction_012_034_12340_wob is not None
    if use_mpi:
        bunchsize = NTHC_INT//comm_size + 1
        Q_begin = rank*bunchsize
        Q_end = (rank+1)*bunchsize
        Q_begin          = min(Q_begin, NTHC_INT)
        Q_end            = min(Q_end, NTHC_INT)
    else:
        Q_begin          = 0               
        Q_end            = NTHC_INT        
    # preallocate buffer
    bucket_size      = RMP3_XX_1_forloop_Q_U_determine_bucket_size_forloop(NVIR = NVIR,
                                                                           NOCC = NOCC,
                                                                           N_LAPLACE = N_LAPLACE,
                                                                           NTHC_INT = NTHC_INT,
                                                                           V_bunchsize = V_bunchsize,
                                                                           W_bunchsize = W_bunchsize,
                                                                           Q_bunchsize = Q_bunchsize,
                                                                           U_bunchsize = U_bunchsize)
    bufsize_now      = buffer.size     
    _itemsize        = buffer.itemsize 
    offset_now       = 0               
    offset_0         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[0])
    offset_1         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[1])
    offset_2         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[2])
    offset_3         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[3])
    offset_4         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[4])
    offset_5         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[5])
    offset_6         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[6])
    offset_7         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[7])
    offset_8         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[8])
    offset_9         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[9])
    bufsize          = offset_now      
    if (bufsize > bufsize_now):
        buffer           = np.ndarray((bufsize), dtype=np.float64)
    # step   0 start for loop with indices ()
    # step   1 allocate   _M21
    _M21             = 0.0             
    # step   2 aQ,aV->QVa
    offset_now       = offset_0        
    _M1_offset       = offset_now      
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M1_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_4.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_4.shape[0]),
                                 ctypes.c_int(_INPUT_4.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    # step   3 cU,cW->UWc
    offset_now       = offset_1        
    _M3_offset       = offset_now      
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M3_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_14.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_14.shape[0]),
                                 ctypes.c_int(_INPUT_14.shape[1]),
                                 ctypes.c_int(_INPUT_22.shape[1]))
    # step   4 cS,UWc->SUW
    offset_now       = offset_2        
    _M10_offset      = offset_now      
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M10_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_9.shape[0]
    _INPUT_9_reshaped = _INPUT_9.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_9_reshaped.T, _M3_reshaped.T, c=_M10_reshaped)
    _M10             = _M10_reshaped.reshape(*shape_backup)
    # step   5 jQ,jV->QVj
    offset_now       = offset_1        
    _M0_offset       = offset_now      
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M0_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_3.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_3.shape[0]),
                                 ctypes.c_int(_INPUT_3.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    # step   6 jR,QVj->RQV
    offset_now       = offset_3        
    _M6_offset       = offset_now      
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M6_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M0.shape[0]
    _size_dim_1      = _size_dim_1 * _M0.shape[1]
    _M0_reshaped = _M0.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_6_reshaped.T, _M0_reshaped.T, c=_M6_reshaped)
    _M6              = _M6_reshaped.reshape(*shape_backup)
    # step   7 kU,kW->UWk
    offset_now       = offset_1        
    _M2_offset       = offset_now      
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M2_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_13.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_13.shape[0]),
                                 ctypes.c_int(_INPUT_13.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    # step   8 kR,UWk->RUW
    offset_now       = offset_4        
    _M7_offset       = offset_now      
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M7_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M7.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_7_reshaped.T, _M2_reshaped.T, c=_M7_reshaped)
    _M7              = _M7_reshaped.reshape(*shape_backup)
    # step   9 start for loop with indices ('V',)
    for V_0, V_1 in lib.prange(0,N_LAPLACE,V_bunchsize):
        # step  10 start for loop with indices ('V', 'W')
        for W_0, W_1 in lib.prange(0,N_LAPLACE,W_bunchsize):
            # step  11 slice _INPUT_15 with indices ['V']
            _INPUT_15_sliced_offset = offset_1        
            _INPUT_15_sliced = np.ndarray((NOCC, (V_1-V_0)), buffer = buffer, offset = _INPUT_15_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_15.ctypes.data),
                         ctypes.c_void_p(_INPUT_15_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_15.shape[0]),
                         ctypes.c_int(_INPUT_15.shape[1]),
                         ctypes.c_int(V_0),
                         ctypes.c_int(V_1))
            # step  12 slice _INPUT_19 with indices ['W']
            _INPUT_19_sliced_offset = offset_5        
            _INPUT_19_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_19_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_19.ctypes.data),
                         ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_19.shape[0]),
                         ctypes.c_int(_INPUT_19.shape[1]),
                         ctypes.c_int(W_0),
                         ctypes.c_int(W_1))
            # step  13 iV,iW->VWi
            offset_now       = offset_6        
            _M4_offset       = offset_now      
            _M4              = np.ndarray(((V_1-V_0), (W_1-W_0), NOCC), buffer = buffer, offset = _M4_offset)
            fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_15_sliced.ctypes.data),
                                         ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                                         ctypes.c_void_p(_M4.ctypes.data),
                                         ctypes.c_int(_INPUT_15_sliced.shape[0]),
                                         ctypes.c_int(_INPUT_15_sliced.shape[1]),
                                         ctypes.c_int(_INPUT_19_sliced.shape[1]))
            # step  14 start for loop with indices ('V', 'W', 'Q')
            for Q_0, Q_1 in lib.prange(Q_begin,Q_end,Q_bunchsize):
                # step  15 slice _INPUT_21 with indices ['W']
                _INPUT_21_sliced_offset = offset_1        
                _INPUT_21_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_21_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_21.ctypes.data),
                             ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_21.shape[0]),
                             ctypes.c_int(_INPUT_21.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  16 slice _M1 with indices ['Q', 'V']
                _M1_sliced_offset = offset_5        
                _M1_sliced       = np.ndarray(((Q_1-Q_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M1_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M1.ctypes.data),
                               ctypes.c_void_p(_M1_sliced.ctypes.data),
                               ctypes.c_int(_M1.shape[0]),
                               ctypes.c_int(_M1.shape[1]),
                               ctypes.c_int(_M1.shape[2]),
                               ctypes.c_int(Q_0),
                               ctypes.c_int(Q_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  17 aW,QVa->WQVa
                offset_now       = offset_7        
                _M5_offset       = offset_now      
                _M5              = np.ndarray(((W_1-W_0), (Q_1-Q_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M5_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                                               ctypes.c_void_p(_M1_sliced.ctypes.data),
                                               ctypes.c_void_p(_M5.ctypes.data),
                                               ctypes.c_int(_INPUT_21_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_21_sliced.shape[1]),
                                               ctypes.c_int(_M1_sliced.shape[0]),
                                               ctypes.c_int(_M1_sliced.shape[1]))
                # step  18 aT,WQVa->TWQV
                offset_now       = offset_1        
                _M20_offset      = offset_now      
                _M20             = np.ndarray((NTHC_INT, (W_1-W_0), (Q_1-Q_0), (V_1-V_0)), buffer = buffer, offset = _M20_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
                _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M5.shape[0]
                _size_dim_1      = _size_dim_1 * _M5.shape[1]
                _size_dim_1      = _size_dim_1 * _M5.shape[2]
                _M5_reshaped = _M5.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M20.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M20.shape[0]
                _M20_reshaped = _M20.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_12_reshaped.T, _M5_reshaped.T, c=_M20_reshaped)
                _M20             = _M20_reshaped.reshape(*shape_backup)
                # step  19 allocate   _M19
                offset_now       = offset_5        
                _M19             = np.ndarray((NTHC_INT, (Q_1-Q_0), (V_1-V_0), (W_1-W_0)), buffer = buffer, offset = offset_now)
                _M19_offset      = offset_now      
                _M19.ravel()[:] = 0.0
                # step  20 TWQV->TQVW
                _M20_perm_offset = offset_7        
                _M20_perm        = np.ndarray((NTHC_INT, (Q_1-Q_0), (V_1-V_0), (W_1-W_0)), buffer = buffer, offset = _M20_perm_offset)
                fn_permutation_0123_0231_wob(ctypes.c_void_p(_M20.ctypes.data),
                                             ctypes.c_void_p(_M20_perm.ctypes.data),
                                             ctypes.c_int(NTHC_INT),
                                             ctypes.c_int((W_1-W_0)),
                                             ctypes.c_int((Q_1-Q_0)),
                                             ctypes.c_int((V_1-V_0)))
                # step  21 start for loop with indices ('V', 'W', 'Q', 'U')
                for U_0, U_1 in lib.prange(0,NTHC_INT,U_bunchsize):
                    # step  22 slice _M6 with indices ['Q', 'V']
                    _M6_sliced_offset = offset_1        
                    _M6_sliced       = np.ndarray((NTHC_INT, (Q_1-Q_0), (V_1-V_0)), buffer = buffer, offset = _M6_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                   ctypes.c_int(_M6.shape[0]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]),
                                   ctypes.c_int(Q_0),
                                   ctypes.c_int(Q_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  23 slice _M7 with indices ['U', 'W']
                    _M7_sliced_offset = offset_8        
                    _M7_sliced       = np.ndarray((NTHC_INT, (U_1-U_0), (W_1-W_0)), buffer = buffer, offset = _M7_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M7.ctypes.data),
                                   ctypes.c_void_p(_M7_sliced.ctypes.data),
                                   ctypes.c_int(_M7.shape[0]),
                                   ctypes.c_int(_M7.shape[1]),
                                   ctypes.c_int(_M7.shape[2]),
                                   ctypes.c_int(U_0),
                                   ctypes.c_int(U_1),
                                   ctypes.c_int(W_0),
                                   ctypes.c_int(W_1))
                    # step  24 RQV,RUW->QVUWR
                    offset_now       = offset_9        
                    _M8_offset       = offset_now      
                    _M8              = np.ndarray(((Q_1-Q_0), (V_1-V_0), (U_1-U_0), (W_1-W_0), NTHC_INT), buffer = buffer, offset = _M8_offset)
                    fn_contraction_012_034_12340_wob(ctypes.c_void_p(_M6_sliced.ctypes.data),
                                                     ctypes.c_void_p(_M7_sliced.ctypes.data),
                                                     ctypes.c_void_p(_M8.ctypes.data),
                                                     ctypes.c_int(_M6_sliced.shape[0]),
                                                     ctypes.c_int(_M6_sliced.shape[1]),
                                                     ctypes.c_int(_M6_sliced.shape[2]),
                                                     ctypes.c_int(_M7_sliced.shape[1]),
                                                     ctypes.c_int(_M7_sliced.shape[2]))
                    # step  25 RS,QVUWR->SQVUW
                    offset_now       = offset_1        
                    _M9_offset       = offset_now      
                    _M9              = np.ndarray((NTHC_INT, (Q_1-Q_0), (V_1-V_0), (U_1-U_0), (W_1-W_0)), buffer = buffer, offset = _M9_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_5.shape[0]
                    _INPUT_5_reshaped = _INPUT_5.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M8.shape[0]
                    _size_dim_1      = _size_dim_1 * _M8.shape[1]
                    _size_dim_1      = _size_dim_1 * _M8.shape[2]
                    _size_dim_1      = _size_dim_1 * _M8.shape[3]
                    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M9.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M9.shape[0]
                    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_5_reshaped.T, _M8_reshaped.T, c=_M9_reshaped)
                    _M9              = _M9_reshaped.reshape(*shape_backup)
                    # step  26 slice _M10 with indices ['U', 'W']
                    _M10_sliced_offset = offset_8        
                    _M10_sliced      = np.ndarray((NTHC_INT, (U_1-U_0), (W_1-W_0)), buffer = buffer, offset = _M10_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M10.ctypes.data),
                                   ctypes.c_void_p(_M10_sliced.ctypes.data),
                                   ctypes.c_int(_M10.shape[0]),
                                   ctypes.c_int(_M10.shape[1]),
                                   ctypes.c_int(_M10.shape[2]),
                                   ctypes.c_int(U_0),
                                   ctypes.c_int(U_1),
                                   ctypes.c_int(W_0),
                                   ctypes.c_int(W_1))
                    # step  27 SQVUW,SUW->QVSUW
                    offset_now       = offset_9        
                    _M11_offset      = offset_now      
                    _M11             = np.ndarray(((Q_1-Q_0), (V_1-V_0), NTHC_INT, (U_1-U_0), (W_1-W_0)), buffer = buffer, offset = _M11_offset)
                    fn_contraction_01234_034_12034_wob(ctypes.c_void_p(_M9.ctypes.data),
                                                       ctypes.c_void_p(_M10_sliced.ctypes.data),
                                                       ctypes.c_void_p(_M11.ctypes.data),
                                                       ctypes.c_int(_M9.shape[0]),
                                                       ctypes.c_int(_M9.shape[1]),
                                                       ctypes.c_int(_M9.shape[2]),
                                                       ctypes.c_int(_M9.shape[3]),
                                                       ctypes.c_int(_M9.shape[4]))
                    # step  28 QVSUW->QVUWS
                    _M11_perm_offset = offset_1        
                    _M11_perm        = np.ndarray(((Q_1-Q_0), (V_1-V_0), (U_1-U_0), (W_1-W_0), NTHC_INT), buffer = buffer, offset = _M11_perm_offset)
                    fn_permutation_01234_01342_wob(ctypes.c_void_p(_M11.ctypes.data),
                                                   ctypes.c_void_p(_M11_perm.ctypes.data),
                                                   ctypes.c_int((Q_1-Q_0)),
                                                   ctypes.c_int((V_1-V_0)),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((U_1-U_0)),
                                                   ctypes.c_int((W_1-W_0)))
                    # step  29 bS,QVUWS->bQVUW
                    offset_now       = offset_8        
                    _M12_offset      = offset_now      
                    _M12             = np.ndarray((NVIR, (Q_1-Q_0), (V_1-V_0), (U_1-U_0), (W_1-W_0)), buffer = buffer, offset = _M12_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_8.shape[0]
                    _INPUT_8_reshaped = _INPUT_8.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[3]
                    _M11_perm_reshaped = _M11_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M12.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M12.shape[0]
                    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_8_reshaped, _M11_perm_reshaped.T, c=_M12_reshaped)
                    _M12             = _M12_reshaped.reshape(*shape_backup)
                    # step  30 slice _INPUT_18 with indices ['V']
                    _INPUT_18_sliced_offset = offset_1        
                    _INPUT_18_sliced = np.ndarray((NVIR, (V_1-V_0)), buffer = buffer, offset = _INPUT_18_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_18.shape[0]),
                                 ctypes.c_int(_INPUT_18.shape[1]),
                                 ctypes.c_int(V_0),
                                 ctypes.c_int(V_1))
                    # step  31 bV,bQVUW->QUWbV
                    offset_now       = offset_9        
                    _M13_offset      = offset_now      
                    _M13             = np.ndarray(((Q_1-Q_0), (U_1-U_0), (W_1-W_0), NVIR, (V_1-V_0)), buffer = buffer, offset = _M13_offset)
                    fn_contraction_01_02134_23401_wob(ctypes.c_void_p(_INPUT_18_sliced.ctypes.data),
                                                      ctypes.c_void_p(_M12.ctypes.data),
                                                      ctypes.c_void_p(_M13.ctypes.data),
                                                      ctypes.c_int(_INPUT_18_sliced.shape[0]),
                                                      ctypes.c_int(_INPUT_18_sliced.shape[1]),
                                                      ctypes.c_int(_M12.shape[1]),
                                                      ctypes.c_int(_M12.shape[3]),
                                                      ctypes.c_int(_M12.shape[4]))
                    # step  32 QUWbV->QUWVb
                    _M13_perm_offset = offset_1        
                    _M13_perm        = np.ndarray(((Q_1-Q_0), (U_1-U_0), (W_1-W_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M13_perm_offset)
                    fn_permutation_01234_01243_wob(ctypes.c_void_p(_M13.ctypes.data),
                                                   ctypes.c_void_p(_M13_perm.ctypes.data),
                                                   ctypes.c_int((Q_1-Q_0)),
                                                   ctypes.c_int((U_1-U_0)),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int(NVIR),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  33 bP,QUWVb->PQUWV
                    offset_now       = offset_8        
                    _M14_offset      = offset_now      
                    _M14             = np.ndarray((NTHC_INT, (Q_1-Q_0), (U_1-U_0), (W_1-W_0), (V_1-V_0)), buffer = buffer, offset = _M14_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_2.shape[0]
                    _INPUT_2_reshaped = _INPUT_2.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M13_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M13_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M13_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M13_perm.shape[3]
                    _M13_perm_reshaped = _M13_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M14.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M14.shape[0]
                    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_2_reshaped.T, _M13_perm_reshaped.T, c=_M14_reshaped)
                    _M14             = _M14_reshaped.reshape(*shape_backup)
                    # step  34 slice _INPUT_0 with indices ['Q']
                    _INPUT_0_sliced_offset = offset_1        
                    _INPUT_0_sliced  = np.ndarray((NTHC_INT, (Q_1-Q_0)), buffer = buffer, offset = _INPUT_0_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                 ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_0.shape[0]),
                                 ctypes.c_int(_INPUT_0.shape[1]),
                                 ctypes.c_int(Q_0),
                                 ctypes.c_int(Q_1))
                    # step  35 PQ,PQUWV->UWVPQ
                    offset_now       = offset_9        
                    _M15_offset      = offset_now      
                    _M15             = np.ndarray(((U_1-U_0), (W_1-W_0), (V_1-V_0), NTHC_INT, (Q_1-Q_0)), buffer = buffer, offset = _M15_offset)
                    fn_contraction_01_01234_23401_wob(ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                                      ctypes.c_void_p(_M14.ctypes.data),
                                                      ctypes.c_void_p(_M15.ctypes.data),
                                                      ctypes.c_int(_INPUT_0_sliced.shape[0]),
                                                      ctypes.c_int(_INPUT_0_sliced.shape[1]),
                                                      ctypes.c_int(_M14.shape[2]),
                                                      ctypes.c_int(_M14.shape[3]),
                                                      ctypes.c_int(_M14.shape[4]))
                    # step  36 UWVPQ->UWVQP
                    _M15_perm_offset = offset_1        
                    _M15_perm        = np.ndarray(((U_1-U_0), (W_1-W_0), (V_1-V_0), (Q_1-Q_0), NTHC_INT), buffer = buffer, offset = _M15_perm_offset)
                    fn_permutation_01234_01243_wob(ctypes.c_void_p(_M15.ctypes.data),
                                                   ctypes.c_void_p(_M15_perm.ctypes.data),
                                                   ctypes.c_int((U_1-U_0)),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((V_1-V_0)),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((Q_1-Q_0)))
                    # step  37 iP,UWVQP->iUWVQ
                    offset_now       = offset_8        
                    _M16_offset      = offset_now      
                    _M16             = np.ndarray((NOCC, (U_1-U_0), (W_1-W_0), (V_1-V_0), (Q_1-Q_0)), buffer = buffer, offset = _M16_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_1.shape[0]
                    _INPUT_1_reshaped = _INPUT_1.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M15_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M15_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M15_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M15_perm.shape[3]
                    _M15_perm_reshaped = _M15_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M16.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M16.shape[0]
                    _M16_reshaped = _M16.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_1_reshaped, _M15_perm_reshaped.T, c=_M16_reshaped)
                    _M16             = _M16_reshaped.reshape(*shape_backup)
                    # step  38 VWi,iUWVQ->UQVWi
                    offset_now       = offset_1        
                    _M17_offset      = offset_now      
                    _M17             = np.ndarray(((U_1-U_0), (Q_1-Q_0), (V_1-V_0), (W_1-W_0), NOCC), buffer = buffer, offset = _M17_offset)
                    fn_contraction_012_23104_34012_wob(ctypes.c_void_p(_M4.ctypes.data),
                                                       ctypes.c_void_p(_M16.ctypes.data),
                                                       ctypes.c_void_p(_M17.ctypes.data),
                                                       ctypes.c_int(_M4.shape[0]),
                                                       ctypes.c_int(_M4.shape[1]),
                                                       ctypes.c_int(_M4.shape[2]),
                                                       ctypes.c_int(_M16.shape[1]),
                                                       ctypes.c_int(_M16.shape[4]))
                    # step  39 iT,UQVWi->TUQVW
                    offset_now       = offset_8        
                    _M18_offset      = offset_now      
                    _M18             = np.ndarray((NTHC_INT, (U_1-U_0), (Q_1-Q_0), (V_1-V_0), (W_1-W_0)), buffer = buffer, offset = _M18_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
                    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M17.shape[0]
                    _size_dim_1      = _size_dim_1 * _M17.shape[1]
                    _size_dim_1      = _size_dim_1 * _M17.shape[2]
                    _size_dim_1      = _size_dim_1 * _M17.shape[3]
                    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M18.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M18.shape[0]
                    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_11_reshaped.T, _M17_reshaped.T, c=_M18_reshaped)
                    _M18             = _M18_reshaped.reshape(*shape_backup)
                    # step  40 slice _INPUT_10 with indices ['U']
                    _INPUT_10_sliced_offset = offset_1        
                    _INPUT_10_sliced = np.ndarray((NTHC_INT, (U_1-U_0)), buffer = buffer, offset = _INPUT_10_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_10.ctypes.data),
                                 ctypes.c_void_p(_INPUT_10_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_10.shape[0]),
                                 ctypes.c_int(_INPUT_10.shape[1]),
                                 ctypes.c_int(U_0),
                                 ctypes.c_int(U_1))
                    # step  41 TU,TUQVW->TQVW
                    offset_now       = offset_5        
                    fn_contraction_01_01234_0234_plus_wob(ctypes.c_void_p(_INPUT_10_sliced.ctypes.data),
                                                          ctypes.c_void_p(_M18.ctypes.data),
                                                          ctypes.c_void_p(_M19.ctypes.data),
                                                          ctypes.c_int(_INPUT_10_sliced.shape[0]),
                                                          ctypes.c_int(_INPUT_10_sliced.shape[1]),
                                                          ctypes.c_int(_M18.shape[2]),
                                                          ctypes.c_int(_M18.shape[3]),
                                                          ctypes.c_int(_M18.shape[4]))
                # step  42 end   for loop with indices ('V', 'W', 'Q', 'U')
                # step  43 TQVW,TQVW->
                output_tmp       = ctypes.c_double(0.0)
                fn_dot(ctypes.c_void_p(_M19.ctypes.data),
                       ctypes.c_void_p(_M20_perm.ctypes.data),
                       ctypes.c_int(_M19.size),
                       ctypes.pointer(output_tmp))
                output_tmp = output_tmp.value
                _M21 += output_tmp
            # step  44 end   for loop with indices ('V', 'W', 'Q')
        # step  45 end   for loop with indices ('V', 'W')
    # step  46 end   for loop with indices ('V',)
    # clean the final forloop
    # MPI finalize
    if use_mpi:
        _M21 = reduce(_M21, root=0)
        _M21 = bcast(_M21, root=0)
    return _M21

def RMP3_XX_1_forloop_R_T_determine_bucket_size_forloop(NVIR        : int,
                                                        NOCC        : int,
                                                        N_LAPLACE   : int,
                                                        NTHC_INT    : int,
                                                        T_bunchsize = 8,
                                                        R_bunchsize = 8,
                                                        V_bunchsize = 1,
                                                        W_bunchsize = 1):
    # init
    output = []     
    bucked_0_size    = 0               
    bucked_1_size    = 0               
    bucked_2_size    = 0               
    bucked_3_size    = 0               
    bucked_4_size    = 0               
    bucked_5_size    = 0               
    bucked_6_size    = 0               
    bucked_7_size    = 0               
    bucked_8_size    = 0               
    bucked_9_size    = 0               
    # assign the size of each tensor
    _M2_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M0_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M3_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M7_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M1_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _INPUT_19_sliced_size = (NOCC * N_LAPLACE)
    _M6_size         = (NTHC_INT * (W_bunchsize * (T_bunchsize * V_bunchsize)))
    _M18_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M2_sliced_size  = (T_bunchsize * (V_bunchsize * NOCC))
    _INPUT_21_sliced_size = (NVIR * N_LAPLACE)
    _M8_size         = (NTHC_INT * (W_bunchsize * (T_bunchsize * V_bunchsize)))
    _M4_size         = (W_bunchsize * (T_bunchsize * (V_bunchsize * NOCC)))
    _M3_sliced_size  = (T_bunchsize * (V_bunchsize * NVIR))
    _M7_sliced_size  = (NTHC_INT * (R_bunchsize * V_bunchsize))
    _M9_perm_size    = (R_bunchsize * (W_bunchsize * (T_bunchsize * (NTHC_INT * V_bunchsize))))
    _M11_size        = (R_bunchsize * (NTHC_INT * (W_bunchsize * (T_bunchsize * V_bunchsize))))
    _M12_size        = (NVIR * (R_bunchsize * (W_bunchsize * (T_bunchsize * V_bunchsize))))
    _M14_size        = (NTHC_INT * (R_bunchsize * (W_bunchsize * T_bunchsize)))
    _M16_size        = (NVIR * (W_bunchsize * (T_bunchsize * R_bunchsize)))
    _M17_perm_size   = (T_bunchsize * (R_bunchsize * (NVIR * W_bunchsize)))
    _M20_perm_size   = (NTHC_INT * (T_bunchsize * (R_bunchsize * W_bunchsize)))
    _M5_size         = (W_bunchsize * (T_bunchsize * (V_bunchsize * NVIR)))
    _M9_size         = (R_bunchsize * (W_bunchsize * (T_bunchsize * (NTHC_INT * V_bunchsize))))
    _M10_size        = (NTHC_INT * (R_bunchsize * (W_bunchsize * (T_bunchsize * V_bunchsize))))
    _M11_perm_size   = (R_bunchsize * (NTHC_INT * (W_bunchsize * (T_bunchsize * V_bunchsize))))
    _INPUT_18_sliced_size = (NVIR * N_LAPLACE)
    _INPUT_5_sliced_size = (NTHC_INT * NTHC_INT)
    _INPUT_22_sliced_size = (NVIR * N_LAPLACE)
    _M20_size        = (NTHC_INT * (T_bunchsize * (R_bunchsize * W_bunchsize)))
    _INPUT_10_sliced_size = (NTHC_INT * NTHC_INT)
    _M13_size        = (NVIR * (R_bunchsize * (W_bunchsize * T_bunchsize)))
    _M15_size        = (W_bunchsize * (T_bunchsize * (R_bunchsize * NTHC_INT)))
    _M17_size        = (T_bunchsize * (R_bunchsize * (NVIR * W_bunchsize)))
    _M18_sliced_size = (NTHC_INT * (R_bunchsize * W_bunchsize))
    _M19_size        = (T_bunchsize * (R_bunchsize * (W_bunchsize * NTHC_INT)))
    # determine the size of each bucket
    # bucket 0
    bucked_0_size    = max(bucked_0_size, _M2_size)
    # bucket 1
    bucked_1_size    = max(bucked_1_size, _M0_size)
    bucked_1_size    = max(bucked_1_size, _M3_size)
    # bucket 2
    bucked_2_size    = max(bucked_2_size, _M7_size)
    # bucket 3
    bucked_3_size    = max(bucked_3_size, _M1_size)
    bucked_3_size    = max(bucked_3_size, _INPUT_19_sliced_size)
    bucked_3_size    = max(bucked_3_size, _M6_size)
    # bucket 4
    bucked_4_size    = max(bucked_4_size, _M18_size)
    # bucket 5
    bucked_5_size    = max(bucked_5_size, _M2_sliced_size)
    bucked_5_size    = max(bucked_5_size, _INPUT_21_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M8_size)
    # bucket 6
    bucked_6_size    = max(bucked_6_size, _M4_size)
    bucked_6_size    = max(bucked_6_size, _M3_sliced_size)
    bucked_6_size    = max(bucked_6_size, _M7_sliced_size)
    bucked_6_size    = max(bucked_6_size, _M9_perm_size)
    bucked_6_size    = max(bucked_6_size, _M11_size)
    bucked_6_size    = max(bucked_6_size, _M12_size)
    bucked_6_size    = max(bucked_6_size, _M14_size)
    bucked_6_size    = max(bucked_6_size, _M16_size)
    bucked_6_size    = max(bucked_6_size, _M17_perm_size)
    bucked_6_size    = max(bucked_6_size, _M20_perm_size)
    # bucket 7
    bucked_7_size    = max(bucked_7_size, _M5_size)
    bucked_7_size    = max(bucked_7_size, _M9_size)
    bucked_7_size    = max(bucked_7_size, _M10_size)
    bucked_7_size    = max(bucked_7_size, _M11_perm_size)
    bucked_7_size    = max(bucked_7_size, _INPUT_18_sliced_size)
    bucked_7_size    = max(bucked_7_size, _INPUT_5_sliced_size)
    bucked_7_size    = max(bucked_7_size, _INPUT_22_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M20_size)
    bucked_7_size    = max(bucked_7_size, _INPUT_10_sliced_size)
    # bucket 8
    bucked_8_size    = max(bucked_8_size, _M13_size)
    bucked_8_size    = max(bucked_8_size, _M15_size)
    bucked_8_size    = max(bucked_8_size, _M17_size)
    bucked_8_size    = max(bucked_8_size, _M18_sliced_size)
    # bucket 9
    bucked_9_size    = max(bucked_9_size, _M19_size)
    # append each bucket size to the output
    output.append(bucked_0_size)
    output.append(bucked_1_size)
    output.append(bucked_2_size)
    output.append(bucked_3_size)
    output.append(bucked_4_size)
    output.append(bucked_5_size)
    output.append(bucked_6_size)
    output.append(bucked_7_size)
    output.append(bucked_8_size)
    output.append(bucked_9_size)
    return output

def RMP3_XX_1_forloop_R_T_naive(Z           : np.ndarray,
                                X_o         : np.ndarray,
                                X_v         : np.ndarray,
                                tau_o       : np.ndarray,
                                tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    t1 = (logger.process_clock(), logger.perf_counter())
    _M2              = np.einsum("iT,iV->TVi"    , _INPUT_11       , _INPUT_15       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M0              = np.einsum("jR,jV->RVj"    , _INPUT_6        , _INPUT_16       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.einsum("jQ,RVj->QRV"   , _INPUT_3        , _M0             )
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M3              = np.einsum("aT,aV->TVa"    , _INPUT_12       , _INPUT_17       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M1              = np.einsum("kR,kW->RWk"    , _INPUT_7        , _INPUT_20       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.einsum("kU,RWk->URW"   , _INPUT_13       , _M1             )
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M4              = np.einsum("iW,TVi->WTVi"  , _INPUT_19       , _M2             )
    del _M2         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.einsum("iP,WTVi->PWTV" , _INPUT_1        , _M4             )
    del _M4         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M5              = np.einsum("aW,TVa->WTVa"  , _INPUT_21       , _M3             )
    del _M3         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.einsum("aQ,WTVa->QWTV" , _INPUT_4        , _M5             )
    del _M5         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9              = np.einsum("QRV,QWTV->RWTQV", _M7             , _M8             )
    del _M7         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9_perm         = np.transpose(_M9             , (0, 1, 2, 4, 3) )
    del _M9         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.einsum("PQ,RWTVQ->PRWTV", _INPUT_0        , _M9_perm        )
    del _M9_perm    
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11             = np.einsum("PWTV,PRWTV->RPWTV", _M6             , _M10            )
    del _M6         
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11_perm        = np.transpose(_M11            , (0, 2, 3, 4, 1) )
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.einsum("bP,RWTVP->bRWTV", _INPUT_2        , _M11_perm       )
    del _M11_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M13             = np.einsum("bV,bRWTV->bRWT", _INPUT_18       , _M12            )
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.einsum("bS,bRWT->SRWT" , _INPUT_8        , _M13            )
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.einsum("RS,SRWT->WTRS" , _INPUT_5        , _M14            )
    del _M14        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.einsum("cS,WTRS->cWTR" , _INPUT_9        , _M15            )
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.einsum("cW,cWTR->TRcW" , _INPUT_22       , _M16            )
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17_perm        = np.transpose(_M17            , (0, 1, 3, 2)    )
    del _M17        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.einsum("cU,TRWc->UTRW" , _INPUT_14       , _M17_perm       )
    del _M17_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20_perm        = np.transpose(_M20            , (1, 2, 3, 0)    )
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M19             = np.einsum("TU,URW->TRWU"  , _INPUT_10       , _M18            )
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 25")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M21             = np.einsum("TRWU,TRWU->"   , _M19            , _M20_perm       )
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 26")
    return _M21

def RMP3_XX_1_forloop_R_T(Z           : np.ndarray,
                          X_o         : np.ndarray,
                          X_v         : np.ndarray,
                          tau_o       : np.ndarray,
                          tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # step 0 iT,iV->TVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_11.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_11.shape[0]),
                                 ctypes.c_int(_INPUT_11.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    # step 1 jR,jV->RVj 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_6.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_6.shape[0]),
                                 ctypes.c_int(_INPUT_6.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    # step 2 jQ,RVj->QRV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M0.shape[0]
    _size_dim_1      = _size_dim_1 * _M0.shape[1]
    _M0_reshaped = _M0.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M7.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped.T, _M0_reshaped.T, c=_M7_reshaped)
    _M7          = _M7_reshaped.reshape(*shape_backup)
    del _M0         
    del _M0_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    # step 3 aT,aV->TVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_12.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_12.shape[0]),
                                 ctypes.c_int(_INPUT_12.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    # step 4 kR,kW->RWk 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_7.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_7.shape[0]),
                                 ctypes.c_int(_INPUT_7.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    # step 5 kU,RWk->URW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_13_reshaped.T, _M1_reshaped.T, c=_M18_reshaped)
    _M18         = _M18_reshaped.reshape(*shape_backup)
    del _M1         
    del _M1_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    # step 6 iW,TVi->WTVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M4              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19.ctypes.data),
                                   ctypes.c_void_p(_M2.ctypes.data),
                                   ctypes.c_void_p(_M4.ctypes.data),
                                   ctypes.c_int(_INPUT_19.shape[0]),
                                   ctypes.c_int(_INPUT_19.shape[1]),
                                   ctypes.c_int(_M2.shape[0]),
                                   ctypes.c_int(_M2.shape[1]))
    del _M2         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    # step 7 iP,WTVi->PWTV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_1.shape[0]
    _INPUT_1_reshaped = _INPUT_1.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M4.shape[0]
    _size_dim_1      = _size_dim_1 * _M4.shape[1]
    _size_dim_1      = _size_dim_1 * _M4.shape[2]
    _M4_reshaped = _M4.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_1_reshaped.T, _M4_reshaped.T, c=_M6_reshaped)
    _M6          = _M6_reshaped.reshape(*shape_backup)
    del _M4         
    del _M4_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    # step 8 aW,TVa->WTVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M5              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_21.ctypes.data),
                                   ctypes.c_void_p(_M3.ctypes.data),
                                   ctypes.c_void_p(_M5.ctypes.data),
                                   ctypes.c_int(_INPUT_21.shape[0]),
                                   ctypes.c_int(_INPUT_21.shape[1]),
                                   ctypes.c_int(_M3.shape[0]),
                                   ctypes.c_int(_M3.shape[1]))
    del _M3         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    # step 9 aQ,WTVa->QWTV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M5.shape[0]
    _size_dim_1      = _size_dim_1 * _M5.shape[1]
    _size_dim_1      = _size_dim_1 * _M5.shape[2]
    _M5_reshaped = _M5.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M8.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M8.shape[0]
    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_4_reshaped.T, _M5_reshaped.T, c=_M8_reshaped)
    _M8          = _M8_reshaped.reshape(*shape_backup)
    del _M5         
    del _M5_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    # step 10 QRV,QWTV->RWTQV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_0342_13402_wob = getattr(libpbc, "fn_contraction_012_0342_13402_wob", None)
    assert fn_contraction_012_0342_13402_wob is not None
    _M9              = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_012_0342_13402_wob(ctypes.c_void_p(_M7.ctypes.data),
                                      ctypes.c_void_p(_M8.ctypes.data),
                                      ctypes.c_void_p(_M9.ctypes.data),
                                      ctypes.c_int(_M7.shape[0]),
                                      ctypes.c_int(_M7.shape[1]),
                                      ctypes.c_int(_M7.shape[2]),
                                      ctypes.c_int(_M8.shape[1]),
                                      ctypes.c_int(_M8.shape[2]))
    del _M7         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    # step 11 RWTQV->RWTVQ 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_01243_wob = getattr(libpbc, "fn_permutation_01234_01243_wob", None)
    assert fn_permutation_01234_01243_wob is not None
    _M9_perm         = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_01243_wob(ctypes.c_void_p(_M9.ctypes.data),
                                   ctypes.c_void_p(_M9_perm.ctypes.data),
                                   ctypes.c_int(_M9.shape[0]),
                                   ctypes.c_int(_M9.shape[1]),
                                   ctypes.c_int(_M9.shape[2]),
                                   ctypes.c_int(_M9.shape[3]),
                                   ctypes.c_int(_M9.shape[4]))
    del _M9         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    # step 12 PQ,RWTVQ->PRWTV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_0.shape[0]
    _INPUT_0_reshaped = _INPUT_0.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M9_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M9_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M9_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M9_perm.shape[3]
    _M9_perm_reshaped = _M9_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_0_reshaped, _M9_perm_reshaped.T, c=_M10_reshaped)
    _M10         = _M10_reshaped.reshape(*shape_backup)
    del _M9_perm    
    del _M9_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    # step 13 PWTV,PRWTV->RPWTV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_0123_04123_40123_wob = getattr(libpbc, "fn_contraction_0123_04123_40123_wob", None)
    assert fn_contraction_0123_04123_40123_wob is not None
    _M11             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_0123_04123_40123_wob(ctypes.c_void_p(_M6.ctypes.data),
                                        ctypes.c_void_p(_M10.ctypes.data),
                                        ctypes.c_void_p(_M11.ctypes.data),
                                        ctypes.c_int(_M6.shape[0]),
                                        ctypes.c_int(_M6.shape[1]),
                                        ctypes.c_int(_M6.shape[2]),
                                        ctypes.c_int(_M6.shape[3]),
                                        ctypes.c_int(_M10.shape[1]))
    del _M6         
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    # step 14 RPWTV->RWTVP 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_02341_wob = getattr(libpbc, "fn_permutation_01234_02341_wob", None)
    assert fn_permutation_01234_02341_wob is not None
    _M11_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_02341_wob(ctypes.c_void_p(_M11.ctypes.data),
                                   ctypes.c_void_p(_M11_perm.ctypes.data),
                                   ctypes.c_int(_M11.shape[0]),
                                   ctypes.c_int(_M11.shape[1]),
                                   ctypes.c_int(_M11.shape[2]),
                                   ctypes.c_int(_M11.shape[3]),
                                   ctypes.c_int(_M11.shape[4]))
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    # step 15 bP,RWTVP->bRWTV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.ndarray((NVIR, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_2.shape[0]
    _INPUT_2_reshaped = _INPUT_2.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[3]
    _M11_perm_reshaped = _M11_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M12.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M12.shape[0]
    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_2_reshaped, _M11_perm_reshaped.T, c=_M12_reshaped)
    _M12         = _M12_reshaped.reshape(*shape_backup)
    del _M11_perm   
    del _M11_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    # step 16 bV,bRWTV->bRWT 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02341_0234_wob = getattr(libpbc, "fn_contraction_01_02341_0234_wob", None)
    assert fn_contraction_01_02341_0234_wob is not None
    _M13             = np.ndarray((NVIR, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_02341_0234_wob(ctypes.c_void_p(_INPUT_18.ctypes.data),
                                     ctypes.c_void_p(_M12.ctypes.data),
                                     ctypes.c_void_p(_M13.ctypes.data),
                                     ctypes.c_int(_INPUT_18.shape[0]),
                                     ctypes.c_int(_INPUT_18.shape[1]),
                                     ctypes.c_int(_M12.shape[1]),
                                     ctypes.c_int(_M12.shape[2]),
                                     ctypes.c_int(_M12.shape[3]))
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    # step 17 bS,bRWT->SRWT 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_8.shape[0]
    _INPUT_8_reshaped = _INPUT_8.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M13.shape[0]
    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_8_reshaped.T, _M13_reshaped, c=_M14_reshaped)
    _M14         = _M14_reshaped.reshape(*shape_backup)
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    # step 18 RS,SRWT->WTRS 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_1023_2301_wob = getattr(libpbc, "fn_contraction_01_1023_2301_wob", None)
    assert fn_contraction_01_1023_2301_wob is not None
    _M15             = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, NTHC_INT), dtype=np.float64)
    fn_contraction_01_1023_2301_wob(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                    ctypes.c_void_p(_M14.ctypes.data),
                                    ctypes.c_void_p(_M15.ctypes.data),
                                    ctypes.c_int(_INPUT_5.shape[0]),
                                    ctypes.c_int(_INPUT_5.shape[1]),
                                    ctypes.c_int(_M14.shape[2]),
                                    ctypes.c_int(_M14.shape[3]))
    del _M14        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    # step 19 cS,WTRS->cWTR 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.ndarray((NVIR, N_LAPLACE, NTHC_INT, NTHC_INT), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_9.shape[0]
    _INPUT_9_reshaped = _INPUT_9.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M15.shape[0]
    _size_dim_1      = _size_dim_1 * _M15.shape[1]
    _size_dim_1      = _size_dim_1 * _M15.shape[2]
    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M16.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M16.shape[0]
    _M16_reshaped = _M16.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_9_reshaped, _M15_reshaped.T, c=_M16_reshaped)
    _M16         = _M16_reshaped.reshape(*shape_backup)
    del _M15        
    del _M15_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    # step 20 cW,cWTR->TRcW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_0123_2301_wob = getattr(libpbc, "fn_contraction_01_0123_2301_wob", None)
    assert fn_contraction_01_0123_2301_wob is not None
    _M17             = np.ndarray((NTHC_INT, NTHC_INT, NVIR, N_LAPLACE), dtype=np.float64)
    fn_contraction_01_0123_2301_wob(ctypes.c_void_p(_INPUT_22.ctypes.data),
                                    ctypes.c_void_p(_M16.ctypes.data),
                                    ctypes.c_void_p(_M17.ctypes.data),
                                    ctypes.c_int(_INPUT_22.shape[0]),
                                    ctypes.c_int(_INPUT_22.shape[1]),
                                    ctypes.c_int(_M16.shape[2]),
                                    ctypes.c_int(_M16.shape[3]))
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    # step 21 TRcW->TRWc 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_0123_0132_wob = getattr(libpbc, "fn_permutation_0123_0132_wob", None)
    assert fn_permutation_0123_0132_wob is not None
    _M17_perm        = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_permutation_0123_0132_wob(ctypes.c_void_p(_M17.ctypes.data),
                                 ctypes.c_void_p(_M17_perm.ctypes.data),
                                 ctypes.c_int(_M17.shape[0]),
                                 ctypes.c_int(_M17.shape[1]),
                                 ctypes.c_int(_M17.shape[2]),
                                 ctypes.c_int(_M17.shape[3]))
    del _M17        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    # step 22 cU,TRWc->UTRW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.ndarray((NTHC_INT, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M17_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M17_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M17_perm.shape[2]
    _M17_perm_reshaped = _M17_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_14_reshaped.T, _M17_perm_reshaped.T, c=_M20_reshaped)
    _M20         = _M20_reshaped.reshape(*shape_backup)
    del _M17_perm   
    del _M17_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    # step 23 UTRW->TRWU 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_0123_1230_wob = getattr(libpbc, "fn_permutation_0123_1230_wob", None)
    assert fn_permutation_0123_1230_wob is not None
    _M20_perm        = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_0123_1230_wob(ctypes.c_void_p(_M20.ctypes.data),
                                 ctypes.c_void_p(_M20_perm.ctypes.data),
                                 ctypes.c_int(_M20.shape[0]),
                                 ctypes.c_int(_M20.shape[1]),
                                 ctypes.c_int(_M20.shape[2]),
                                 ctypes.c_int(_M20.shape[3]))
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    # step 24 TU,URW->TRWU 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    _M19             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_10.ctypes.data),
                                   ctypes.c_void_p(_M18.ctypes.data),
                                   ctypes.c_void_p(_M19.ctypes.data),
                                   ctypes.c_int(_INPUT_10.shape[0]),
                                   ctypes.c_int(_INPUT_10.shape[1]),
                                   ctypes.c_int(_M18.shape[1]),
                                   ctypes.c_int(_M18.shape[2]))
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 25")
    # step 25 TRWU,TRWU-> 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    _M21             = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20_perm.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(_M21))
    _M21 = _M21.value
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 26")
    return _M21

def RMP3_XX_1_forloop_R_T_forloop_T_R(Z           : np.ndarray,
                                      X_o         : np.ndarray,
                                      X_v         : np.ndarray,
                                      tau_o       : np.ndarray,
                                      tau_v       : np.ndarray,
                                      buffer      : np.ndarray,
                                      T_bunchsize = 8,
                                      R_bunchsize = 8,
                                      V_bunchsize = 1,
                                      W_bunchsize = 1,
                                      use_mpi = False):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # fetch function pointers
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    fn_permutation_0123_0132_wob = getattr(libpbc, "fn_permutation_0123_0132_wob", None)
    assert fn_permutation_0123_0132_wob is not None
    fn_contraction_01_0123_2301_wob = getattr(libpbc, "fn_contraction_01_0123_2301_wob", None)
    assert fn_contraction_01_0123_2301_wob is not None
    fn_contraction_01_02341_0234_wob = getattr(libpbc, "fn_contraction_01_02341_0234_wob", None)
    assert fn_contraction_01_02341_0234_wob is not None
    fn_slice_3_1_2 = getattr(libpbc, "fn_slice_3_1_2", None)
    assert fn_slice_3_1_2 is not None
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    fn_slice_2_1 = getattr(libpbc, "fn_slice_2_1", None)
    assert fn_slice_2_1 is not None
    fn_slice_2_0 = getattr(libpbc, "fn_slice_2_0", None)
    assert fn_slice_2_0 is not None
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    fn_slice_3_0_1 = getattr(libpbc, "fn_slice_3_0_1", None)
    assert fn_slice_3_0_1 is not None
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    fn_contraction_01_1023_2301_wob = getattr(libpbc, "fn_contraction_01_1023_2301_wob", None)
    assert fn_contraction_01_1023_2301_wob is not None
    fn_contraction_0123_04123_40123_wob = getattr(libpbc, "fn_contraction_0123_04123_40123_wob", None)
    assert fn_contraction_0123_04123_40123_wob is not None
    fn_contraction_012_0342_13402_wob = getattr(libpbc, "fn_contraction_012_0342_13402_wob", None)
    assert fn_contraction_012_0342_13402_wob is not None
    fn_permutation_01234_02341_wob = getattr(libpbc, "fn_permutation_01234_02341_wob", None)
    assert fn_permutation_01234_02341_wob is not None
    fn_permutation_0123_1230_wob = getattr(libpbc, "fn_permutation_0123_1230_wob", None)
    assert fn_permutation_0123_1230_wob is not None
    fn_permutation_01234_01243_wob = getattr(libpbc, "fn_permutation_01234_01243_wob", None)
    assert fn_permutation_01234_01243_wob is not None
    if use_mpi:
        bunchsize = NTHC_INT//comm_size + 1
        T_begin = rank*bunchsize
        T_end = (rank+1)*bunchsize
        T_begin          = min(T_begin, NTHC_INT)
        T_end            = min(T_end, NTHC_INT)
    else:
        T_begin          = 0               
        T_end            = NTHC_INT        
    # preallocate buffer
    bucket_size      = RMP3_XX_1_forloop_R_T_determine_bucket_size_forloop(NVIR = NVIR,
                                                                           NOCC = NOCC,
                                                                           N_LAPLACE = N_LAPLACE,
                                                                           NTHC_INT = NTHC_INT,
                                                                           T_bunchsize = T_bunchsize,
                                                                           V_bunchsize = V_bunchsize,
                                                                           W_bunchsize = W_bunchsize,
                                                                           R_bunchsize = R_bunchsize)
    bufsize_now      = buffer.size     
    _itemsize        = buffer.itemsize 
    offset_now       = 0               
    offset_0         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[0])
    offset_1         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[1])
    offset_2         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[2])
    offset_3         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[3])
    offset_4         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[4])
    offset_5         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[5])
    offset_6         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[6])
    offset_7         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[7])
    offset_8         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[8])
    offset_9         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[9])
    bufsize          = offset_now      
    if (bufsize > bufsize_now):
        buffer           = np.ndarray((bufsize), dtype=np.float64)
    # step   0 start for loop with indices ()
    # step   1 allocate   _M21
    _M21             = 0.0             
    # step   2 iT,iV->TVi
    offset_now       = offset_0        
    _M2_offset       = offset_now      
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M2_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_11.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_11.shape[0]),
                                 ctypes.c_int(_INPUT_11.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    # step   3 jR,jV->RVj
    offset_now       = offset_1        
    _M0_offset       = offset_now      
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M0_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_6.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_6.shape[0]),
                                 ctypes.c_int(_INPUT_6.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    # step   4 jQ,RVj->QRV
    offset_now       = offset_2        
    _M7_offset       = offset_now      
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M7_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M0.shape[0]
    _size_dim_1      = _size_dim_1 * _M0.shape[1]
    _M0_reshaped = _M0.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M7.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped.T, _M0_reshaped.T, c=_M7_reshaped)
    _M7              = _M7_reshaped.reshape(*shape_backup)
    # step   5 aT,aV->TVa
    offset_now       = offset_1        
    _M3_offset       = offset_now      
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M3_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_12.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_12.shape[0]),
                                 ctypes.c_int(_INPUT_12.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    # step   6 kR,kW->RWk
    offset_now       = offset_3        
    _M1_offset       = offset_now      
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M1_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_7.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_7.shape[0]),
                                 ctypes.c_int(_INPUT_7.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    # step   7 kU,RWk->URW
    offset_now       = offset_4        
    _M18_offset      = offset_now      
    _M18             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M18_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_13_reshaped.T, _M1_reshaped.T, c=_M18_reshaped)
    _M18             = _M18_reshaped.reshape(*shape_backup)
    # step   8 start for loop with indices ('T',)
    for T_0, T_1 in lib.prange(T_begin,T_end,T_bunchsize):
        # step   9 start for loop with indices ('T', 'V')
        for V_0, V_1 in lib.prange(0,N_LAPLACE,V_bunchsize):
            # step  10 start for loop with indices ('T', 'V', 'W')
            for W_0, W_1 in lib.prange(0,N_LAPLACE,W_bunchsize):
                # step  11 slice _INPUT_19 with indices ['W']
                _INPUT_19_sliced_offset = offset_3        
                _INPUT_19_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_19_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_19.ctypes.data),
                             ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_19.shape[0]),
                             ctypes.c_int(_INPUT_19.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  12 slice _M2 with indices ['T', 'V']
                _M2_sliced_offset = offset_5        
                _M2_sliced       = np.ndarray(((T_1-T_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M2_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M2.ctypes.data),
                               ctypes.c_void_p(_M2_sliced.ctypes.data),
                               ctypes.c_int(_M2.shape[0]),
                               ctypes.c_int(_M2.shape[1]),
                               ctypes.c_int(_M2.shape[2]),
                               ctypes.c_int(T_0),
                               ctypes.c_int(T_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  13 iW,TVi->WTVi
                offset_now       = offset_6        
                _M4_offset       = offset_now      
                _M4              = np.ndarray(((W_1-W_0), (T_1-T_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M4_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                                               ctypes.c_void_p(_M2_sliced.ctypes.data),
                                               ctypes.c_void_p(_M4.ctypes.data),
                                               ctypes.c_int(_INPUT_19_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_19_sliced.shape[1]),
                                               ctypes.c_int(_M2_sliced.shape[0]),
                                               ctypes.c_int(_M2_sliced.shape[1]))
                # step  14 iP,WTVi->PWTV
                offset_now       = offset_3        
                _M6_offset       = offset_now      
                _M6              = np.ndarray((NTHC_INT, (W_1-W_0), (T_1-T_0), (V_1-V_0)), buffer = buffer, offset = _M6_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_1.shape[0]
                _INPUT_1_reshaped = _INPUT_1.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M4.shape[0]
                _size_dim_1      = _size_dim_1 * _M4.shape[1]
                _size_dim_1      = _size_dim_1 * _M4.shape[2]
                _M4_reshaped = _M4.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M6.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M6.shape[0]
                _M6_reshaped = _M6.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_1_reshaped.T, _M4_reshaped.T, c=_M6_reshaped)
                _M6              = _M6_reshaped.reshape(*shape_backup)
                # step  15 slice _INPUT_21 with indices ['W']
                _INPUT_21_sliced_offset = offset_5        
                _INPUT_21_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_21_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_21.ctypes.data),
                             ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_21.shape[0]),
                             ctypes.c_int(_INPUT_21.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  16 slice _M3 with indices ['T', 'V']
                _M3_sliced_offset = offset_6        
                _M3_sliced       = np.ndarray(((T_1-T_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M3_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M3.ctypes.data),
                               ctypes.c_void_p(_M3_sliced.ctypes.data),
                               ctypes.c_int(_M3.shape[0]),
                               ctypes.c_int(_M3.shape[1]),
                               ctypes.c_int(_M3.shape[2]),
                               ctypes.c_int(T_0),
                               ctypes.c_int(T_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  17 aW,TVa->WTVa
                offset_now       = offset_7        
                _M5_offset       = offset_now      
                _M5              = np.ndarray(((W_1-W_0), (T_1-T_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M5_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                                               ctypes.c_void_p(_M3_sliced.ctypes.data),
                                               ctypes.c_void_p(_M5.ctypes.data),
                                               ctypes.c_int(_INPUT_21_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_21_sliced.shape[1]),
                                               ctypes.c_int(_M3_sliced.shape[0]),
                                               ctypes.c_int(_M3_sliced.shape[1]))
                # step  18 aQ,WTVa->QWTV
                offset_now       = offset_5        
                _M8_offset       = offset_now      
                _M8              = np.ndarray((NTHC_INT, (W_1-W_0), (T_1-T_0), (V_1-V_0)), buffer = buffer, offset = _M8_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
                _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M5.shape[0]
                _size_dim_1      = _size_dim_1 * _M5.shape[1]
                _size_dim_1      = _size_dim_1 * _M5.shape[2]
                _M5_reshaped = _M5.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M8.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M8.shape[0]
                _M8_reshaped = _M8.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_4_reshaped.T, _M5_reshaped.T, c=_M8_reshaped)
                _M8              = _M8_reshaped.reshape(*shape_backup)
                # step  19 start for loop with indices ('T', 'V', 'W', 'R')
                for R_0, R_1 in lib.prange(0,NTHC_INT,R_bunchsize):
                    # step  20 slice _M7 with indices ['R', 'V']
                    _M7_sliced_offset = offset_6        
                    _M7_sliced       = np.ndarray((NTHC_INT, (R_1-R_0), (V_1-V_0)), buffer = buffer, offset = _M7_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M7.ctypes.data),
                                   ctypes.c_void_p(_M7_sliced.ctypes.data),
                                   ctypes.c_int(_M7.shape[0]),
                                   ctypes.c_int(_M7.shape[1]),
                                   ctypes.c_int(_M7.shape[2]),
                                   ctypes.c_int(R_0),
                                   ctypes.c_int(R_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  21 QRV,QWTV->RWTQV
                    offset_now       = offset_7        
                    _M9_offset       = offset_now      
                    _M9              = np.ndarray(((R_1-R_0), (W_1-W_0), (T_1-T_0), NTHC_INT, (V_1-V_0)), buffer = buffer, offset = _M9_offset)
                    fn_contraction_012_0342_13402_wob(ctypes.c_void_p(_M7_sliced.ctypes.data),
                                                      ctypes.c_void_p(_M8.ctypes.data),
                                                      ctypes.c_void_p(_M9.ctypes.data),
                                                      ctypes.c_int(_M7_sliced.shape[0]),
                                                      ctypes.c_int(_M7_sliced.shape[1]),
                                                      ctypes.c_int(_M7_sliced.shape[2]),
                                                      ctypes.c_int(_M8.shape[1]),
                                                      ctypes.c_int(_M8.shape[2]))
                    # step  22 RWTQV->RWTVQ
                    _M9_perm_offset  = offset_6        
                    _M9_perm         = np.ndarray(((R_1-R_0), (W_1-W_0), (T_1-T_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M9_perm_offset)
                    fn_permutation_01234_01243_wob(ctypes.c_void_p(_M9.ctypes.data),
                                                   ctypes.c_void_p(_M9_perm.ctypes.data),
                                                   ctypes.c_int((R_1-R_0)),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((T_1-T_0)),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  23 PQ,RWTVQ->PRWTV
                    offset_now       = offset_7        
                    _M10_offset      = offset_now      
                    _M10             = np.ndarray((NTHC_INT, (R_1-R_0), (W_1-W_0), (T_1-T_0), (V_1-V_0)), buffer = buffer, offset = _M10_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_0.shape[0]
                    _INPUT_0_reshaped = _INPUT_0.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M9_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M9_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M9_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M9_perm.shape[3]
                    _M9_perm_reshaped = _M9_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M10.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M10.shape[0]
                    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_0_reshaped, _M9_perm_reshaped.T, c=_M10_reshaped)
                    _M10             = _M10_reshaped.reshape(*shape_backup)
                    # step  24 PWTV,PRWTV->RPWTV
                    offset_now       = offset_6        
                    _M11_offset      = offset_now      
                    _M11             = np.ndarray(((R_1-R_0), NTHC_INT, (W_1-W_0), (T_1-T_0), (V_1-V_0)), buffer = buffer, offset = _M11_offset)
                    fn_contraction_0123_04123_40123_wob(ctypes.c_void_p(_M6.ctypes.data),
                                                        ctypes.c_void_p(_M10.ctypes.data),
                                                        ctypes.c_void_p(_M11.ctypes.data),
                                                        ctypes.c_int(_M6.shape[0]),
                                                        ctypes.c_int(_M6.shape[1]),
                                                        ctypes.c_int(_M6.shape[2]),
                                                        ctypes.c_int(_M6.shape[3]),
                                                        ctypes.c_int(_M10.shape[1]))
                    # step  25 RPWTV->RWTVP
                    _M11_perm_offset = offset_7        
                    _M11_perm        = np.ndarray(((R_1-R_0), (W_1-W_0), (T_1-T_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M11_perm_offset)
                    fn_permutation_01234_02341_wob(ctypes.c_void_p(_M11.ctypes.data),
                                                   ctypes.c_void_p(_M11_perm.ctypes.data),
                                                   ctypes.c_int((R_1-R_0)),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((T_1-T_0)),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  26 bP,RWTVP->bRWTV
                    offset_now       = offset_6        
                    _M12_offset      = offset_now      
                    _M12             = np.ndarray((NVIR, (R_1-R_0), (W_1-W_0), (T_1-T_0), (V_1-V_0)), buffer = buffer, offset = _M12_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_2.shape[0]
                    _INPUT_2_reshaped = _INPUT_2.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[3]
                    _M11_perm_reshaped = _M11_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M12.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M12.shape[0]
                    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_2_reshaped, _M11_perm_reshaped.T, c=_M12_reshaped)
                    _M12             = _M12_reshaped.reshape(*shape_backup)
                    # step  27 slice _INPUT_18 with indices ['V']
                    _INPUT_18_sliced_offset = offset_7        
                    _INPUT_18_sliced = np.ndarray((NVIR, (V_1-V_0)), buffer = buffer, offset = _INPUT_18_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_18.shape[0]),
                                 ctypes.c_int(_INPUT_18.shape[1]),
                                 ctypes.c_int(V_0),
                                 ctypes.c_int(V_1))
                    # step  28 bV,bRWTV->bRWT
                    offset_now       = offset_8        
                    _M13_offset      = offset_now      
                    _M13             = np.ndarray((NVIR, (R_1-R_0), (W_1-W_0), (T_1-T_0)), buffer = buffer, offset = _M13_offset)
                    fn_contraction_01_02341_0234_wob(ctypes.c_void_p(_INPUT_18_sliced.ctypes.data),
                                                     ctypes.c_void_p(_M12.ctypes.data),
                                                     ctypes.c_void_p(_M13.ctypes.data),
                                                     ctypes.c_int(_INPUT_18_sliced.shape[0]),
                                                     ctypes.c_int(_INPUT_18_sliced.shape[1]),
                                                     ctypes.c_int(_M12.shape[1]),
                                                     ctypes.c_int(_M12.shape[2]),
                                                     ctypes.c_int(_M12.shape[3]))
                    # step  29 bS,bRWT->SRWT
                    offset_now       = offset_6        
                    _M14_offset      = offset_now      
                    _M14             = np.ndarray((NTHC_INT, (R_1-R_0), (W_1-W_0), (T_1-T_0)), buffer = buffer, offset = _M14_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_8.shape[0]
                    _INPUT_8_reshaped = _INPUT_8.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M13.shape[0]
                    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M14.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M14.shape[0]
                    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_8_reshaped.T, _M13_reshaped, c=_M14_reshaped)
                    _M14             = _M14_reshaped.reshape(*shape_backup)
                    # step  30 slice _INPUT_5 with indices ['R']
                    _INPUT_5_sliced_offset = offset_7        
                    _INPUT_5_sliced  = np.ndarray(((R_1-R_0), NTHC_INT), buffer = buffer, offset = _INPUT_5_sliced_offset)
                    fn_slice_2_0(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                 ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_5.shape[0]),
                                 ctypes.c_int(_INPUT_5.shape[1]),
                                 ctypes.c_int(R_0),
                                 ctypes.c_int(R_1))
                    # step  31 RS,SRWT->WTRS
                    offset_now       = offset_8        
                    _M15_offset      = offset_now      
                    _M15             = np.ndarray(((W_1-W_0), (T_1-T_0), (R_1-R_0), NTHC_INT), buffer = buffer, offset = _M15_offset)
                    fn_contraction_01_1023_2301_wob(ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                                    ctypes.c_void_p(_M14.ctypes.data),
                                                    ctypes.c_void_p(_M15.ctypes.data),
                                                    ctypes.c_int(_INPUT_5_sliced.shape[0]),
                                                    ctypes.c_int(_INPUT_5_sliced.shape[1]),
                                                    ctypes.c_int(_M14.shape[2]),
                                                    ctypes.c_int(_M14.shape[3]))
                    # step  32 cS,WTRS->cWTR
                    offset_now       = offset_6        
                    _M16_offset      = offset_now      
                    _M16             = np.ndarray((NVIR, (W_1-W_0), (T_1-T_0), (R_1-R_0)), buffer = buffer, offset = _M16_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_9.shape[0]
                    _INPUT_9_reshaped = _INPUT_9.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M15.shape[0]
                    _size_dim_1      = _size_dim_1 * _M15.shape[1]
                    _size_dim_1      = _size_dim_1 * _M15.shape[2]
                    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M16.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M16.shape[0]
                    _M16_reshaped = _M16.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_9_reshaped, _M15_reshaped.T, c=_M16_reshaped)
                    _M16             = _M16_reshaped.reshape(*shape_backup)
                    # step  33 slice _INPUT_22 with indices ['W']
                    _INPUT_22_sliced_offset = offset_7        
                    _INPUT_22_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_22_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_22.shape[0]),
                                 ctypes.c_int(_INPUT_22.shape[1]),
                                 ctypes.c_int(W_0),
                                 ctypes.c_int(W_1))
                    # step  34 cW,cWTR->TRcW
                    offset_now       = offset_8        
                    _M17_offset      = offset_now      
                    _M17             = np.ndarray(((T_1-T_0), (R_1-R_0), NVIR, (W_1-W_0)), buffer = buffer, offset = _M17_offset)
                    fn_contraction_01_0123_2301_wob(ctypes.c_void_p(_INPUT_22_sliced.ctypes.data),
                                                    ctypes.c_void_p(_M16.ctypes.data),
                                                    ctypes.c_void_p(_M17.ctypes.data),
                                                    ctypes.c_int(_INPUT_22_sliced.shape[0]),
                                                    ctypes.c_int(_INPUT_22_sliced.shape[1]),
                                                    ctypes.c_int(_M16.shape[2]),
                                                    ctypes.c_int(_M16.shape[3]))
                    # step  35 TRcW->TRWc
                    _M17_perm_offset = offset_6        
                    _M17_perm        = np.ndarray(((T_1-T_0), (R_1-R_0), (W_1-W_0), NVIR), buffer = buffer, offset = _M17_perm_offset)
                    fn_permutation_0123_0132_wob(ctypes.c_void_p(_M17.ctypes.data),
                                                 ctypes.c_void_p(_M17_perm.ctypes.data),
                                                 ctypes.c_int((T_1-T_0)),
                                                 ctypes.c_int((R_1-R_0)),
                                                 ctypes.c_int(NVIR),
                                                 ctypes.c_int((W_1-W_0)))
                    # step  36 cU,TRWc->UTRW
                    offset_now       = offset_7        
                    _M20_offset      = offset_now      
                    _M20             = np.ndarray((NTHC_INT, (T_1-T_0), (R_1-R_0), (W_1-W_0)), buffer = buffer, offset = _M20_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
                    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M17_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M17_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M17_perm.shape[2]
                    _M17_perm_reshaped = _M17_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M20.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M20.shape[0]
                    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_14_reshaped.T, _M17_perm_reshaped.T, c=_M20_reshaped)
                    _M20             = _M20_reshaped.reshape(*shape_backup)
                    # step  37 UTRW->TRWU
                    _M20_perm_offset = offset_6        
                    _M20_perm        = np.ndarray(((T_1-T_0), (R_1-R_0), (W_1-W_0), NTHC_INT), buffer = buffer, offset = _M20_perm_offset)
                    fn_permutation_0123_1230_wob(ctypes.c_void_p(_M20.ctypes.data),
                                                 ctypes.c_void_p(_M20_perm.ctypes.data),
                                                 ctypes.c_int(NTHC_INT),
                                                 ctypes.c_int((T_1-T_0)),
                                                 ctypes.c_int((R_1-R_0)),
                                                 ctypes.c_int((W_1-W_0)))
                    # step  38 slice _INPUT_10 with indices ['T']
                    _INPUT_10_sliced_offset = offset_7        
                    _INPUT_10_sliced = np.ndarray(((T_1-T_0), NTHC_INT), buffer = buffer, offset = _INPUT_10_sliced_offset)
                    fn_slice_2_0(ctypes.c_void_p(_INPUT_10.ctypes.data),
                                 ctypes.c_void_p(_INPUT_10_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_10.shape[0]),
                                 ctypes.c_int(_INPUT_10.shape[1]),
                                 ctypes.c_int(T_0),
                                 ctypes.c_int(T_1))
                    # step  39 slice _M18 with indices ['R', 'W']
                    _M18_sliced_offset = offset_8        
                    _M18_sliced      = np.ndarray((NTHC_INT, (R_1-R_0), (W_1-W_0)), buffer = buffer, offset = _M18_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M18.ctypes.data),
                                   ctypes.c_void_p(_M18_sliced.ctypes.data),
                                   ctypes.c_int(_M18.shape[0]),
                                   ctypes.c_int(_M18.shape[1]),
                                   ctypes.c_int(_M18.shape[2]),
                                   ctypes.c_int(R_0),
                                   ctypes.c_int(R_1),
                                   ctypes.c_int(W_0),
                                   ctypes.c_int(W_1))
                    # step  40 TU,URW->TRWU
                    offset_now       = offset_9        
                    _M19_offset      = offset_now      
                    _M19             = np.ndarray(((T_1-T_0), (R_1-R_0), (W_1-W_0), NTHC_INT), buffer = buffer, offset = _M19_offset)
                    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_10_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M18_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M19.ctypes.data),
                                                   ctypes.c_int(_INPUT_10_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_10_sliced.shape[1]),
                                                   ctypes.c_int(_M18_sliced.shape[1]),
                                                   ctypes.c_int(_M18_sliced.shape[2]))
                    # step  41 TRWU,TRWU->
                    output_tmp       = ctypes.c_double(0.0)
                    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
                           ctypes.c_void_p(_M20_perm.ctypes.data),
                           ctypes.c_int(_M19.size),
                           ctypes.pointer(output_tmp))
                    output_tmp = output_tmp.value
                    _M21 += output_tmp
                # step  42 end   for loop with indices ('T', 'V', 'W', 'R')
            # step  43 end   for loop with indices ('T', 'V', 'W')
        # step  44 end   for loop with indices ('T', 'V')
    # step  45 end   for loop with indices ('T',)
    # clean the final forloop
    # MPI finalize
    if use_mpi:
        _M21 = reduce(_M21, root=0)
        _M21 = bcast(_M21, root=0)
    return _M21

def RMP3_XX_1_forloop_S_T_determine_bucket_size_forloop(NVIR        : int,
                                                        NOCC        : int,
                                                        N_LAPLACE   : int,
                                                        NTHC_INT    : int,
                                                        T_bunchsize = 8,
                                                        S_bunchsize = 8,
                                                        V_bunchsize = 1,
                                                        W_bunchsize = 1):
    # init
    output = []     
    bucked_0_size    = 0               
    bucked_1_size    = 0               
    bucked_2_size    = 0               
    bucked_3_size    = 0               
    bucked_4_size    = 0               
    bucked_5_size    = 0               
    bucked_6_size    = 0               
    bucked_7_size    = 0               
    bucked_8_size    = 0               
    bucked_9_size    = 0               
    bucked_10_size   = 0               
    # assign the size of each tensor
    _INPUT_10_perm_size = (NTHC_INT * NTHC_INT)
    _M1_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M19_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M20_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M3_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M0_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M2_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M7_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _INPUT_21_sliced_size = (NVIR * N_LAPLACE)
    _M10_size        = (NTHC_INT * (W_bunchsize * (T_bunchsize * V_bunchsize)))
    _M3_sliced_size  = (T_bunchsize * (V_bunchsize * NVIR))
    _INPUT_19_sliced_size = (NOCC * N_LAPLACE)
    _M6_size         = (NTHC_INT * (W_bunchsize * (T_bunchsize * V_bunchsize)))
    _M5_size         = (W_bunchsize * (T_bunchsize * (V_bunchsize * NVIR)))
    _M2_sliced_size  = (T_bunchsize * (V_bunchsize * NOCC))
    _M7_sliced_size  = (NTHC_INT * (S_bunchsize * V_bunchsize))
    _M8_perm_size    = (W_bunchsize * (T_bunchsize * (S_bunchsize * (NTHC_INT * V_bunchsize))))
    _M11_size        = (S_bunchsize * (NTHC_INT * (W_bunchsize * (T_bunchsize * V_bunchsize))))
    _M12_size        = (NOCC * (S_bunchsize * (W_bunchsize * (T_bunchsize * V_bunchsize))))
    _M14_size        = (NTHC_INT * (S_bunchsize * (W_bunchsize * T_bunchsize)))
    _M15_perm_size   = (W_bunchsize * (T_bunchsize * (NTHC_INT * S_bunchsize)))
    _INPUT_20_sliced_size = (NOCC * N_LAPLACE)
    _M17_perm_size   = (T_bunchsize * (S_bunchsize * (NOCC * W_bunchsize)))
    _INPUT_10_perm_sliced_size = (NTHC_INT * NTHC_INT)
    _M4_size         = (W_bunchsize * (T_bunchsize * (V_bunchsize * NOCC)))
    _M8_size         = (W_bunchsize * (T_bunchsize * (S_bunchsize * (NTHC_INT * V_bunchsize))))
    _M9_size         = (NTHC_INT * (W_bunchsize * (T_bunchsize * (S_bunchsize * V_bunchsize))))
    _M11_perm_size   = (S_bunchsize * (NTHC_INT * (W_bunchsize * (T_bunchsize * V_bunchsize))))
    _INPUT_16_sliced_size = (NOCC * N_LAPLACE)
    _INPUT_5_sliced_size = (NTHC_INT * NTHC_INT)
    _M16_size        = (NOCC * (W_bunchsize * (T_bunchsize * S_bunchsize)))
    _M18_size        = (NTHC_INT * (T_bunchsize * (S_bunchsize * W_bunchsize)))
    _M13_size        = (NOCC * (S_bunchsize * (W_bunchsize * T_bunchsize)))
    _M15_size        = (W_bunchsize * (T_bunchsize * (NTHC_INT * S_bunchsize)))
    _M17_size        = (T_bunchsize * (S_bunchsize * (NOCC * W_bunchsize)))
    _M19_packed_size = (NTHC_INT * (S_bunchsize * W_bunchsize))
    # determine the size of each bucket
    # bucket 0
    bucked_0_size    = max(bucked_0_size, _INPUT_10_perm_size)
    # bucket 1
    bucked_1_size    = max(bucked_1_size, _M1_size)
    bucked_1_size    = max(bucked_1_size, _M19_size)
    # bucket 2
    bucked_2_size    = max(bucked_2_size, _M20_size)
    # bucket 3
    bucked_3_size    = max(bucked_3_size, _M3_size)
    # bucket 4
    bucked_4_size    = max(bucked_4_size, _M0_size)
    bucked_4_size    = max(bucked_4_size, _M2_size)
    # bucket 5
    bucked_5_size    = max(bucked_5_size, _M7_size)
    # bucket 6
    bucked_6_size    = max(bucked_6_size, _INPUT_21_sliced_size)
    bucked_6_size    = max(bucked_6_size, _M10_size)
    # bucket 7
    bucked_7_size    = max(bucked_7_size, _M3_sliced_size)
    bucked_7_size    = max(bucked_7_size, _INPUT_19_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M6_size)
    # bucket 8
    bucked_8_size    = max(bucked_8_size, _M5_size)
    bucked_8_size    = max(bucked_8_size, _M2_sliced_size)
    bucked_8_size    = max(bucked_8_size, _M7_sliced_size)
    bucked_8_size    = max(bucked_8_size, _M8_perm_size)
    bucked_8_size    = max(bucked_8_size, _M11_size)
    bucked_8_size    = max(bucked_8_size, _M12_size)
    bucked_8_size    = max(bucked_8_size, _M14_size)
    bucked_8_size    = max(bucked_8_size, _M15_perm_size)
    bucked_8_size    = max(bucked_8_size, _INPUT_20_sliced_size)
    bucked_8_size    = max(bucked_8_size, _M17_perm_size)
    bucked_8_size    = max(bucked_8_size, _INPUT_10_perm_sliced_size)
    # bucket 9
    bucked_9_size    = max(bucked_9_size, _M4_size)
    bucked_9_size    = max(bucked_9_size, _M8_size)
    bucked_9_size    = max(bucked_9_size, _M9_size)
    bucked_9_size    = max(bucked_9_size, _M11_perm_size)
    bucked_9_size    = max(bucked_9_size, _INPUT_16_sliced_size)
    bucked_9_size    = max(bucked_9_size, _INPUT_5_sliced_size)
    bucked_9_size    = max(bucked_9_size, _M16_size)
    bucked_9_size    = max(bucked_9_size, _M18_size)
    # bucket 10
    bucked_10_size   = max(bucked_10_size, _M13_size)
    bucked_10_size   = max(bucked_10_size, _M15_size)
    bucked_10_size   = max(bucked_10_size, _M17_size)
    bucked_10_size   = max(bucked_10_size, _M19_packed_size)
    # append each bucket size to the output
    output.append(bucked_0_size)
    output.append(bucked_1_size)
    output.append(bucked_2_size)
    output.append(bucked_3_size)
    output.append(bucked_4_size)
    output.append(bucked_5_size)
    output.append(bucked_6_size)
    output.append(bucked_7_size)
    output.append(bucked_8_size)
    output.append(bucked_9_size)
    output.append(bucked_10_size)
    return output

def RMP3_XX_1_forloop_S_T_naive(Z           : np.ndarray,
                                X_o         : np.ndarray,
                                X_v         : np.ndarray,
                                tau_o       : np.ndarray,
                                tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    t1 = (logger.process_clock(), logger.perf_counter())
    _INPUT_10_perm   = np.transpose(_INPUT_10       , (1, 0)          )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M1              = np.einsum("cS,cW->SWc"    , _INPUT_9        , _INPUT_22       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.einsum("cU,SWc->USW"   , _INPUT_14       , _M1             )
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M3              = np.einsum("aT,aV->TVa"    , _INPUT_12       , _INPUT_17       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M0              = np.einsum("bS,bV->SVb"    , _INPUT_8        , _INPUT_18       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.einsum("bP,SVb->PSV"   , _INPUT_2        , _M0             )
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M2              = np.einsum("iT,iV->TVi"    , _INPUT_11       , _INPUT_15       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M5              = np.einsum("aW,TVa->WTVa"  , _INPUT_21       , _M3             )
    del _M3         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.einsum("aQ,WTVa->QWTV" , _INPUT_4        , _M5             )
    del _M5         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M4              = np.einsum("iW,TVi->WTVi"  , _INPUT_19       , _M2             )
    del _M2         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.einsum("iP,WTVi->PWTV" , _INPUT_1        , _M4             )
    del _M4         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.einsum("PWTV,PSV->WTSPV", _M6             , _M7             )
    del _M6         
    del _M7         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8_perm         = np.transpose(_M8             , (0, 1, 2, 4, 3) )
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9              = np.einsum("PQ,WTSVP->QWTSV", _INPUT_0        , _M8_perm        )
    del _M8_perm    
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11             = np.einsum("QWTSV,QWTV->SQWTV", _M9             , _M10            )
    del _M9         
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11_perm        = np.transpose(_M11            , (0, 2, 3, 4, 1) )
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.einsum("jQ,SWTVQ->jSWTV", _INPUT_3        , _M11_perm       )
    del _M11_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M13             = np.einsum("jV,jSWTV->jSWT", _INPUT_16       , _M12            )
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.einsum("jR,jSWT->RSWT" , _INPUT_6        , _M13            )
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.einsum("RS,RSWT->WTRS" , _INPUT_5        , _M14            )
    del _M14        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15_perm        = np.transpose(_M15            , (0, 1, 3, 2)    )
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.einsum("kR,WTSR->kWTS" , _INPUT_7        , _M15_perm       )
    del _M15_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.einsum("kW,kWTS->TSkW" , _INPUT_20       , _M16            )
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17_perm        = np.transpose(_M17            , (0, 1, 3, 2)    )
    del _M17        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.einsum("kU,TSWk->UTSW" , _INPUT_13       , _M17_perm       )
    del _M17_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 25")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M19             = np.einsum("UT,UTSW->USW"  , _INPUT_10_perm  , _M18            )
    del _INPUT_10_perm
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 26")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M21             = np.einsum("USW,USW->"     , _M19            , _M20            )
    del _M19        
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 27")
    return _M21

def RMP3_XX_1_forloop_S_T(Z           : np.ndarray,
                          X_o         : np.ndarray,
                          X_v         : np.ndarray,
                          tau_o       : np.ndarray,
                          tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # step 0 TU->UT 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01_10_wob = getattr(libpbc, "fn_permutation_01_10_wob", None)
    assert fn_permutation_01_10_wob is not None
    _INPUT_10_perm   = np.ndarray((NTHC_INT, NTHC_INT), dtype=np.float64)
    fn_permutation_01_10_wob(ctypes.c_void_p(_INPUT_10.ctypes.data),
                             ctypes.c_void_p(_INPUT_10_perm.ctypes.data),
                             ctypes.c_int(_INPUT_10.shape[0]),
                             ctypes.c_int(_INPUT_10.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    # step 1 cS,cW->SWc 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_9.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_9.shape[0]),
                                 ctypes.c_int(_INPUT_9.shape[1]),
                                 ctypes.c_int(_INPUT_22.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    # step 2 cU,SWc->USW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_14_reshaped.T, _M1_reshaped.T, c=_M20_reshaped)
    _M20         = _M20_reshaped.reshape(*shape_backup)
    del _M1         
    del _M1_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    # step 3 aT,aV->TVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_12.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_12.shape[0]),
                                 ctypes.c_int(_INPUT_12.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    # step 4 bS,bV->SVb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_8.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_8.shape[0]),
                                 ctypes.c_int(_INPUT_8.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    # step 5 bP,SVb->PSV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_2.shape[0]
    _INPUT_2_reshaped = _INPUT_2.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M0.shape[0]
    _size_dim_1      = _size_dim_1 * _M0.shape[1]
    _M0_reshaped = _M0.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M7.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_2_reshaped.T, _M0_reshaped.T, c=_M7_reshaped)
    _M7          = _M7_reshaped.reshape(*shape_backup)
    del _M0         
    del _M0_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    # step 6 iT,iV->TVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_11.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_11.shape[0]),
                                 ctypes.c_int(_INPUT_11.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    # step 7 aW,TVa->WTVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M5              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_21.ctypes.data),
                                   ctypes.c_void_p(_M3.ctypes.data),
                                   ctypes.c_void_p(_M5.ctypes.data),
                                   ctypes.c_int(_INPUT_21.shape[0]),
                                   ctypes.c_int(_INPUT_21.shape[1]),
                                   ctypes.c_int(_M3.shape[0]),
                                   ctypes.c_int(_M3.shape[1]))
    del _M3         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    # step 8 aQ,WTVa->QWTV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M5.shape[0]
    _size_dim_1      = _size_dim_1 * _M5.shape[1]
    _size_dim_1      = _size_dim_1 * _M5.shape[2]
    _M5_reshaped = _M5.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_4_reshaped.T, _M5_reshaped.T, c=_M10_reshaped)
    _M10         = _M10_reshaped.reshape(*shape_backup)
    del _M5         
    del _M5_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    # step 9 iW,TVi->WTVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M4              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19.ctypes.data),
                                   ctypes.c_void_p(_M2.ctypes.data),
                                   ctypes.c_void_p(_M4.ctypes.data),
                                   ctypes.c_int(_INPUT_19.shape[0]),
                                   ctypes.c_int(_INPUT_19.shape[1]),
                                   ctypes.c_int(_M2.shape[0]),
                                   ctypes.c_int(_M2.shape[1]))
    del _M2         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    # step 10 iP,WTVi->PWTV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_1.shape[0]
    _INPUT_1_reshaped = _INPUT_1.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M4.shape[0]
    _size_dim_1      = _size_dim_1 * _M4.shape[1]
    _size_dim_1      = _size_dim_1 * _M4.shape[2]
    _M4_reshaped = _M4.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_1_reshaped.T, _M4_reshaped.T, c=_M6_reshaped)
    _M6          = _M6_reshaped.reshape(*shape_backup)
    del _M4         
    del _M4_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    # step 11 PWTV,PSV->WTSPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_0123_043_12403_wob = getattr(libpbc, "fn_contraction_0123_043_12403_wob", None)
    assert fn_contraction_0123_043_12403_wob is not None
    _M8              = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_0123_043_12403_wob(ctypes.c_void_p(_M6.ctypes.data),
                                      ctypes.c_void_p(_M7.ctypes.data),
                                      ctypes.c_void_p(_M8.ctypes.data),
                                      ctypes.c_int(_M6.shape[0]),
                                      ctypes.c_int(_M6.shape[1]),
                                      ctypes.c_int(_M6.shape[2]),
                                      ctypes.c_int(_M6.shape[3]),
                                      ctypes.c_int(_M7.shape[1]))
    del _M6         
    del _M7         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    # step 12 WTSPV->WTSVP 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_01243_wob = getattr(libpbc, "fn_permutation_01234_01243_wob", None)
    assert fn_permutation_01234_01243_wob is not None
    _M8_perm         = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_01243_wob(ctypes.c_void_p(_M8.ctypes.data),
                                   ctypes.c_void_p(_M8_perm.ctypes.data),
                                   ctypes.c_int(_M8.shape[0]),
                                   ctypes.c_int(_M8.shape[1]),
                                   ctypes.c_int(_M8.shape[2]),
                                   ctypes.c_int(_M8.shape[3]),
                                   ctypes.c_int(_M8.shape[4]))
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    # step 13 PQ,WTSVP->QWTSV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9              = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_0.shape[0]
    _INPUT_0_reshaped = _INPUT_0.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M8_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M8_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M8_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M8_perm.shape[3]
    _M8_perm_reshaped = _M8_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M9.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M9.shape[0]
    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_0_reshaped.T, _M8_perm_reshaped.T, c=_M9_reshaped)
    _M9          = _M9_reshaped.reshape(*shape_backup)
    del _M8_perm    
    del _M8_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    # step 14 QWTSV,QWTV->SQWTV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01234_0124_30124_wob = getattr(libpbc, "fn_contraction_01234_0124_30124_wob", None)
    assert fn_contraction_01234_0124_30124_wob is not None
    _M11             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_01234_0124_30124_wob(ctypes.c_void_p(_M9.ctypes.data),
                                        ctypes.c_void_p(_M10.ctypes.data),
                                        ctypes.c_void_p(_M11.ctypes.data),
                                        ctypes.c_int(_M9.shape[0]),
                                        ctypes.c_int(_M9.shape[1]),
                                        ctypes.c_int(_M9.shape[2]),
                                        ctypes.c_int(_M9.shape[3]),
                                        ctypes.c_int(_M9.shape[4]))
    del _M9         
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    # step 15 SQWTV->SWTVQ 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_02341_wob = getattr(libpbc, "fn_permutation_01234_02341_wob", None)
    assert fn_permutation_01234_02341_wob is not None
    _M11_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_02341_wob(ctypes.c_void_p(_M11.ctypes.data),
                                   ctypes.c_void_p(_M11_perm.ctypes.data),
                                   ctypes.c_int(_M11.shape[0]),
                                   ctypes.c_int(_M11.shape[1]),
                                   ctypes.c_int(_M11.shape[2]),
                                   ctypes.c_int(_M11.shape[3]),
                                   ctypes.c_int(_M11.shape[4]))
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    # step 16 jQ,SWTVQ->jSWTV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.ndarray((NOCC, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M11_perm.shape[3]
    _M11_perm_reshaped = _M11_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M12.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M12.shape[0]
    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped, _M11_perm_reshaped.T, c=_M12_reshaped)
    _M12         = _M12_reshaped.reshape(*shape_backup)
    del _M11_perm   
    del _M11_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    # step 17 jV,jSWTV->jSWT 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02341_0234_wob = getattr(libpbc, "fn_contraction_01_02341_0234_wob", None)
    assert fn_contraction_01_02341_0234_wob is not None
    _M13             = np.ndarray((NOCC, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_02341_0234_wob(ctypes.c_void_p(_INPUT_16.ctypes.data),
                                     ctypes.c_void_p(_M12.ctypes.data),
                                     ctypes.c_void_p(_M13.ctypes.data),
                                     ctypes.c_int(_INPUT_16.shape[0]),
                                     ctypes.c_int(_INPUT_16.shape[1]),
                                     ctypes.c_int(_M12.shape[1]),
                                     ctypes.c_int(_M12.shape[2]),
                                     ctypes.c_int(_M12.shape[3]))
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    # step 18 jR,jSWT->RSWT 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M13.shape[0]
    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_6_reshaped.T, _M13_reshaped, c=_M14_reshaped)
    _M14         = _M14_reshaped.reshape(*shape_backup)
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    # step 19 RS,RSWT->WTRS 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_0123_2301_wob = getattr(libpbc, "fn_contraction_01_0123_2301_wob", None)
    assert fn_contraction_01_0123_2301_wob is not None
    _M15             = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, NTHC_INT), dtype=np.float64)
    fn_contraction_01_0123_2301_wob(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                    ctypes.c_void_p(_M14.ctypes.data),
                                    ctypes.c_void_p(_M15.ctypes.data),
                                    ctypes.c_int(_INPUT_5.shape[0]),
                                    ctypes.c_int(_INPUT_5.shape[1]),
                                    ctypes.c_int(_M14.shape[2]),
                                    ctypes.c_int(_M14.shape[3]))
    del _M14        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    # step 20 WTRS->WTSR 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_0123_0132_wob = getattr(libpbc, "fn_permutation_0123_0132_wob", None)
    assert fn_permutation_0123_0132_wob is not None
    _M15_perm        = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, NTHC_INT), dtype=np.float64)
    fn_permutation_0123_0132_wob(ctypes.c_void_p(_M15.ctypes.data),
                                 ctypes.c_void_p(_M15_perm.ctypes.data),
                                 ctypes.c_int(_M15.shape[0]),
                                 ctypes.c_int(_M15.shape[1]),
                                 ctypes.c_int(_M15.shape[2]),
                                 ctypes.c_int(_M15.shape[3]))
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    # step 21 kR,WTSR->kWTS 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.ndarray((NOCC, N_LAPLACE, NTHC_INT, NTHC_INT), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M15_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M15_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M15_perm.shape[2]
    _M15_perm_reshaped = _M15_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M16.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M16.shape[0]
    _M16_reshaped = _M16.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_7_reshaped, _M15_perm_reshaped.T, c=_M16_reshaped)
    _M16         = _M16_reshaped.reshape(*shape_backup)
    del _M15_perm   
    del _M15_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    # step 22 kW,kWTS->TSkW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_0123_2301_wob = getattr(libpbc, "fn_contraction_01_0123_2301_wob", None)
    assert fn_contraction_01_0123_2301_wob is not None
    _M17             = np.ndarray((NTHC_INT, NTHC_INT, NOCC, N_LAPLACE), dtype=np.float64)
    fn_contraction_01_0123_2301_wob(ctypes.c_void_p(_INPUT_20.ctypes.data),
                                    ctypes.c_void_p(_M16.ctypes.data),
                                    ctypes.c_void_p(_M17.ctypes.data),
                                    ctypes.c_int(_INPUT_20.shape[0]),
                                    ctypes.c_int(_INPUT_20.shape[1]),
                                    ctypes.c_int(_M16.shape[2]),
                                    ctypes.c_int(_M16.shape[3]))
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    # step 23 TSkW->TSWk 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_0123_0132_wob = getattr(libpbc, "fn_permutation_0123_0132_wob", None)
    assert fn_permutation_0123_0132_wob is not None
    _M17_perm        = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_permutation_0123_0132_wob(ctypes.c_void_p(_M17.ctypes.data),
                                 ctypes.c_void_p(_M17_perm.ctypes.data),
                                 ctypes.c_int(_M17.shape[0]),
                                 ctypes.c_int(_M17.shape[1]),
                                 ctypes.c_int(_M17.shape[2]),
                                 ctypes.c_int(_M17.shape[3]))
    del _M17        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    # step 24 kU,TSWk->UTSW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.ndarray((NTHC_INT, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M17_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M17_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M17_perm.shape[2]
    _M17_perm_reshaped = _M17_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_13_reshaped.T, _M17_perm_reshaped.T, c=_M18_reshaped)
    _M18         = _M18_reshaped.reshape(*shape_backup)
    del _M17_perm   
    del _M17_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 25")
    # step 25 UT,UTSW->USW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_0123_023_wob = getattr(libpbc, "fn_contraction_01_0123_023_wob", None)
    assert fn_contraction_01_0123_023_wob is not None
    _M19             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_01_0123_023_wob(ctypes.c_void_p(_INPUT_10_perm.ctypes.data),
                                   ctypes.c_void_p(_M18.ctypes.data),
                                   ctypes.c_void_p(_M19.ctypes.data),
                                   ctypes.c_int(_INPUT_10_perm.shape[0]),
                                   ctypes.c_int(_INPUT_10_perm.shape[1]),
                                   ctypes.c_int(_M18.shape[2]),
                                   ctypes.c_int(_M18.shape[3]))
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 26")
    # step 26 USW,USW-> 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    _M21             = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(_M21))
    _M21 = _M21.value
    del _M19        
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 27")
    return _M21

def RMP3_XX_1_forloop_S_T_forloop_T_S(Z           : np.ndarray,
                                      X_o         : np.ndarray,
                                      X_v         : np.ndarray,
                                      tau_o       : np.ndarray,
                                      tau_v       : np.ndarray,
                                      buffer      : np.ndarray,
                                      T_bunchsize = 8,
                                      S_bunchsize = 8,
                                      V_bunchsize = 1,
                                      W_bunchsize = 1,
                                      use_mpi = False):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # fetch function pointers
    fn_permutation_01_10_wob = getattr(libpbc, "fn_permutation_01_10_wob", None)
    assert fn_permutation_01_10_wob is not None
    fn_permutation_0123_0132_wob = getattr(libpbc, "fn_permutation_0123_0132_wob", None)
    assert fn_permutation_0123_0132_wob is not None
    fn_contraction_01_0123_2301_wob = getattr(libpbc, "fn_contraction_01_0123_2301_wob", None)
    assert fn_contraction_01_0123_2301_wob is not None
    fn_contraction_01_02341_0234_wob = getattr(libpbc, "fn_contraction_01_02341_0234_wob", None)
    assert fn_contraction_01_02341_0234_wob is not None
    fn_slice_3_1_2 = getattr(libpbc, "fn_slice_3_1_2", None)
    assert fn_slice_3_1_2 is not None
    fn_contraction_01_0123_023_wob = getattr(libpbc, "fn_contraction_01_0123_023_wob", None)
    assert fn_contraction_01_0123_023_wob is not None
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    fn_packadd_3_1_2 = getattr(libpbc, "fn_packadd_3_1_2", None)
    assert fn_packadd_3_1_2 is not None
    fn_slice_2_1 = getattr(libpbc, "fn_slice_2_1", None)
    assert fn_slice_2_1 is not None
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    fn_slice_3_0_1 = getattr(libpbc, "fn_slice_3_0_1", None)
    assert fn_slice_3_0_1 is not None
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    fn_contraction_01234_0124_30124_wob = getattr(libpbc, "fn_contraction_01234_0124_30124_wob", None)
    assert fn_contraction_01234_0124_30124_wob is not None
    fn_permutation_01234_02341_wob = getattr(libpbc, "fn_permutation_01234_02341_wob", None)
    assert fn_permutation_01234_02341_wob is not None
    fn_permutation_01234_01243_wob = getattr(libpbc, "fn_permutation_01234_01243_wob", None)
    assert fn_permutation_01234_01243_wob is not None
    fn_contraction_0123_043_12403_wob = getattr(libpbc, "fn_contraction_0123_043_12403_wob", None)
    assert fn_contraction_0123_043_12403_wob is not None
    if use_mpi:
        bunchsize = NTHC_INT//comm_size + 1
        T_begin = rank*bunchsize
        T_end = (rank+1)*bunchsize
        T_begin          = min(T_begin, NTHC_INT)
        T_end            = min(T_end, NTHC_INT)
    else:
        T_begin          = 0               
        T_end            = NTHC_INT        
    # preallocate buffer
    bucket_size      = RMP3_XX_1_forloop_S_T_determine_bucket_size_forloop(NVIR = NVIR,
                                                                           NOCC = NOCC,
                                                                           N_LAPLACE = N_LAPLACE,
                                                                           NTHC_INT = NTHC_INT,
                                                                           T_bunchsize = T_bunchsize,
                                                                           V_bunchsize = V_bunchsize,
                                                                           W_bunchsize = W_bunchsize,
                                                                           S_bunchsize = S_bunchsize)
    bufsize_now      = buffer.size     
    _itemsize        = buffer.itemsize 
    offset_now       = 0               
    offset_0         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[0])
    offset_1         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[1])
    offset_2         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[2])
    offset_3         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[3])
    offset_4         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[4])
    offset_5         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[5])
    offset_6         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[6])
    offset_7         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[7])
    offset_8         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[8])
    offset_9         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[9])
    offset_10        = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[10])
    bufsize          = offset_now      
    if (bufsize > bufsize_now):
        buffer           = np.ndarray((bufsize), dtype=np.float64)
    # step   0 start for loop with indices ()
    # step   1 TU->UT
    _INPUT_10_perm_offset = offset_0        
    _INPUT_10_perm   = np.ndarray((NTHC_INT, NTHC_INT), buffer = buffer, offset = _INPUT_10_perm_offset)
    fn_permutation_01_10_wob(ctypes.c_void_p(_INPUT_10.ctypes.data),
                             ctypes.c_void_p(_INPUT_10_perm.ctypes.data),
                             ctypes.c_int(NTHC_INT),
                             ctypes.c_int(NTHC_INT))
    # step   2 cS,cW->SWc
    offset_now       = offset_1        
    _M1_offset       = offset_now      
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M1_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_9.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_9.shape[0]),
                                 ctypes.c_int(_INPUT_9.shape[1]),
                                 ctypes.c_int(_INPUT_22.shape[1]))
    # step   3 cU,SWc->USW
    offset_now       = offset_2        
    _M20_offset      = offset_now      
    _M20             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M20_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_14_reshaped.T, _M1_reshaped.T, c=_M20_reshaped)
    _M20             = _M20_reshaped.reshape(*shape_backup)
    # step   4 allocate   _M19
    offset_now       = offset_1        
    _M19             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = offset_now)
    _M19_offset      = offset_now      
    _M19.ravel()[:] = 0.0
    # step   5 aT,aV->TVa
    offset_now       = offset_3        
    _M3_offset       = offset_now      
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M3_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_12.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_12.shape[0]),
                                 ctypes.c_int(_INPUT_12.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    # step   6 bS,bV->SVb
    offset_now       = offset_4        
    _M0_offset       = offset_now      
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M0_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_8.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_8.shape[0]),
                                 ctypes.c_int(_INPUT_8.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    # step   7 bP,SVb->PSV
    offset_now       = offset_5        
    _M7_offset       = offset_now      
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M7_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_2.shape[0]
    _INPUT_2_reshaped = _INPUT_2.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M0.shape[0]
    _size_dim_1      = _size_dim_1 * _M0.shape[1]
    _M0_reshaped = _M0.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M7.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_2_reshaped.T, _M0_reshaped.T, c=_M7_reshaped)
    _M7              = _M7_reshaped.reshape(*shape_backup)
    # step   8 iT,iV->TVi
    offset_now       = offset_4        
    _M2_offset       = offset_now      
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M2_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_11.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_11.shape[0]),
                                 ctypes.c_int(_INPUT_11.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    # step   9 start for loop with indices ('T',)
    for T_0, T_1 in lib.prange(T_begin,T_end,T_bunchsize):
        # step  10 start for loop with indices ('T', 'V')
        for V_0, V_1 in lib.prange(0,N_LAPLACE,V_bunchsize):
            # step  11 start for loop with indices ('T', 'V', 'W')
            for W_0, W_1 in lib.prange(0,N_LAPLACE,W_bunchsize):
                # step  12 slice _INPUT_21 with indices ['W']
                _INPUT_21_sliced_offset = offset_6        
                _INPUT_21_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_21_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_21.ctypes.data),
                             ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_21.shape[0]),
                             ctypes.c_int(_INPUT_21.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  13 slice _M3 with indices ['T', 'V']
                _M3_sliced_offset = offset_7        
                _M3_sliced       = np.ndarray(((T_1-T_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M3_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M3.ctypes.data),
                               ctypes.c_void_p(_M3_sliced.ctypes.data),
                               ctypes.c_int(_M3.shape[0]),
                               ctypes.c_int(_M3.shape[1]),
                               ctypes.c_int(_M3.shape[2]),
                               ctypes.c_int(T_0),
                               ctypes.c_int(T_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  14 aW,TVa->WTVa
                offset_now       = offset_8        
                _M5_offset       = offset_now      
                _M5              = np.ndarray(((W_1-W_0), (T_1-T_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M5_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                                               ctypes.c_void_p(_M3_sliced.ctypes.data),
                                               ctypes.c_void_p(_M5.ctypes.data),
                                               ctypes.c_int(_INPUT_21_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_21_sliced.shape[1]),
                                               ctypes.c_int(_M3_sliced.shape[0]),
                                               ctypes.c_int(_M3_sliced.shape[1]))
                # step  15 aQ,WTVa->QWTV
                offset_now       = offset_6        
                _M10_offset      = offset_now      
                _M10             = np.ndarray((NTHC_INT, (W_1-W_0), (T_1-T_0), (V_1-V_0)), buffer = buffer, offset = _M10_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
                _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M5.shape[0]
                _size_dim_1      = _size_dim_1 * _M5.shape[1]
                _size_dim_1      = _size_dim_1 * _M5.shape[2]
                _M5_reshaped = _M5.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M10.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M10.shape[0]
                _M10_reshaped = _M10.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_4_reshaped.T, _M5_reshaped.T, c=_M10_reshaped)
                _M10             = _M10_reshaped.reshape(*shape_backup)
                # step  16 slice _INPUT_19 with indices ['W']
                _INPUT_19_sliced_offset = offset_7        
                _INPUT_19_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_19_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_19.ctypes.data),
                             ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_19.shape[0]),
                             ctypes.c_int(_INPUT_19.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  17 slice _M2 with indices ['T', 'V']
                _M2_sliced_offset = offset_8        
                _M2_sliced       = np.ndarray(((T_1-T_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M2_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M2.ctypes.data),
                               ctypes.c_void_p(_M2_sliced.ctypes.data),
                               ctypes.c_int(_M2.shape[0]),
                               ctypes.c_int(_M2.shape[1]),
                               ctypes.c_int(_M2.shape[2]),
                               ctypes.c_int(T_0),
                               ctypes.c_int(T_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  18 iW,TVi->WTVi
                offset_now       = offset_9        
                _M4_offset       = offset_now      
                _M4              = np.ndarray(((W_1-W_0), (T_1-T_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M4_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                                               ctypes.c_void_p(_M2_sliced.ctypes.data),
                                               ctypes.c_void_p(_M4.ctypes.data),
                                               ctypes.c_int(_INPUT_19_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_19_sliced.shape[1]),
                                               ctypes.c_int(_M2_sliced.shape[0]),
                                               ctypes.c_int(_M2_sliced.shape[1]))
                # step  19 iP,WTVi->PWTV
                offset_now       = offset_7        
                _M6_offset       = offset_now      
                _M6              = np.ndarray((NTHC_INT, (W_1-W_0), (T_1-T_0), (V_1-V_0)), buffer = buffer, offset = _M6_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_1.shape[0]
                _INPUT_1_reshaped = _INPUT_1.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M4.shape[0]
                _size_dim_1      = _size_dim_1 * _M4.shape[1]
                _size_dim_1      = _size_dim_1 * _M4.shape[2]
                _M4_reshaped = _M4.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M6.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M6.shape[0]
                _M6_reshaped = _M6.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_1_reshaped.T, _M4_reshaped.T, c=_M6_reshaped)
                _M6              = _M6_reshaped.reshape(*shape_backup)
                # step  20 start for loop with indices ('T', 'V', 'W', 'S')
                for S_0, S_1 in lib.prange(0,NTHC_INT,S_bunchsize):
                    # step  21 slice _M7 with indices ['S', 'V']
                    _M7_sliced_offset = offset_8        
                    _M7_sliced       = np.ndarray((NTHC_INT, (S_1-S_0), (V_1-V_0)), buffer = buffer, offset = _M7_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M7.ctypes.data),
                                   ctypes.c_void_p(_M7_sliced.ctypes.data),
                                   ctypes.c_int(_M7.shape[0]),
                                   ctypes.c_int(_M7.shape[1]),
                                   ctypes.c_int(_M7.shape[2]),
                                   ctypes.c_int(S_0),
                                   ctypes.c_int(S_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  22 PWTV,PSV->WTSPV
                    offset_now       = offset_9        
                    _M8_offset       = offset_now      
                    _M8              = np.ndarray(((W_1-W_0), (T_1-T_0), (S_1-S_0), NTHC_INT, (V_1-V_0)), buffer = buffer, offset = _M8_offset)
                    fn_contraction_0123_043_12403_wob(ctypes.c_void_p(_M6.ctypes.data),
                                                      ctypes.c_void_p(_M7_sliced.ctypes.data),
                                                      ctypes.c_void_p(_M8.ctypes.data),
                                                      ctypes.c_int(_M6.shape[0]),
                                                      ctypes.c_int(_M6.shape[1]),
                                                      ctypes.c_int(_M6.shape[2]),
                                                      ctypes.c_int(_M6.shape[3]),
                                                      ctypes.c_int(_M7_sliced.shape[1]))
                    # step  23 WTSPV->WTSVP
                    _M8_perm_offset  = offset_8        
                    _M8_perm         = np.ndarray(((W_1-W_0), (T_1-T_0), (S_1-S_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M8_perm_offset)
                    fn_permutation_01234_01243_wob(ctypes.c_void_p(_M8.ctypes.data),
                                                   ctypes.c_void_p(_M8_perm.ctypes.data),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((T_1-T_0)),
                                                   ctypes.c_int((S_1-S_0)),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  24 PQ,WTSVP->QWTSV
                    offset_now       = offset_9        
                    _M9_offset       = offset_now      
                    _M9              = np.ndarray((NTHC_INT, (W_1-W_0), (T_1-T_0), (S_1-S_0), (V_1-V_0)), buffer = buffer, offset = _M9_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_0.shape[0]
                    _INPUT_0_reshaped = _INPUT_0.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M8_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M8_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M8_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M8_perm.shape[3]
                    _M8_perm_reshaped = _M8_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M9.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M9.shape[0]
                    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_0_reshaped.T, _M8_perm_reshaped.T, c=_M9_reshaped)
                    _M9              = _M9_reshaped.reshape(*shape_backup)
                    # step  25 QWTSV,QWTV->SQWTV
                    offset_now       = offset_8        
                    _M11_offset      = offset_now      
                    _M11             = np.ndarray(((S_1-S_0), NTHC_INT, (W_1-W_0), (T_1-T_0), (V_1-V_0)), buffer = buffer, offset = _M11_offset)
                    fn_contraction_01234_0124_30124_wob(ctypes.c_void_p(_M9.ctypes.data),
                                                        ctypes.c_void_p(_M10.ctypes.data),
                                                        ctypes.c_void_p(_M11.ctypes.data),
                                                        ctypes.c_int(_M9.shape[0]),
                                                        ctypes.c_int(_M9.shape[1]),
                                                        ctypes.c_int(_M9.shape[2]),
                                                        ctypes.c_int(_M9.shape[3]),
                                                        ctypes.c_int(_M9.shape[4]))
                    # step  26 SQWTV->SWTVQ
                    _M11_perm_offset = offset_9        
                    _M11_perm        = np.ndarray(((S_1-S_0), (W_1-W_0), (T_1-T_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M11_perm_offset)
                    fn_permutation_01234_02341_wob(ctypes.c_void_p(_M11.ctypes.data),
                                                   ctypes.c_void_p(_M11_perm.ctypes.data),
                                                   ctypes.c_int((S_1-S_0)),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((T_1-T_0)),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  27 jQ,SWTVQ->jSWTV
                    offset_now       = offset_8        
                    _M12_offset      = offset_now      
                    _M12             = np.ndarray((NOCC, (S_1-S_0), (W_1-W_0), (T_1-T_0), (V_1-V_0)), buffer = buffer, offset = _M12_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
                    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M11_perm.shape[3]
                    _M11_perm_reshaped = _M11_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M12.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M12.shape[0]
                    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_3_reshaped, _M11_perm_reshaped.T, c=_M12_reshaped)
                    _M12             = _M12_reshaped.reshape(*shape_backup)
                    # step  28 slice _INPUT_16 with indices ['V']
                    _INPUT_16_sliced_offset = offset_9        
                    _INPUT_16_sliced = np.ndarray((NOCC, (V_1-V_0)), buffer = buffer, offset = _INPUT_16_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_16.shape[0]),
                                 ctypes.c_int(_INPUT_16.shape[1]),
                                 ctypes.c_int(V_0),
                                 ctypes.c_int(V_1))
                    # step  29 jV,jSWTV->jSWT
                    offset_now       = offset_10       
                    _M13_offset      = offset_now      
                    _M13             = np.ndarray((NOCC, (S_1-S_0), (W_1-W_0), (T_1-T_0)), buffer = buffer, offset = _M13_offset)
                    fn_contraction_01_02341_0234_wob(ctypes.c_void_p(_INPUT_16_sliced.ctypes.data),
                                                     ctypes.c_void_p(_M12.ctypes.data),
                                                     ctypes.c_void_p(_M13.ctypes.data),
                                                     ctypes.c_int(_INPUT_16_sliced.shape[0]),
                                                     ctypes.c_int(_INPUT_16_sliced.shape[1]),
                                                     ctypes.c_int(_M12.shape[1]),
                                                     ctypes.c_int(_M12.shape[2]),
                                                     ctypes.c_int(_M12.shape[3]))
                    # step  30 jR,jSWT->RSWT
                    offset_now       = offset_8        
                    _M14_offset      = offset_now      
                    _M14             = np.ndarray((NTHC_INT, (S_1-S_0), (W_1-W_0), (T_1-T_0)), buffer = buffer, offset = _M14_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
                    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M13.shape[0]
                    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M14.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M14.shape[0]
                    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_6_reshaped.T, _M13_reshaped, c=_M14_reshaped)
                    _M14             = _M14_reshaped.reshape(*shape_backup)
                    # step  31 slice _INPUT_5 with indices ['S']
                    _INPUT_5_sliced_offset = offset_9        
                    _INPUT_5_sliced  = np.ndarray((NTHC_INT, (S_1-S_0)), buffer = buffer, offset = _INPUT_5_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                 ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_5.shape[0]),
                                 ctypes.c_int(_INPUT_5.shape[1]),
                                 ctypes.c_int(S_0),
                                 ctypes.c_int(S_1))
                    # step  32 RS,RSWT->WTRS
                    offset_now       = offset_10       
                    _M15_offset      = offset_now      
                    _M15             = np.ndarray(((W_1-W_0), (T_1-T_0), NTHC_INT, (S_1-S_0)), buffer = buffer, offset = _M15_offset)
                    fn_contraction_01_0123_2301_wob(ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                                    ctypes.c_void_p(_M14.ctypes.data),
                                                    ctypes.c_void_p(_M15.ctypes.data),
                                                    ctypes.c_int(_INPUT_5_sliced.shape[0]),
                                                    ctypes.c_int(_INPUT_5_sliced.shape[1]),
                                                    ctypes.c_int(_M14.shape[2]),
                                                    ctypes.c_int(_M14.shape[3]))
                    # step  33 WTRS->WTSR
                    _M15_perm_offset = offset_8        
                    _M15_perm        = np.ndarray(((W_1-W_0), (T_1-T_0), (S_1-S_0), NTHC_INT), buffer = buffer, offset = _M15_perm_offset)
                    fn_permutation_0123_0132_wob(ctypes.c_void_p(_M15.ctypes.data),
                                                 ctypes.c_void_p(_M15_perm.ctypes.data),
                                                 ctypes.c_int((W_1-W_0)),
                                                 ctypes.c_int((T_1-T_0)),
                                                 ctypes.c_int(NTHC_INT),
                                                 ctypes.c_int((S_1-S_0)))
                    # step  34 kR,WTSR->kWTS
                    offset_now       = offset_9        
                    _M16_offset      = offset_now      
                    _M16             = np.ndarray((NOCC, (W_1-W_0), (T_1-T_0), (S_1-S_0)), buffer = buffer, offset = _M16_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
                    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M15_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M15_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M15_perm.shape[2]
                    _M15_perm_reshaped = _M15_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M16.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M16.shape[0]
                    _M16_reshaped = _M16.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_7_reshaped, _M15_perm_reshaped.T, c=_M16_reshaped)
                    _M16             = _M16_reshaped.reshape(*shape_backup)
                    # step  35 slice _INPUT_20 with indices ['W']
                    _INPUT_20_sliced_offset = offset_8        
                    _INPUT_20_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_20_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_20.shape[0]),
                                 ctypes.c_int(_INPUT_20.shape[1]),
                                 ctypes.c_int(W_0),
                                 ctypes.c_int(W_1))
                    # step  36 kW,kWTS->TSkW
                    offset_now       = offset_10       
                    _M17_offset      = offset_now      
                    _M17             = np.ndarray(((T_1-T_0), (S_1-S_0), NOCC, (W_1-W_0)), buffer = buffer, offset = _M17_offset)
                    fn_contraction_01_0123_2301_wob(ctypes.c_void_p(_INPUT_20_sliced.ctypes.data),
                                                    ctypes.c_void_p(_M16.ctypes.data),
                                                    ctypes.c_void_p(_M17.ctypes.data),
                                                    ctypes.c_int(_INPUT_20_sliced.shape[0]),
                                                    ctypes.c_int(_INPUT_20_sliced.shape[1]),
                                                    ctypes.c_int(_M16.shape[2]),
                                                    ctypes.c_int(_M16.shape[3]))
                    # step  37 TSkW->TSWk
                    _M17_perm_offset = offset_8        
                    _M17_perm        = np.ndarray(((T_1-T_0), (S_1-S_0), (W_1-W_0), NOCC), buffer = buffer, offset = _M17_perm_offset)
                    fn_permutation_0123_0132_wob(ctypes.c_void_p(_M17.ctypes.data),
                                                 ctypes.c_void_p(_M17_perm.ctypes.data),
                                                 ctypes.c_int((T_1-T_0)),
                                                 ctypes.c_int((S_1-S_0)),
                                                 ctypes.c_int(NOCC),
                                                 ctypes.c_int((W_1-W_0)))
                    # step  38 kU,TSWk->UTSW
                    offset_now       = offset_9        
                    _M18_offset      = offset_now      
                    _M18             = np.ndarray((NTHC_INT, (T_1-T_0), (S_1-S_0), (W_1-W_0)), buffer = buffer, offset = _M18_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
                    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M17_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M17_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M17_perm.shape[2]
                    _M17_perm_reshaped = _M17_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M18.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M18.shape[0]
                    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_13_reshaped.T, _M17_perm_reshaped.T, c=_M18_reshaped)
                    _M18             = _M18_reshaped.reshape(*shape_backup)
                    # step  39 slice _INPUT_10 with indices ['T']
                    _INPUT_10_perm_sliced_offset = offset_8        
                    _INPUT_10_perm_sliced = np.ndarray((NTHC_INT, (T_1-T_0)), buffer = buffer, offset = _INPUT_10_perm_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_10_perm.ctypes.data),
                                 ctypes.c_void_p(_INPUT_10_perm_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_10_perm.shape[0]),
                                 ctypes.c_int(_INPUT_10_perm.shape[1]),
                                 ctypes.c_int(T_0),
                                 ctypes.c_int(T_1))
                    # step  40 UT,UTSW->USW
                    offset_now       = offset_10       
                    _M19_packed_offset = offset_now      
                    _M19_packed      = np.ndarray((NTHC_INT, (S_1-S_0), (W_1-W_0)), buffer = buffer, offset = _M19_packed_offset)
                    fn_contraction_01_0123_023_wob(ctypes.c_void_p(_INPUT_10_perm_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M18.ctypes.data),
                                                   ctypes.c_void_p(_M19_packed.ctypes.data),
                                                   ctypes.c_int(_INPUT_10_perm_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_10_perm_sliced.shape[1]),
                                                   ctypes.c_int(_M18.shape[2]),
                                                   ctypes.c_int(_M18.shape[3]))
                    # step  41 pack  _M19 with indices ['W', 'S']
                    fn_packadd_3_1_2(ctypes.c_void_p(_M19.ctypes.data),
                                     ctypes.c_void_p(_M19_packed.ctypes.data),
                                     ctypes.c_int(_M19.shape[0]),
                                     ctypes.c_int(_M19.shape[1]),
                                     ctypes.c_int(_M19.shape[2]),
                                     ctypes.c_int(S_0),
                                     ctypes.c_int(S_1),
                                     ctypes.c_int(W_0),
                                     ctypes.c_int(W_1))
                # step  42 end   for loop with indices ('T', 'V', 'W', 'S')
                # step  43 deallocate ['_M10', '_M6']
            # step  44 end   for loop with indices ('T', 'V', 'W')
        # step  45 end   for loop with indices ('T', 'V')
    # step  46 end   for loop with indices ('T',)
    # step  47 deallocate ['_M3', '_M7', '_M2']
    # step  48 USW,USW->
    output_tmp       = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(output_tmp))
    _M21 = output_tmp.value
    # clean the final forloop
    # MPI finalize
    if use_mpi:
        _M21 = reduce(_M21, root=0)
        _M21 = bcast(_M21, root=0)
    return _M21

def RMP3_XX_2_forloop_P_S_determine_bucket_size_forloop(NVIR        : int,
                                                        NOCC        : int,
                                                        N_LAPLACE   : int,
                                                        NTHC_INT    : int,
                                                        P_bunchsize = 8,
                                                        S_bunchsize = 8,
                                                        V_bunchsize = 1,
                                                        W_bunchsize = 1):
    # init
    output = []     
    bucked_0_size    = 0               
    bucked_1_size    = 0               
    bucked_2_size    = 0               
    bucked_3_size    = 0               
    bucked_4_size    = 0               
    bucked_5_size    = 0               
    bucked_6_size    = 0               
    bucked_7_size    = 0               
    bucked_8_size    = 0               
    bucked_9_size    = 0               
    # assign the size of each tensor
    _M3_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M19_size        = (NTHC_INT * (N_LAPLACE * NTHC_INT))
    _M20_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M0_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M20_perm_size   = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M2_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M1_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _INPUT_17_sliced_size = (NVIR * N_LAPLACE)
    _INPUT_19_sliced_size = (NOCC * N_LAPLACE)
    _M18_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize)))
    _M14_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M6_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _INPUT_21_sliced_size = (NVIR * N_LAPLACE)
    _M0_sliced_size  = (P_bunchsize * (V_bunchsize * NOCC))
    _INPUT_5_sliced_size = (NTHC_INT * NTHC_INT)
    _M8_size         = (NOCC * (S_bunchsize * (P_bunchsize * V_bunchsize)))
    _M9_perm_size    = (S_bunchsize * (P_bunchsize * (NOCC * V_bunchsize)))
    _INPUT_0_sliced_size = (NTHC_INT * NTHC_INT)
    _M12_size        = (NVIR * (S_bunchsize * (V_bunchsize * P_bunchsize)))
    _M15_size        = (NTHC_INT * (W_bunchsize * (S_bunchsize * (P_bunchsize * V_bunchsize))))
    _M16_perm_size   = (P_bunchsize * (V_bunchsize * (NTHC_INT * (S_bunchsize * W_bunchsize))))
    _M17_perm_size   = (NTHC_INT * (P_bunchsize * (V_bunchsize * (S_bunchsize * W_bunchsize))))
    _M4_size         = (V_bunchsize * (W_bunchsize * NVIR))
    _M5_size         = (W_bunchsize * (P_bunchsize * (V_bunchsize * NOCC)))
    _M6_sliced_size  = (NTHC_INT * (P_bunchsize * V_bunchsize))
    _INPUT_16_sliced_size = (NOCC * N_LAPLACE)
    _M10_size        = (NTHC_INT * (S_bunchsize * (P_bunchsize * V_bunchsize)))
    _M13_size        = (W_bunchsize * (S_bunchsize * (P_bunchsize * (V_bunchsize * NVIR))))
    _M14_sliced_size = (NTHC_INT * (S_bunchsize * W_bunchsize))
    _M17_size        = (NTHC_INT * (P_bunchsize * (V_bunchsize * (S_bunchsize * W_bunchsize))))
    _M7_size         = (S_bunchsize * (P_bunchsize * (V_bunchsize * NTHC_INT)))
    _M9_size         = (S_bunchsize * (P_bunchsize * (NOCC * V_bunchsize)))
    _M11_size        = (S_bunchsize * (V_bunchsize * (P_bunchsize * NTHC_INT)))
    _M16_size        = (P_bunchsize * (V_bunchsize * (NTHC_INT * (S_bunchsize * W_bunchsize))))
    _M19_packed_size = (NTHC_INT * (W_bunchsize * S_bunchsize))
    # determine the size of each bucket
    # bucket 0
    bucked_0_size    = max(bucked_0_size, _M3_size)
    bucked_0_size    = max(bucked_0_size, _M19_size)
    # bucket 1
    bucked_1_size    = max(bucked_1_size, _M20_size)
    bucked_1_size    = max(bucked_1_size, _M0_size)
    # bucket 2
    bucked_2_size    = max(bucked_2_size, _M20_perm_size)
    # bucket 3
    bucked_3_size    = max(bucked_3_size, _M2_size)
    bucked_3_size    = max(bucked_3_size, _M1_size)
    bucked_3_size    = max(bucked_3_size, _INPUT_17_sliced_size)
    bucked_3_size    = max(bucked_3_size, _INPUT_19_sliced_size)
    bucked_3_size    = max(bucked_3_size, _M18_size)
    # bucket 4
    bucked_4_size    = max(bucked_4_size, _M14_size)
    # bucket 5
    bucked_5_size    = max(bucked_5_size, _M6_size)
    # bucket 6
    bucked_6_size    = max(bucked_6_size, _INPUT_21_sliced_size)
    bucked_6_size    = max(bucked_6_size, _M0_sliced_size)
    bucked_6_size    = max(bucked_6_size, _INPUT_5_sliced_size)
    bucked_6_size    = max(bucked_6_size, _M8_size)
    bucked_6_size    = max(bucked_6_size, _M9_perm_size)
    bucked_6_size    = max(bucked_6_size, _INPUT_0_sliced_size)
    bucked_6_size    = max(bucked_6_size, _M12_size)
    bucked_6_size    = max(bucked_6_size, _M15_size)
    bucked_6_size    = max(bucked_6_size, _M16_perm_size)
    bucked_6_size    = max(bucked_6_size, _M17_perm_size)
    # bucket 7
    bucked_7_size    = max(bucked_7_size, _M4_size)
    # bucket 8
    bucked_8_size    = max(bucked_8_size, _M5_size)
    bucked_8_size    = max(bucked_8_size, _M6_sliced_size)
    bucked_8_size    = max(bucked_8_size, _INPUT_16_sliced_size)
    bucked_8_size    = max(bucked_8_size, _M10_size)
    bucked_8_size    = max(bucked_8_size, _M13_size)
    bucked_8_size    = max(bucked_8_size, _M14_sliced_size)
    bucked_8_size    = max(bucked_8_size, _M17_size)
    # bucket 9
    bucked_9_size    = max(bucked_9_size, _M7_size)
    bucked_9_size    = max(bucked_9_size, _M9_size)
    bucked_9_size    = max(bucked_9_size, _M11_size)
    bucked_9_size    = max(bucked_9_size, _M16_size)
    bucked_9_size    = max(bucked_9_size, _M19_packed_size)
    # append each bucket size to the output
    output.append(bucked_0_size)
    output.append(bucked_1_size)
    output.append(bucked_2_size)
    output.append(bucked_3_size)
    output.append(bucked_4_size)
    output.append(bucked_5_size)
    output.append(bucked_6_size)
    output.append(bucked_7_size)
    output.append(bucked_8_size)
    output.append(bucked_9_size)
    return output

def RMP3_XX_2_forloop_P_S_naive(Z           : np.ndarray,
                                X_o         : np.ndarray,
                                X_v         : np.ndarray,
                                tau_o       : np.ndarray,
                                tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_v             
    _INPUT_8         = X_o             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    t1 = (logger.process_clock(), logger.perf_counter())
    _M3              = np.einsum("cS,cW->SWc"    , _INPUT_9        , _INPUT_22       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.einsum("cU,SWc->USW"   , _INPUT_14       , _M3             )
    del _M3         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20_perm        = np.transpose(_M20            , (0, 2, 1)       )
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M0              = np.einsum("iP,iV->PVi"    , _INPUT_1        , _INPUT_15       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M2              = np.einsum("kS,kW->SWk"    , _INPUT_8        , _INPUT_20       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.einsum("kT,SWk->TSW"   , _INPUT_11       , _M2             )
    del _M2         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M1              = np.einsum("bP,bV->PVb"    , _INPUT_2        , _INPUT_18       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.einsum("bR,PVb->RPV"   , _INPUT_7        , _M1             )
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M4              = np.einsum("aV,aW->VWa"    , _INPUT_17       , _INPUT_21       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M5              = np.einsum("iW,PVi->WPVi"  , _INPUT_19       , _M0             )
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.einsum("iU,WPVi->UWPV" , _INPUT_13       , _M5             )
    del _M5         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.einsum("RS,RPV->SPVR"  , _INPUT_5        , _M6             )
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.einsum("jR,SPVR->jSPV" , _INPUT_6        , _M7             )
    del _M7         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9              = np.einsum("jV,jSPV->SPjV" , _INPUT_16       , _M8             )
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9_perm         = np.transpose(_M9             , (0, 1, 3, 2)    )
    del _M9         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.einsum("jQ,SPVj->QSPV" , _INPUT_3        , _M9_perm        )
    del _M9_perm    
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11             = np.einsum("PQ,QSPV->SVPQ" , _INPUT_0        , _M10            )
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.einsum("aQ,SVPQ->aSVP" , _INPUT_4        , _M11            )
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M13             = np.einsum("VWa,aSVP->WSPVa", _M4             , _M12            )
    del _M4         
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.einsum("aT,WSPVa->TWSPV", _INPUT_12       , _M13            )
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.einsum("TSW,TWSPV->PVTSW", _M14            , _M15            )
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16_perm        = np.transpose(_M16            , (0, 1, 3, 4, 2) )
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.einsum("TU,PVSWT->UPVSW", _INPUT_10       , _M16_perm       )
    del _M16_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17_perm        = np.transpose(_M17            , (0, 4, 3, 1, 2) )
    del _M17        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M19             = np.einsum("UWSPV,UWPV->UWS", _M17_perm       , _M18            )
    del _M17_perm   
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 25")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M21             = np.einsum("UWS,UWS->"     , _M19            , _M20_perm       )
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 26")
    return _M21

def RMP3_XX_2_forloop_P_S(Z           : np.ndarray,
                          X_o         : np.ndarray,
                          X_v         : np.ndarray,
                          tau_o       : np.ndarray,
                          tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_v             
    _INPUT_8         = X_o             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # step 0 cS,cW->SWc 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_9.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_9.shape[0]),
                                 ctypes.c_int(_INPUT_9.shape[1]),
                                 ctypes.c_int(_INPUT_22.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    # step 1 cU,SWc->USW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_14_reshaped.T, _M3_reshaped.T, c=_M20_reshaped)
    _M20         = _M20_reshaped.reshape(*shape_backup)
    del _M3         
    del _M3_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    # step 2 USW->UWS 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_012_021_wob = getattr(libpbc, "fn_permutation_012_021_wob", None)
    assert fn_permutation_012_021_wob is not None
    _M20_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_012_021_wob(ctypes.c_void_p(_M20.ctypes.data),
                               ctypes.c_void_p(_M20_perm.ctypes.data),
                               ctypes.c_int(_M20.shape[0]),
                               ctypes.c_int(_M20.shape[1]),
                               ctypes.c_int(_M20.shape[2]))
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    # step 3 iP,iV->PVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    # step 4 kS,kW->SWk 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_8.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_8.shape[0]),
                                 ctypes.c_int(_INPUT_8.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    # step 5 kT,SWk->TSW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_11_reshaped.T, _M2_reshaped.T, c=_M14_reshaped)
    _M14         = _M14_reshaped.reshape(*shape_backup)
    del _M2         
    del _M2_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    # step 6 bP,bV->PVb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    # step 7 bR,PVb->RPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_7_reshaped.T, _M1_reshaped.T, c=_M6_reshaped)
    _M6          = _M6_reshaped.reshape(*shape_backup)
    del _M1         
    del _M1_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    # step 8 aV,aW->VWa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M4              = np.ndarray((N_LAPLACE, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_INPUT_21.ctypes.data),
                                 ctypes.c_void_p(_M4.ctypes.data),
                                 ctypes.c_int(_INPUT_17.shape[0]),
                                 ctypes.c_int(_INPUT_17.shape[1]),
                                 ctypes.c_int(_INPUT_21.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    # step 9 iW,PVi->WPVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M5              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19.ctypes.data),
                                   ctypes.c_void_p(_M0.ctypes.data),
                                   ctypes.c_void_p(_M5.ctypes.data),
                                   ctypes.c_int(_INPUT_19.shape[0]),
                                   ctypes.c_int(_INPUT_19.shape[1]),
                                   ctypes.c_int(_M0.shape[0]),
                                   ctypes.c_int(_M0.shape[1]))
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    # step 10 iU,WPVi->UWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M5.shape[0]
    _size_dim_1      = _size_dim_1 * _M5.shape[1]
    _size_dim_1      = _size_dim_1 * _M5.shape[2]
    _M5_reshaped = _M5.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_13_reshaped.T, _M5_reshaped.T, c=_M18_reshaped)
    _M18         = _M18_reshaped.reshape(*shape_backup)
    del _M5         
    del _M5_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    # step 11 RS,RPV->SPVR 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_023_1230_wob = getattr(libpbc, "fn_contraction_01_023_1230_wob", None)
    assert fn_contraction_01_023_1230_wob is not None
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_023_1230_wob(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                   ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M7.ctypes.data),
                                   ctypes.c_int(_INPUT_5.shape[0]),
                                   ctypes.c_int(_INPUT_5.shape[1]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]))
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    # step 12 jR,SPVR->jSPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.ndarray((NOCC, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _size_dim_1      = _size_dim_1 * _M7.shape[1]
    _size_dim_1      = _size_dim_1 * _M7.shape[2]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M8.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M8.shape[0]
    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_6_reshaped, _M7_reshaped.T, c=_M8_reshaped)
    _M8          = _M8_reshaped.reshape(*shape_backup)
    del _M7         
    del _M7_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    # step 13 jV,jSPV->SPjV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_0231_2301_wob = getattr(libpbc, "fn_contraction_01_0231_2301_wob", None)
    assert fn_contraction_01_0231_2301_wob is not None
    _M9              = np.ndarray((NTHC_INT, NTHC_INT, NOCC, N_LAPLACE), dtype=np.float64)
    fn_contraction_01_0231_2301_wob(ctypes.c_void_p(_INPUT_16.ctypes.data),
                                    ctypes.c_void_p(_M8.ctypes.data),
                                    ctypes.c_void_p(_M9.ctypes.data),
                                    ctypes.c_int(_INPUT_16.shape[0]),
                                    ctypes.c_int(_INPUT_16.shape[1]),
                                    ctypes.c_int(_M8.shape[1]),
                                    ctypes.c_int(_M8.shape[2]))
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    # step 14 SPjV->SPVj 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_0123_0132_wob = getattr(libpbc, "fn_permutation_0123_0132_wob", None)
    assert fn_permutation_0123_0132_wob is not None
    _M9_perm         = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_permutation_0123_0132_wob(ctypes.c_void_p(_M9.ctypes.data),
                                 ctypes.c_void_p(_M9_perm.ctypes.data),
                                 ctypes.c_int(_M9.shape[0]),
                                 ctypes.c_int(_M9.shape[1]),
                                 ctypes.c_int(_M9.shape[2]),
                                 ctypes.c_int(_M9.shape[3]))
    del _M9         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    # step 15 jQ,SPVj->QSPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M9_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M9_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M9_perm.shape[2]
    _M9_perm_reshaped = _M9_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped.T, _M9_perm_reshaped.T, c=_M10_reshaped)
    _M10         = _M10_reshaped.reshape(*shape_backup)
    del _M9_perm    
    del _M9_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    # step 16 PQ,QSPV->SVPQ 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_1203_2301_wob = getattr(libpbc, "fn_contraction_01_1203_2301_wob", None)
    assert fn_contraction_01_1203_2301_wob is not None
    _M11             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT), dtype=np.float64)
    fn_contraction_01_1203_2301_wob(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                    ctypes.c_void_p(_M10.ctypes.data),
                                    ctypes.c_void_p(_M11.ctypes.data),
                                    ctypes.c_int(_INPUT_0.shape[0]),
                                    ctypes.c_int(_INPUT_0.shape[1]),
                                    ctypes.c_int(_M10.shape[1]),
                                    ctypes.c_int(_M10.shape[3]))
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    # step 17 aQ,SVPQ->aSVP 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.ndarray((NVIR, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M11.shape[0]
    _size_dim_1      = _size_dim_1 * _M11.shape[1]
    _size_dim_1      = _size_dim_1 * _M11.shape[2]
    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M12.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M12.shape[0]
    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_4_reshaped, _M11_reshaped.T, c=_M12_reshaped)
    _M12         = _M12_reshaped.reshape(*shape_backup)
    del _M11        
    del _M11_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    # step 18 VWa,aSVP->WSPVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_2304_13402_wob = getattr(libpbc, "fn_contraction_012_2304_13402_wob", None)
    assert fn_contraction_012_2304_13402_wob is not None
    _M13             = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_012_2304_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                      ctypes.c_void_p(_M12.ctypes.data),
                                      ctypes.c_void_p(_M13.ctypes.data),
                                      ctypes.c_int(_M4.shape[0]),
                                      ctypes.c_int(_M4.shape[1]),
                                      ctypes.c_int(_M4.shape[2]),
                                      ctypes.c_int(_M12.shape[1]),
                                      ctypes.c_int(_M12.shape[3]))
    del _M4         
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    # step 19 aT,WSPVa->TWSPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M13.shape[0]
    _size_dim_1      = _size_dim_1 * _M13.shape[1]
    _size_dim_1      = _size_dim_1 * _M13.shape[2]
    _size_dim_1      = _size_dim_1 * _M13.shape[3]
    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M15.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M15.shape[0]
    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_12_reshaped.T, _M13_reshaped.T, c=_M15_reshaped)
    _M15         = _M15_reshaped.reshape(*shape_backup)
    del _M13        
    del _M13_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    # step 20 TSW,TWSPV->PVTSW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_02134_34012_wob = getattr(libpbc, "fn_contraction_012_02134_34012_wob", None)
    assert fn_contraction_012_02134_34012_wob is not None
    _M16             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_012_02134_34012_wob(ctypes.c_void_p(_M14.ctypes.data),
                                       ctypes.c_void_p(_M15.ctypes.data),
                                       ctypes.c_void_p(_M16.ctypes.data),
                                       ctypes.c_int(_M14.shape[0]),
                                       ctypes.c_int(_M14.shape[1]),
                                       ctypes.c_int(_M14.shape[2]),
                                       ctypes.c_int(_M15.shape[3]),
                                       ctypes.c_int(_M15.shape[4]))
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    # step 21 PVTSW->PVSWT 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_01342_wob = getattr(libpbc, "fn_permutation_01234_01342_wob", None)
    assert fn_permutation_01234_01342_wob is not None
    _M16_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_01342_wob(ctypes.c_void_p(_M16.ctypes.data),
                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                   ctypes.c_int(_M16.shape[0]),
                                   ctypes.c_int(_M16.shape[1]),
                                   ctypes.c_int(_M16.shape[2]),
                                   ctypes.c_int(_M16.shape[3]),
                                   ctypes.c_int(_M16.shape[4]))
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    # step 22 TU,PVSWT->UPVSW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M17.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M17.shape[0]
    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
    _M17         = _M17_reshaped.reshape(*shape_backup)
    del _M16_perm   
    del _M16_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    # step 23 UPVSW->UWSPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_04312_wob = getattr(libpbc, "fn_permutation_01234_04312_wob", None)
    assert fn_permutation_01234_04312_wob is not None
    _M17_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_permutation_01234_04312_wob(ctypes.c_void_p(_M17.ctypes.data),
                                   ctypes.c_void_p(_M17_perm.ctypes.data),
                                   ctypes.c_int(_M17.shape[0]),
                                   ctypes.c_int(_M17.shape[1]),
                                   ctypes.c_int(_M17.shape[2]),
                                   ctypes.c_int(_M17.shape[3]),
                                   ctypes.c_int(_M17.shape[4]))
    del _M17        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    # step 24 UWSPV,UWPV->UWS 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01234_0134_012_wob = getattr(libpbc, "fn_contraction_01234_0134_012_wob", None)
    assert fn_contraction_01234_0134_012_wob is not None
    _M19             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01234_0134_012_wob(ctypes.c_void_p(_M17_perm.ctypes.data),
                                      ctypes.c_void_p(_M18.ctypes.data),
                                      ctypes.c_void_p(_M19.ctypes.data),
                                      ctypes.c_int(_M17_perm.shape[0]),
                                      ctypes.c_int(_M17_perm.shape[1]),
                                      ctypes.c_int(_M17_perm.shape[2]),
                                      ctypes.c_int(_M17_perm.shape[3]),
                                      ctypes.c_int(_M17_perm.shape[4]))
    del _M17_perm   
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 25")
    # step 25 UWS,UWS-> 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    _M21             = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20_perm.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(_M21))
    _M21 = _M21.value
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 26")
    return _M21

def RMP3_XX_2_forloop_P_S_forloop_P_S(Z           : np.ndarray,
                                      X_o         : np.ndarray,
                                      X_v         : np.ndarray,
                                      tau_o       : np.ndarray,
                                      tau_v       : np.ndarray,
                                      buffer      : np.ndarray,
                                      P_bunchsize = 8,
                                      S_bunchsize = 8,
                                      V_bunchsize = 1,
                                      W_bunchsize = 1,
                                      use_mpi = False):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_v             
    _INPUT_8         = X_o             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # fetch function pointers
    fn_contraction_01_0231_2301_wob = getattr(libpbc, "fn_contraction_01_0231_2301_wob", None)
    assert fn_contraction_01_0231_2301_wob is not None
    fn_permutation_0123_0132_wob = getattr(libpbc, "fn_permutation_0123_0132_wob", None)
    assert fn_permutation_0123_0132_wob is not None
    fn_permutation_01234_01342_wob = getattr(libpbc, "fn_permutation_01234_01342_wob", None)
    assert fn_permutation_01234_01342_wob is not None
    fn_contraction_012_02134_34012_wob = getattr(libpbc, "fn_contraction_012_02134_34012_wob", None)
    assert fn_contraction_012_02134_34012_wob is not None
    fn_slice_3_1_2 = getattr(libpbc, "fn_slice_3_1_2", None)
    assert fn_slice_3_1_2 is not None
    fn_contraction_01_1203_2301_wob = getattr(libpbc, "fn_contraction_01_1203_2301_wob", None)
    assert fn_contraction_01_1203_2301_wob is not None
    fn_permutation_01234_04312_wob = getattr(libpbc, "fn_permutation_01234_04312_wob", None)
    assert fn_permutation_01234_04312_wob is not None
    fn_contraction_01234_0134_012_wob = getattr(libpbc, "fn_contraction_01234_0134_012_wob", None)
    assert fn_contraction_01234_0134_012_wob is not None
    fn_slice_2_1 = getattr(libpbc, "fn_slice_2_1", None)
    assert fn_slice_2_1 is not None
    fn_slice_2_0 = getattr(libpbc, "fn_slice_2_0", None)
    assert fn_slice_2_0 is not None
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    fn_slice_3_0_1 = getattr(libpbc, "fn_slice_3_0_1", None)
    assert fn_slice_3_0_1 is not None
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    fn_contraction_012_2304_13402_wob = getattr(libpbc, "fn_contraction_012_2304_13402_wob", None)
    assert fn_contraction_012_2304_13402_wob is not None
    fn_packadd_3_1_2 = getattr(libpbc, "fn_packadd_3_1_2", None)
    assert fn_packadd_3_1_2 is not None
    fn_contraction_01_023_1230_wob = getattr(libpbc, "fn_contraction_01_023_1230_wob", None)
    assert fn_contraction_01_023_1230_wob is not None
    fn_permutation_012_021_wob = getattr(libpbc, "fn_permutation_012_021_wob", None)
    assert fn_permutation_012_021_wob is not None
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    if use_mpi:
        bunchsize = NTHC_INT//comm_size + 1
        P_begin = rank*bunchsize
        P_end = (rank+1)*bunchsize
        P_begin          = min(P_begin, NTHC_INT)
        P_end            = min(P_end, NTHC_INT)
    else:
        P_begin          = 0               
        P_end            = NTHC_INT        
    # preallocate buffer
    bucket_size      = RMP3_XX_2_forloop_P_S_determine_bucket_size_forloop(NVIR = NVIR,
                                                                           NOCC = NOCC,
                                                                           N_LAPLACE = N_LAPLACE,
                                                                           NTHC_INT = NTHC_INT,
                                                                           V_bunchsize = V_bunchsize,
                                                                           W_bunchsize = W_bunchsize,
                                                                           P_bunchsize = P_bunchsize,
                                                                           S_bunchsize = S_bunchsize)
    bufsize_now      = buffer.size     
    _itemsize        = buffer.itemsize 
    offset_now       = 0               
    offset_0         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[0])
    offset_1         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[1])
    offset_2         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[2])
    offset_3         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[3])
    offset_4         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[4])
    offset_5         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[5])
    offset_6         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[6])
    offset_7         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[7])
    offset_8         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[8])
    offset_9         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[9])
    bufsize          = offset_now      
    if (bufsize > bufsize_now):
        buffer           = np.ndarray((bufsize), dtype=np.float64)
    # step   0 start for loop with indices ()
    # step   1 cS,cW->SWc
    offset_now       = offset_0        
    _M3_offset       = offset_now      
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M3_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_9.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_9.shape[0]),
                                 ctypes.c_int(_INPUT_9.shape[1]),
                                 ctypes.c_int(_INPUT_22.shape[1]))
    # step   2 cU,SWc->USW
    offset_now       = offset_1        
    _M20_offset      = offset_now      
    _M20             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M20_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_14_reshaped.T, _M3_reshaped.T, c=_M20_reshaped)
    _M20             = _M20_reshaped.reshape(*shape_backup)
    # step   3 allocate   _M19
    offset_now       = offset_0        
    _M19             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT), buffer = buffer, offset = offset_now)
    _M19_offset      = offset_now      
    _M19.ravel()[:] = 0.0
    # step   4 USW->UWS
    _M20_perm_offset = offset_2        
    _M20_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT), buffer = buffer, offset = _M20_perm_offset)
    fn_permutation_012_021_wob(ctypes.c_void_p(_M20.ctypes.data),
                               ctypes.c_void_p(_M20_perm.ctypes.data),
                               ctypes.c_int(NTHC_INT),
                               ctypes.c_int(NTHC_INT),
                               ctypes.c_int(N_LAPLACE))
    # step   5 iP,iV->PVi
    offset_now       = offset_1        
    _M0_offset       = offset_now      
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M0_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    # step   6 kS,kW->SWk
    offset_now       = offset_3        
    _M2_offset       = offset_now      
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M2_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_8.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_8.shape[0]),
                                 ctypes.c_int(_INPUT_8.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    # step   7 kT,SWk->TSW
    offset_now       = offset_4        
    _M14_offset      = offset_now      
    _M14             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M14_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_11_reshaped.T, _M2_reshaped.T, c=_M14_reshaped)
    _M14             = _M14_reshaped.reshape(*shape_backup)
    # step   8 bP,bV->PVb
    offset_now       = offset_3        
    _M1_offset       = offset_now      
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M1_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    # step   9 bR,PVb->RPV
    offset_now       = offset_5        
    _M6_offset       = offset_now      
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M6_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_7_reshaped.T, _M1_reshaped.T, c=_M6_reshaped)
    _M6              = _M6_reshaped.reshape(*shape_backup)
    # step  10 start for loop with indices ('V',)
    for V_0, V_1 in lib.prange(0,N_LAPLACE,V_bunchsize):
        # step  11 start for loop with indices ('V', 'W')
        for W_0, W_1 in lib.prange(0,N_LAPLACE,W_bunchsize):
            # step  12 slice _INPUT_17 with indices ['V']
            _INPUT_17_sliced_offset = offset_3        
            _INPUT_17_sliced = np.ndarray((NVIR, (V_1-V_0)), buffer = buffer, offset = _INPUT_17_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_17.ctypes.data),
                         ctypes.c_void_p(_INPUT_17_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_17.shape[0]),
                         ctypes.c_int(_INPUT_17.shape[1]),
                         ctypes.c_int(V_0),
                         ctypes.c_int(V_1))
            # step  13 slice _INPUT_21 with indices ['W']
            _INPUT_21_sliced_offset = offset_6        
            _INPUT_21_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_21_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_21.ctypes.data),
                         ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_21.shape[0]),
                         ctypes.c_int(_INPUT_21.shape[1]),
                         ctypes.c_int(W_0),
                         ctypes.c_int(W_1))
            # step  14 aV,aW->VWa
            offset_now       = offset_7        
            _M4_offset       = offset_now      
            _M4              = np.ndarray(((V_1-V_0), (W_1-W_0), NVIR), buffer = buffer, offset = _M4_offset)
            fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_17_sliced.ctypes.data),
                                         ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                                         ctypes.c_void_p(_M4.ctypes.data),
                                         ctypes.c_int(_INPUT_17_sliced.shape[0]),
                                         ctypes.c_int(_INPUT_17_sliced.shape[1]),
                                         ctypes.c_int(_INPUT_21_sliced.shape[1]))
            # step  15 start for loop with indices ('V', 'W', 'P')
            for P_0, P_1 in lib.prange(P_begin,P_end,P_bunchsize):
                # step  16 slice _INPUT_19 with indices ['W']
                _INPUT_19_sliced_offset = offset_3        
                _INPUT_19_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_19_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_19.ctypes.data),
                             ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_19.shape[0]),
                             ctypes.c_int(_INPUT_19.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  17 slice _M0 with indices ['P', 'V']
                _M0_sliced_offset = offset_6        
                _M0_sliced       = np.ndarray(((P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M0_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M0.ctypes.data),
                               ctypes.c_void_p(_M0_sliced.ctypes.data),
                               ctypes.c_int(_M0.shape[0]),
                               ctypes.c_int(_M0.shape[1]),
                               ctypes.c_int(_M0.shape[2]),
                               ctypes.c_int(P_0),
                               ctypes.c_int(P_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  18 iW,PVi->WPVi
                offset_now       = offset_8        
                _M5_offset       = offset_now      
                _M5              = np.ndarray(((W_1-W_0), (P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M5_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                                               ctypes.c_void_p(_M0_sliced.ctypes.data),
                                               ctypes.c_void_p(_M5.ctypes.data),
                                               ctypes.c_int(_INPUT_19_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_19_sliced.shape[1]),
                                               ctypes.c_int(_M0_sliced.shape[0]),
                                               ctypes.c_int(_M0_sliced.shape[1]))
                # step  19 iU,WPVi->UWPV
                offset_now       = offset_3        
                _M18_offset      = offset_now      
                _M18             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M18_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
                _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M5.shape[0]
                _size_dim_1      = _size_dim_1 * _M5.shape[1]
                _size_dim_1      = _size_dim_1 * _M5.shape[2]
                _M5_reshaped = _M5.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M18.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M18.shape[0]
                _M18_reshaped = _M18.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_13_reshaped.T, _M5_reshaped.T, c=_M18_reshaped)
                _M18             = _M18_reshaped.reshape(*shape_backup)
                # step  20 start for loop with indices ('V', 'W', 'P', 'S')
                for S_0, S_1 in lib.prange(0,NTHC_INT,S_bunchsize):
                    # step  21 slice _INPUT_5 with indices ['S']
                    _INPUT_5_sliced_offset = offset_6        
                    _INPUT_5_sliced  = np.ndarray((NTHC_INT, (S_1-S_0)), buffer = buffer, offset = _INPUT_5_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                 ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_5.shape[0]),
                                 ctypes.c_int(_INPUT_5.shape[1]),
                                 ctypes.c_int(S_0),
                                 ctypes.c_int(S_1))
                    # step  22 slice _M6 with indices ['P', 'V']
                    _M6_sliced_offset = offset_8        
                    _M6_sliced       = np.ndarray((NTHC_INT, (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M6_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                   ctypes.c_int(_M6.shape[0]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]),
                                   ctypes.c_int(P_0),
                                   ctypes.c_int(P_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  23 RS,RPV->SPVR
                    offset_now       = offset_9        
                    _M7_offset       = offset_now      
                    _M7              = np.ndarray(((S_1-S_0), (P_1-P_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M7_offset)
                    fn_contraction_01_023_1230_wob(ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M7.ctypes.data),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[2]))
                    # step  24 jR,SPVR->jSPV
                    offset_now       = offset_6        
                    _M8_offset       = offset_now      
                    _M8              = np.ndarray((NOCC, (S_1-S_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M8_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
                    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M7.shape[0]
                    _size_dim_1      = _size_dim_1 * _M7.shape[1]
                    _size_dim_1      = _size_dim_1 * _M7.shape[2]
                    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M8.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M8.shape[0]
                    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_6_reshaped, _M7_reshaped.T, c=_M8_reshaped)
                    _M8              = _M8_reshaped.reshape(*shape_backup)
                    # step  25 slice _INPUT_16 with indices ['V']
                    _INPUT_16_sliced_offset = offset_8        
                    _INPUT_16_sliced = np.ndarray((NOCC, (V_1-V_0)), buffer = buffer, offset = _INPUT_16_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_16.shape[0]),
                                 ctypes.c_int(_INPUT_16.shape[1]),
                                 ctypes.c_int(V_0),
                                 ctypes.c_int(V_1))
                    # step  26 jV,jSPV->SPjV
                    offset_now       = offset_9        
                    _M9_offset       = offset_now      
                    _M9              = np.ndarray(((S_1-S_0), (P_1-P_0), NOCC, (V_1-V_0)), buffer = buffer, offset = _M9_offset)
                    fn_contraction_01_0231_2301_wob(ctypes.c_void_p(_INPUT_16_sliced.ctypes.data),
                                                    ctypes.c_void_p(_M8.ctypes.data),
                                                    ctypes.c_void_p(_M9.ctypes.data),
                                                    ctypes.c_int(_INPUT_16_sliced.shape[0]),
                                                    ctypes.c_int(_INPUT_16_sliced.shape[1]),
                                                    ctypes.c_int(_M8.shape[1]),
                                                    ctypes.c_int(_M8.shape[2]))
                    # step  27 SPjV->SPVj
                    _M9_perm_offset  = offset_6        
                    _M9_perm         = np.ndarray(((S_1-S_0), (P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M9_perm_offset)
                    fn_permutation_0123_0132_wob(ctypes.c_void_p(_M9.ctypes.data),
                                                 ctypes.c_void_p(_M9_perm.ctypes.data),
                                                 ctypes.c_int((S_1-S_0)),
                                                 ctypes.c_int((P_1-P_0)),
                                                 ctypes.c_int(NOCC),
                                                 ctypes.c_int((V_1-V_0)))
                    # step  28 jQ,SPVj->QSPV
                    offset_now       = offset_8        
                    _M10_offset      = offset_now      
                    _M10             = np.ndarray((NTHC_INT, (S_1-S_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M10_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
                    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M9_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M9_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M9_perm.shape[2]
                    _M9_perm_reshaped = _M9_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M10.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M10.shape[0]
                    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_3_reshaped.T, _M9_perm_reshaped.T, c=_M10_reshaped)
                    _M10             = _M10_reshaped.reshape(*shape_backup)
                    # step  29 slice _INPUT_0 with indices ['P']
                    _INPUT_0_sliced_offset = offset_6        
                    _INPUT_0_sliced  = np.ndarray(((P_1-P_0), NTHC_INT), buffer = buffer, offset = _INPUT_0_sliced_offset)
                    fn_slice_2_0(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                 ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_0.shape[0]),
                                 ctypes.c_int(_INPUT_0.shape[1]),
                                 ctypes.c_int(P_0),
                                 ctypes.c_int(P_1))
                    # step  30 PQ,QSPV->SVPQ
                    offset_now       = offset_9        
                    _M11_offset      = offset_now      
                    _M11             = np.ndarray(((S_1-S_0), (V_1-V_0), (P_1-P_0), NTHC_INT), buffer = buffer, offset = _M11_offset)
                    fn_contraction_01_1203_2301_wob(ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                                    ctypes.c_void_p(_M10.ctypes.data),
                                                    ctypes.c_void_p(_M11.ctypes.data),
                                                    ctypes.c_int(_INPUT_0_sliced.shape[0]),
                                                    ctypes.c_int(_INPUT_0_sliced.shape[1]),
                                                    ctypes.c_int(_M10.shape[1]),
                                                    ctypes.c_int(_M10.shape[3]))
                    # step  31 aQ,SVPQ->aSVP
                    offset_now       = offset_6        
                    _M12_offset      = offset_now      
                    _M12             = np.ndarray((NVIR, (S_1-S_0), (V_1-V_0), (P_1-P_0)), buffer = buffer, offset = _M12_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
                    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M11.shape[0]
                    _size_dim_1      = _size_dim_1 * _M11.shape[1]
                    _size_dim_1      = _size_dim_1 * _M11.shape[2]
                    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M12.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M12.shape[0]
                    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_4_reshaped, _M11_reshaped.T, c=_M12_reshaped)
                    _M12             = _M12_reshaped.reshape(*shape_backup)
                    # step  32 VWa,aSVP->WSPVa
                    offset_now       = offset_8        
                    _M13_offset      = offset_now      
                    _M13             = np.ndarray(((W_1-W_0), (S_1-S_0), (P_1-P_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M13_offset)
                    fn_contraction_012_2304_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                                      ctypes.c_void_p(_M12.ctypes.data),
                                                      ctypes.c_void_p(_M13.ctypes.data),
                                                      ctypes.c_int(_M4.shape[0]),
                                                      ctypes.c_int(_M4.shape[1]),
                                                      ctypes.c_int(_M4.shape[2]),
                                                      ctypes.c_int(_M12.shape[1]),
                                                      ctypes.c_int(_M12.shape[3]))
                    # step  33 aT,WSPVa->TWSPV
                    offset_now       = offset_6        
                    _M15_offset      = offset_now      
                    _M15             = np.ndarray((NTHC_INT, (W_1-W_0), (S_1-S_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M15_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
                    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M13.shape[0]
                    _size_dim_1      = _size_dim_1 * _M13.shape[1]
                    _size_dim_1      = _size_dim_1 * _M13.shape[2]
                    _size_dim_1      = _size_dim_1 * _M13.shape[3]
                    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M15.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M15.shape[0]
                    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_12_reshaped.T, _M13_reshaped.T, c=_M15_reshaped)
                    _M15             = _M15_reshaped.reshape(*shape_backup)
                    # step  34 slice _M14 with indices ['S', 'W']
                    _M14_sliced_offset = offset_8        
                    _M14_sliced      = np.ndarray((NTHC_INT, (S_1-S_0), (W_1-W_0)), buffer = buffer, offset = _M14_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M14.ctypes.data),
                                   ctypes.c_void_p(_M14_sliced.ctypes.data),
                                   ctypes.c_int(_M14.shape[0]),
                                   ctypes.c_int(_M14.shape[1]),
                                   ctypes.c_int(_M14.shape[2]),
                                   ctypes.c_int(S_0),
                                   ctypes.c_int(S_1),
                                   ctypes.c_int(W_0),
                                   ctypes.c_int(W_1))
                    # step  35 TSW,TWSPV->PVTSW
                    offset_now       = offset_9        
                    _M16_offset      = offset_now      
                    _M16             = np.ndarray(((P_1-P_0), (V_1-V_0), NTHC_INT, (S_1-S_0), (W_1-W_0)), buffer = buffer, offset = _M16_offset)
                    fn_contraction_012_02134_34012_wob(ctypes.c_void_p(_M14_sliced.ctypes.data),
                                                       ctypes.c_void_p(_M15.ctypes.data),
                                                       ctypes.c_void_p(_M16.ctypes.data),
                                                       ctypes.c_int(_M14_sliced.shape[0]),
                                                       ctypes.c_int(_M14_sliced.shape[1]),
                                                       ctypes.c_int(_M14_sliced.shape[2]),
                                                       ctypes.c_int(_M15.shape[3]),
                                                       ctypes.c_int(_M15.shape[4]))
                    # step  36 PVTSW->PVSWT
                    _M16_perm_offset = offset_6        
                    _M16_perm        = np.ndarray(((P_1-P_0), (V_1-V_0), (S_1-S_0), (W_1-W_0), NTHC_INT), buffer = buffer, offset = _M16_perm_offset)
                    fn_permutation_01234_01342_wob(ctypes.c_void_p(_M16.ctypes.data),
                                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((V_1-V_0)),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((S_1-S_0)),
                                                   ctypes.c_int((W_1-W_0)))
                    # step  37 TU,PVSWT->UPVSW
                    offset_now       = offset_8        
                    _M17_offset      = offset_now      
                    _M17             = np.ndarray((NTHC_INT, (P_1-P_0), (V_1-V_0), (S_1-S_0), (W_1-W_0)), buffer = buffer, offset = _M17_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
                    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
                    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M17.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M17.shape[0]
                    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
                    _M17             = _M17_reshaped.reshape(*shape_backup)
                    # step  38 UPVSW->UWSPV
                    _M17_perm_offset = offset_6        
                    _M17_perm        = np.ndarray((NTHC_INT, (W_1-W_0), (S_1-S_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M17_perm_offset)
                    fn_permutation_01234_04312_wob(ctypes.c_void_p(_M17.ctypes.data),
                                                   ctypes.c_void_p(_M17_perm.ctypes.data),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((V_1-V_0)),
                                                   ctypes.c_int((S_1-S_0)),
                                                   ctypes.c_int((W_1-W_0)))
                    # step  39 UWSPV,UWPV->UWS
                    offset_now       = offset_9        
                    _M19_packed_offset = offset_now      
                    _M19_packed      = np.ndarray((NTHC_INT, (W_1-W_0), (S_1-S_0)), buffer = buffer, offset = _M19_packed_offset)
                    fn_contraction_01234_0134_012_wob(ctypes.c_void_p(_M17_perm.ctypes.data),
                                                      ctypes.c_void_p(_M18.ctypes.data),
                                                      ctypes.c_void_p(_M19_packed.ctypes.data),
                                                      ctypes.c_int(_M17_perm.shape[0]),
                                                      ctypes.c_int(_M17_perm.shape[1]),
                                                      ctypes.c_int(_M17_perm.shape[2]),
                                                      ctypes.c_int(_M17_perm.shape[3]),
                                                      ctypes.c_int(_M17_perm.shape[4]))
                    # step  40 pack  _M19 with indices ['W', 'S']
                    fn_packadd_3_1_2(ctypes.c_void_p(_M19.ctypes.data),
                                     ctypes.c_void_p(_M19_packed.ctypes.data),
                                     ctypes.c_int(_M19.shape[0]),
                                     ctypes.c_int(_M19.shape[1]),
                                     ctypes.c_int(_M19.shape[2]),
                                     ctypes.c_int(W_0),
                                     ctypes.c_int(W_1),
                                     ctypes.c_int(S_0),
                                     ctypes.c_int(S_1))
                # step  41 end   for loop with indices ('V', 'W', 'P', 'S')
                # step  42 deallocate ['_M18']
            # step  43 end   for loop with indices ('V', 'W', 'P')
            # step  44 deallocate ['_M4']
        # step  45 end   for loop with indices ('V', 'W')
    # step  46 end   for loop with indices ('V',)
    # step  47 deallocate ['_M0', '_M14', '_M6']
    # step  48 UWS,UWS->
    output_tmp       = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20_perm.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(output_tmp))
    _M21 = output_tmp.value
    # clean the final forloop
    # MPI finalize
    if use_mpi:
        _M21 = reduce(_M21, root=0)
        _M21 = bcast(_M21, root=0)
    return _M21

def RMP3_XX_3_forloop_P_S_determine_bucket_size_forloop(NVIR        : int,
                                                        NOCC        : int,
                                                        N_LAPLACE   : int,
                                                        NTHC_INT    : int,
                                                        P_bunchsize = 8,
                                                        S_bunchsize = 8,
                                                        V_bunchsize = 1,
                                                        W_bunchsize = 1):
    # init
    output = []     
    bucked_0_size    = 0               
    bucked_1_size    = 0               
    bucked_2_size    = 0               
    bucked_3_size    = 0               
    bucked_4_size    = 0               
    bucked_5_size    = 0               
    bucked_6_size    = 0               
    bucked_7_size    = 0               
    bucked_8_size    = 0               
    bucked_9_size    = 0               
    bucked_10_size   = 0               
    # assign the size of each tensor
    _M3_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M19_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M20_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M0_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M1_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M2_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _INPUT_16_sliced_size = (NOCC * N_LAPLACE)
    _INPUT_19_sliced_size = (NOCC * N_LAPLACE)
    _M14_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize)))
    _M10_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M6_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _INPUT_20_sliced_size = (NOCC * N_LAPLACE)
    _M0_sliced_size  = (P_bunchsize * (V_bunchsize * NOCC))
    _INPUT_5_sliced_size = (NTHC_INT * NTHC_INT)
    _M12_size        = (NVIR * (S_bunchsize * (P_bunchsize * V_bunchsize)))
    _M15_size        = (NTHC_INT * (W_bunchsize * (S_bunchsize * (P_bunchsize * V_bunchsize))))
    _M16_perm_size   = (S_bunchsize * (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize))))
    _INPUT_0_sliced_size = (NTHC_INT * NTHC_INT)
    _M8_size         = (NOCC * (P_bunchsize * (S_bunchsize * V_bunchsize)))
    _M18_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * (S_bunchsize * V_bunchsize))))
    _M4_size         = (V_bunchsize * (W_bunchsize * NOCC))
    _M5_size         = (W_bunchsize * (P_bunchsize * (V_bunchsize * NOCC)))
    _M10_sliced_size = (NTHC_INT * (P_bunchsize * V_bunchsize))
    _INPUT_21_sliced_size = (NVIR * N_LAPLACE)
    _M16_size        = (S_bunchsize * (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize))))
    _M17_size        = (NTHC_INT * (S_bunchsize * (W_bunchsize * (P_bunchsize * V_bunchsize))))
    _M11_size        = (S_bunchsize * (P_bunchsize * (V_bunchsize * NTHC_INT)))
    _M13_size        = (W_bunchsize * (S_bunchsize * (P_bunchsize * (V_bunchsize * NVIR))))
    _M6_sliced_size  = (NTHC_INT * (S_bunchsize * V_bunchsize))
    _M9_size         = (W_bunchsize * (P_bunchsize * (S_bunchsize * (V_bunchsize * NOCC))))
    _M18_perm_size   = (NTHC_INT * (W_bunchsize * (P_bunchsize * (S_bunchsize * V_bunchsize))))
    _M7_size         = (P_bunchsize * (S_bunchsize * (V_bunchsize * NTHC_INT)))
    _M19_packed_size = (NTHC_INT * (S_bunchsize * W_bunchsize))
    # determine the size of each bucket
    # bucket 0
    bucked_0_size    = max(bucked_0_size, _M3_size)
    bucked_0_size    = max(bucked_0_size, _M19_size)
    # bucket 1
    bucked_1_size    = max(bucked_1_size, _M20_size)
    # bucket 2
    bucked_2_size    = max(bucked_2_size, _M0_size)
    # bucket 3
    bucked_3_size    = max(bucked_3_size, _M1_size)
    bucked_3_size    = max(bucked_3_size, _M2_size)
    bucked_3_size    = max(bucked_3_size, _INPUT_16_sliced_size)
    bucked_3_size    = max(bucked_3_size, _INPUT_19_sliced_size)
    bucked_3_size    = max(bucked_3_size, _M14_size)
    # bucket 4
    bucked_4_size    = max(bucked_4_size, _M10_size)
    # bucket 5
    bucked_5_size    = max(bucked_5_size, _M6_size)
    # bucket 6
    bucked_6_size    = max(bucked_6_size, _INPUT_20_sliced_size)
    bucked_6_size    = max(bucked_6_size, _M0_sliced_size)
    bucked_6_size    = max(bucked_6_size, _INPUT_5_sliced_size)
    bucked_6_size    = max(bucked_6_size, _M12_size)
    bucked_6_size    = max(bucked_6_size, _M15_size)
    bucked_6_size    = max(bucked_6_size, _M16_perm_size)
    bucked_6_size    = max(bucked_6_size, _INPUT_0_sliced_size)
    bucked_6_size    = max(bucked_6_size, _M8_size)
    bucked_6_size    = max(bucked_6_size, _M18_size)
    # bucket 7
    bucked_7_size    = max(bucked_7_size, _M4_size)
    # bucket 8
    bucked_8_size    = max(bucked_8_size, _M5_size)
    bucked_8_size    = max(bucked_8_size, _M10_sliced_size)
    bucked_8_size    = max(bucked_8_size, _INPUT_21_sliced_size)
    bucked_8_size    = max(bucked_8_size, _M16_size)
    bucked_8_size    = max(bucked_8_size, _M17_size)
    # bucket 9
    bucked_9_size    = max(bucked_9_size, _M11_size)
    bucked_9_size    = max(bucked_9_size, _M13_size)
    bucked_9_size    = max(bucked_9_size, _M6_sliced_size)
    bucked_9_size    = max(bucked_9_size, _M9_size)
    bucked_9_size    = max(bucked_9_size, _M18_perm_size)
    # bucket 10
    bucked_10_size   = max(bucked_10_size, _M7_size)
    bucked_10_size   = max(bucked_10_size, _M19_packed_size)
    # append each bucket size to the output
    output.append(bucked_0_size)
    output.append(bucked_1_size)
    output.append(bucked_2_size)
    output.append(bucked_3_size)
    output.append(bucked_4_size)
    output.append(bucked_5_size)
    output.append(bucked_6_size)
    output.append(bucked_7_size)
    output.append(bucked_8_size)
    output.append(bucked_9_size)
    output.append(bucked_10_size)
    return output

def RMP3_XX_3_forloop_P_S_naive(Z           : np.ndarray,
                                X_o         : np.ndarray,
                                X_v         : np.ndarray,
                                tau_o       : np.ndarray,
                                tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_v             
    _INPUT_7         = X_v             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    t1 = (logger.process_clock(), logger.perf_counter())
    _M3              = np.einsum("dS,dW->SWd"    , _INPUT_9        , _INPUT_22       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.einsum("dU,SWd->USW"   , _INPUT_14       , _M3             )
    del _M3         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M0              = np.einsum("iP,iV->PVi"    , _INPUT_1        , _INPUT_15       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M1              = np.einsum("aP,aV->PVa"    , _INPUT_2        , _INPUT_17       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.einsum("aR,PVa->RPV"   , _INPUT_6        , _M1             )
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M2              = np.einsum("bS,bV->SVb"    , _INPUT_8        , _INPUT_18       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.einsum("bQ,SVb->QSV"   , _INPUT_4        , _M2             )
    del _M2         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M4              = np.einsum("jV,jW->VWj"    , _INPUT_16       , _INPUT_20       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M5              = np.einsum("iW,PVi->WPVi"  , _INPUT_19       , _M0             )
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.einsum("iT,WPVi->TWPV" , _INPUT_11       , _M5             )
    del _M5         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11             = np.einsum("RS,RPV->SPVR"  , _INPUT_5        , _M10            )
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.einsum("cR,SPVR->cSPV" , _INPUT_7        , _M11            )
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M13             = np.einsum("cW,cSPV->WSPVc", _INPUT_21       , _M12            )
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.einsum("cT,WSPVc->TWSPV", _INPUT_12       , _M13            )
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.einsum("TWPV,TWSPV->STWPV", _M14            , _M15            )
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16_perm        = np.transpose(_M16            , (0, 2, 3, 4, 1) )
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.einsum("TU,SWPVT->USWPV", _INPUT_10       , _M16_perm       )
    del _M16_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.einsum("PQ,QSV->PSVQ"  , _INPUT_0        , _M6             )
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.einsum("jQ,PSVQ->jPSV" , _INPUT_3        , _M7             )
    del _M7         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9              = np.einsum("VWj,jPSV->WPSVj", _M4             , _M8             )
    del _M4         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.einsum("jU,WPSVj->UWPSV", _INPUT_13       , _M9             )
    del _M9         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18_perm        = np.transpose(_M18            , (0, 3, 1, 2, 4) )
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M19             = np.einsum("USWPV,USWPV->USW", _M17            , _M18_perm       )
    del _M17        
    del _M18_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M21             = np.einsum("USW,USW->"     , _M19            , _M20            )
    del _M19        
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    return _M21

def RMP3_XX_3_forloop_P_S(Z           : np.ndarray,
                          X_o         : np.ndarray,
                          X_v         : np.ndarray,
                          tau_o       : np.ndarray,
                          tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_v             
    _INPUT_7         = X_v             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # step 0 dS,dW->SWd 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_9.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_9.shape[0]),
                                 ctypes.c_int(_INPUT_9.shape[1]),
                                 ctypes.c_int(_INPUT_22.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    # step 1 dU,SWd->USW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_14_reshaped.T, _M3_reshaped.T, c=_M20_reshaped)
    _M20         = _M20_reshaped.reshape(*shape_backup)
    del _M3         
    del _M3_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    # step 2 iP,iV->PVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    # step 3 aP,aV->PVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    # step 4 aR,PVa->RPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_6_reshaped.T, _M1_reshaped.T, c=_M10_reshaped)
    _M10         = _M10_reshaped.reshape(*shape_backup)
    del _M1         
    del _M1_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    # step 5 bS,bV->SVb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_8.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_8.shape[0]),
                                 ctypes.c_int(_INPUT_8.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    # step 6 bQ,SVb->QSV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_4_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6          = _M6_reshaped.reshape(*shape_backup)
    del _M2         
    del _M2_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    # step 7 jV,jW->VWj 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M4              = np.ndarray((N_LAPLACE, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M4.ctypes.data),
                                 ctypes.c_int(_INPUT_16.shape[0]),
                                 ctypes.c_int(_INPUT_16.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    # step 8 iW,PVi->WPVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M5              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19.ctypes.data),
                                   ctypes.c_void_p(_M0.ctypes.data),
                                   ctypes.c_void_p(_M5.ctypes.data),
                                   ctypes.c_int(_INPUT_19.shape[0]),
                                   ctypes.c_int(_INPUT_19.shape[1]),
                                   ctypes.c_int(_M0.shape[0]),
                                   ctypes.c_int(_M0.shape[1]))
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    # step 9 iT,WPVi->TWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M5.shape[0]
    _size_dim_1      = _size_dim_1 * _M5.shape[1]
    _size_dim_1      = _size_dim_1 * _M5.shape[2]
    _M5_reshaped = _M5.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_11_reshaped.T, _M5_reshaped.T, c=_M14_reshaped)
    _M14         = _M14_reshaped.reshape(*shape_backup)
    del _M5         
    del _M5_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    # step 10 RS,RPV->SPVR 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_023_1230_wob = getattr(libpbc, "fn_contraction_01_023_1230_wob", None)
    assert fn_contraction_01_023_1230_wob is not None
    _M11             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_023_1230_wob(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                   ctypes.c_void_p(_M10.ctypes.data),
                                   ctypes.c_void_p(_M11.ctypes.data),
                                   ctypes.c_int(_INPUT_5.shape[0]),
                                   ctypes.c_int(_INPUT_5.shape[1]),
                                   ctypes.c_int(_M10.shape[1]),
                                   ctypes.c_int(_M10.shape[2]))
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    # step 11 cR,SPVR->cSPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.ndarray((NVIR, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M11.shape[0]
    _size_dim_1      = _size_dim_1 * _M11.shape[1]
    _size_dim_1      = _size_dim_1 * _M11.shape[2]
    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M12.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M12.shape[0]
    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_7_reshaped, _M11_reshaped.T, c=_M12_reshaped)
    _M12         = _M12_reshaped.reshape(*shape_backup)
    del _M11        
    del _M11_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    # step 12 cW,cSPV->WSPVc 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    _M13             = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_21.ctypes.data),
                                     ctypes.c_void_p(_M12.ctypes.data),
                                     ctypes.c_void_p(_M13.ctypes.data),
                                     ctypes.c_int(_INPUT_21.shape[0]),
                                     ctypes.c_int(_INPUT_21.shape[1]),
                                     ctypes.c_int(_M12.shape[1]),
                                     ctypes.c_int(_M12.shape[2]),
                                     ctypes.c_int(_M12.shape[3]))
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    # step 13 cT,WSPVc->TWSPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M13.shape[0]
    _size_dim_1      = _size_dim_1 * _M13.shape[1]
    _size_dim_1      = _size_dim_1 * _M13.shape[2]
    _size_dim_1      = _size_dim_1 * _M13.shape[3]
    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M15.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M15.shape[0]
    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_12_reshaped.T, _M13_reshaped.T, c=_M15_reshaped)
    _M15         = _M15_reshaped.reshape(*shape_backup)
    del _M13        
    del _M13_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    # step 14 TWPV,TWSPV->STWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_0123_01423_40123_wob = getattr(libpbc, "fn_contraction_0123_01423_40123_wob", None)
    assert fn_contraction_0123_01423_40123_wob is not None
    _M16             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_0123_01423_40123_wob(ctypes.c_void_p(_M14.ctypes.data),
                                        ctypes.c_void_p(_M15.ctypes.data),
                                        ctypes.c_void_p(_M16.ctypes.data),
                                        ctypes.c_int(_M14.shape[0]),
                                        ctypes.c_int(_M14.shape[1]),
                                        ctypes.c_int(_M14.shape[2]),
                                        ctypes.c_int(_M14.shape[3]),
                                        ctypes.c_int(_M15.shape[2]))
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    # step 15 STWPV->SWPVT 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_02341_wob = getattr(libpbc, "fn_permutation_01234_02341_wob", None)
    assert fn_permutation_01234_02341_wob is not None
    _M16_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_02341_wob(ctypes.c_void_p(_M16.ctypes.data),
                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                   ctypes.c_int(_M16.shape[0]),
                                   ctypes.c_int(_M16.shape[1]),
                                   ctypes.c_int(_M16.shape[2]),
                                   ctypes.c_int(_M16.shape[3]),
                                   ctypes.c_int(_M16.shape[4]))
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    # step 16 TU,SWPVT->USWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M17.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M17.shape[0]
    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
    _M17         = _M17_reshaped.reshape(*shape_backup)
    del _M16_perm   
    del _M16_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    # step 17 PQ,QSV->PSVQ 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                   ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M7.ctypes.data),
                                   ctypes.c_int(_INPUT_0.shape[0]),
                                   ctypes.c_int(_INPUT_0.shape[1]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]))
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    # step 18 jQ,PSVQ->jPSV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.ndarray((NOCC, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _size_dim_1      = _size_dim_1 * _M7.shape[1]
    _size_dim_1      = _size_dim_1 * _M7.shape[2]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M8.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M8.shape[0]
    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped, _M7_reshaped.T, c=_M8_reshaped)
    _M8          = _M8_reshaped.reshape(*shape_backup)
    del _M7         
    del _M7_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    # step 19 VWj,jPSV->WPSVj 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_2340_13402_wob = getattr(libpbc, "fn_contraction_012_2340_13402_wob", None)
    assert fn_contraction_012_2340_13402_wob is not None
    _M9              = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_012_2340_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                      ctypes.c_void_p(_M8.ctypes.data),
                                      ctypes.c_void_p(_M9.ctypes.data),
                                      ctypes.c_int(_M4.shape[0]),
                                      ctypes.c_int(_M4.shape[1]),
                                      ctypes.c_int(_M4.shape[2]),
                                      ctypes.c_int(_M8.shape[1]),
                                      ctypes.c_int(_M8.shape[2]))
    del _M4         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    # step 20 jU,WPSVj->UWPSV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M9.shape[0]
    _size_dim_1      = _size_dim_1 * _M9.shape[1]
    _size_dim_1      = _size_dim_1 * _M9.shape[2]
    _size_dim_1      = _size_dim_1 * _M9.shape[3]
    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_13_reshaped.T, _M9_reshaped.T, c=_M18_reshaped)
    _M18         = _M18_reshaped.reshape(*shape_backup)
    del _M9         
    del _M9_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    # step 21 UWPSV->USWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_03124_wob = getattr(libpbc, "fn_permutation_01234_03124_wob", None)
    assert fn_permutation_01234_03124_wob is not None
    _M18_perm        = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_permutation_01234_03124_wob(ctypes.c_void_p(_M18.ctypes.data),
                                   ctypes.c_void_p(_M18_perm.ctypes.data),
                                   ctypes.c_int(_M18.shape[0]),
                                   ctypes.c_int(_M18.shape[1]),
                                   ctypes.c_int(_M18.shape[2]),
                                   ctypes.c_int(_M18.shape[3]),
                                   ctypes.c_int(_M18.shape[4]))
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    # step 22 USWPV,USWPV->USW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01234_01234_012_wob = getattr(libpbc, "fn_contraction_01234_01234_012_wob", None)
    assert fn_contraction_01234_01234_012_wob is not None
    _M19             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_01234_01234_012_wob(ctypes.c_void_p(_M17.ctypes.data),
                                       ctypes.c_void_p(_M18_perm.ctypes.data),
                                       ctypes.c_void_p(_M19.ctypes.data),
                                       ctypes.c_int(_M17.shape[0]),
                                       ctypes.c_int(_M17.shape[1]),
                                       ctypes.c_int(_M17.shape[2]),
                                       ctypes.c_int(_M17.shape[3]),
                                       ctypes.c_int(_M17.shape[4]))
    del _M17        
    del _M18_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    # step 23 USW,USW-> 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    _M21             = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(_M21))
    _M21 = _M21.value
    del _M19        
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    return _M21

def RMP3_XX_3_forloop_P_S_forloop_P_S(Z           : np.ndarray,
                                      X_o         : np.ndarray,
                                      X_v         : np.ndarray,
                                      tau_o       : np.ndarray,
                                      tau_v       : np.ndarray,
                                      buffer      : np.ndarray,
                                      P_bunchsize = 8,
                                      S_bunchsize = 8,
                                      V_bunchsize = 1,
                                      W_bunchsize = 1,
                                      use_mpi = False):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_v             
    _INPUT_7         = X_v             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # fetch function pointers
    fn_contraction_01234_01234_012_wob = getattr(libpbc, "fn_contraction_01234_01234_012_wob", None)
    assert fn_contraction_01234_01234_012_wob is not None
    fn_contraction_0123_01423_40123_wob = getattr(libpbc, "fn_contraction_0123_01423_40123_wob", None)
    assert fn_contraction_0123_01423_40123_wob is not None
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    fn_slice_3_1_2 = getattr(libpbc, "fn_slice_3_1_2", None)
    assert fn_slice_3_1_2 is not None
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    fn_packadd_3_1_2 = getattr(libpbc, "fn_packadd_3_1_2", None)
    assert fn_packadd_3_1_2 is not None
    fn_slice_2_1 = getattr(libpbc, "fn_slice_2_1", None)
    assert fn_slice_2_1 is not None
    fn_slice_2_0 = getattr(libpbc, "fn_slice_2_0", None)
    assert fn_slice_2_0 is not None
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    fn_slice_3_0_1 = getattr(libpbc, "fn_slice_3_0_1", None)
    assert fn_slice_3_0_1 is not None
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    fn_contraction_01_023_1230_wob = getattr(libpbc, "fn_contraction_01_023_1230_wob", None)
    assert fn_contraction_01_023_1230_wob is not None
    fn_permutation_01234_02341_wob = getattr(libpbc, "fn_permutation_01234_02341_wob", None)
    assert fn_permutation_01234_02341_wob is not None
    fn_contraction_012_2340_13402_wob = getattr(libpbc, "fn_contraction_012_2340_13402_wob", None)
    assert fn_contraction_012_2340_13402_wob is not None
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    fn_permutation_01234_03124_wob = getattr(libpbc, "fn_permutation_01234_03124_wob", None)
    assert fn_permutation_01234_03124_wob is not None
    if use_mpi:
        bunchsize = NTHC_INT//comm_size + 1
        P_begin = rank*bunchsize
        P_end = (rank+1)*bunchsize
        P_begin          = min(P_begin, NTHC_INT)
        P_end            = min(P_end, NTHC_INT)
    else:
        P_begin          = 0               
        P_end            = NTHC_INT        
    # preallocate buffer
    bucket_size      = RMP3_XX_3_forloop_P_S_determine_bucket_size_forloop(NVIR = NVIR,
                                                                           NOCC = NOCC,
                                                                           N_LAPLACE = N_LAPLACE,
                                                                           NTHC_INT = NTHC_INT,
                                                                           V_bunchsize = V_bunchsize,
                                                                           W_bunchsize = W_bunchsize,
                                                                           P_bunchsize = P_bunchsize,
                                                                           S_bunchsize = S_bunchsize)
    bufsize_now      = buffer.size     
    _itemsize        = buffer.itemsize 
    offset_now       = 0               
    offset_0         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[0])
    offset_1         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[1])
    offset_2         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[2])
    offset_3         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[3])
    offset_4         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[4])
    offset_5         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[5])
    offset_6         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[6])
    offset_7         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[7])
    offset_8         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[8])
    offset_9         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[9])
    offset_10        = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[10])
    bufsize          = offset_now      
    if (bufsize > bufsize_now):
        buffer           = np.ndarray((bufsize), dtype=np.float64)
    # step   0 start for loop with indices ()
    # step   1 dS,dW->SWd
    offset_now       = offset_0        
    _M3_offset       = offset_now      
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M3_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_9.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_9.shape[0]),
                                 ctypes.c_int(_INPUT_9.shape[1]),
                                 ctypes.c_int(_INPUT_22.shape[1]))
    # step   2 dU,SWd->USW
    offset_now       = offset_1        
    _M20_offset      = offset_now      
    _M20             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M20_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_14_reshaped.T, _M3_reshaped.T, c=_M20_reshaped)
    _M20             = _M20_reshaped.reshape(*shape_backup)
    # step   3 allocate   _M19
    offset_now       = offset_0        
    _M19             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = offset_now)
    _M19_offset      = offset_now      
    _M19.ravel()[:] = 0.0
    # step   4 iP,iV->PVi
    offset_now       = offset_2        
    _M0_offset       = offset_now      
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M0_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    # step   5 aP,aV->PVa
    offset_now       = offset_3        
    _M1_offset       = offset_now      
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M1_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    # step   6 aR,PVa->RPV
    offset_now       = offset_4        
    _M10_offset      = offset_now      
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M10_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_6_reshaped.T, _M1_reshaped.T, c=_M10_reshaped)
    _M10             = _M10_reshaped.reshape(*shape_backup)
    # step   7 bS,bV->SVb
    offset_now       = offset_3        
    _M2_offset       = offset_now      
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M2_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_8.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_8.shape[0]),
                                 ctypes.c_int(_INPUT_8.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    # step   8 bQ,SVb->QSV
    offset_now       = offset_5        
    _M6_offset       = offset_now      
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M6_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_4_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6              = _M6_reshaped.reshape(*shape_backup)
    # step   9 start for loop with indices ('V',)
    for V_0, V_1 in lib.prange(0,N_LAPLACE,V_bunchsize):
        # step  10 start for loop with indices ('V', 'W')
        for W_0, W_1 in lib.prange(0,N_LAPLACE,W_bunchsize):
            # step  11 slice _INPUT_16 with indices ['V']
            _INPUT_16_sliced_offset = offset_3        
            _INPUT_16_sliced = np.ndarray((NOCC, (V_1-V_0)), buffer = buffer, offset = _INPUT_16_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_16.ctypes.data),
                         ctypes.c_void_p(_INPUT_16_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_16.shape[0]),
                         ctypes.c_int(_INPUT_16.shape[1]),
                         ctypes.c_int(V_0),
                         ctypes.c_int(V_1))
            # step  12 slice _INPUT_20 with indices ['W']
            _INPUT_20_sliced_offset = offset_6        
            _INPUT_20_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_20_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_20.ctypes.data),
                         ctypes.c_void_p(_INPUT_20_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_20.shape[0]),
                         ctypes.c_int(_INPUT_20.shape[1]),
                         ctypes.c_int(W_0),
                         ctypes.c_int(W_1))
            # step  13 jV,jW->VWj
            offset_now       = offset_7        
            _M4_offset       = offset_now      
            _M4              = np.ndarray(((V_1-V_0), (W_1-W_0), NOCC), buffer = buffer, offset = _M4_offset)
            fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_16_sliced.ctypes.data),
                                         ctypes.c_void_p(_INPUT_20_sliced.ctypes.data),
                                         ctypes.c_void_p(_M4.ctypes.data),
                                         ctypes.c_int(_INPUT_16_sliced.shape[0]),
                                         ctypes.c_int(_INPUT_16_sliced.shape[1]),
                                         ctypes.c_int(_INPUT_20_sliced.shape[1]))
            # step  14 start for loop with indices ('V', 'W', 'P')
            for P_0, P_1 in lib.prange(P_begin,P_end,P_bunchsize):
                # step  15 slice _INPUT_19 with indices ['W']
                _INPUT_19_sliced_offset = offset_3        
                _INPUT_19_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_19_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_19.ctypes.data),
                             ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_19.shape[0]),
                             ctypes.c_int(_INPUT_19.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  16 slice _M0 with indices ['P', 'V']
                _M0_sliced_offset = offset_6        
                _M0_sliced       = np.ndarray(((P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M0_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M0.ctypes.data),
                               ctypes.c_void_p(_M0_sliced.ctypes.data),
                               ctypes.c_int(_M0.shape[0]),
                               ctypes.c_int(_M0.shape[1]),
                               ctypes.c_int(_M0.shape[2]),
                               ctypes.c_int(P_0),
                               ctypes.c_int(P_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  17 iW,PVi->WPVi
                offset_now       = offset_8        
                _M5_offset       = offset_now      
                _M5              = np.ndarray(((W_1-W_0), (P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M5_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                                               ctypes.c_void_p(_M0_sliced.ctypes.data),
                                               ctypes.c_void_p(_M5.ctypes.data),
                                               ctypes.c_int(_INPUT_19_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_19_sliced.shape[1]),
                                               ctypes.c_int(_M0_sliced.shape[0]),
                                               ctypes.c_int(_M0_sliced.shape[1]))
                # step  18 iT,WPVi->TWPV
                offset_now       = offset_3        
                _M14_offset      = offset_now      
                _M14             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M14_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
                _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M5.shape[0]
                _size_dim_1      = _size_dim_1 * _M5.shape[1]
                _size_dim_1      = _size_dim_1 * _M5.shape[2]
                _M5_reshaped = _M5.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M14.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M14.shape[0]
                _M14_reshaped = _M14.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_11_reshaped.T, _M5_reshaped.T, c=_M14_reshaped)
                _M14             = _M14_reshaped.reshape(*shape_backup)
                # step  19 start for loop with indices ('V', 'W', 'P', 'S')
                for S_0, S_1 in lib.prange(0,NTHC_INT,S_bunchsize):
                    # step  20 slice _INPUT_5 with indices ['S']
                    _INPUT_5_sliced_offset = offset_6        
                    _INPUT_5_sliced  = np.ndarray((NTHC_INT, (S_1-S_0)), buffer = buffer, offset = _INPUT_5_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                 ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_5.shape[0]),
                                 ctypes.c_int(_INPUT_5.shape[1]),
                                 ctypes.c_int(S_0),
                                 ctypes.c_int(S_1))
                    # step  21 slice _M10 with indices ['P', 'V']
                    _M10_sliced_offset = offset_8        
                    _M10_sliced      = np.ndarray((NTHC_INT, (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M10_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M10.ctypes.data),
                                   ctypes.c_void_p(_M10_sliced.ctypes.data),
                                   ctypes.c_int(_M10.shape[0]),
                                   ctypes.c_int(_M10.shape[1]),
                                   ctypes.c_int(_M10.shape[2]),
                                   ctypes.c_int(P_0),
                                   ctypes.c_int(P_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  22 RS,RPV->SPVR
                    offset_now       = offset_9        
                    _M11_offset      = offset_now      
                    _M11             = np.ndarray(((S_1-S_0), (P_1-P_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M11_offset)
                    fn_contraction_01_023_1230_wob(ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M10_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M11.ctypes.data),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[1]),
                                                   ctypes.c_int(_M10_sliced.shape[1]),
                                                   ctypes.c_int(_M10_sliced.shape[2]))
                    # step  23 cR,SPVR->cSPV
                    offset_now       = offset_6        
                    _M12_offset      = offset_now      
                    _M12             = np.ndarray((NVIR, (S_1-S_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M12_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
                    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M11.shape[0]
                    _size_dim_1      = _size_dim_1 * _M11.shape[1]
                    _size_dim_1      = _size_dim_1 * _M11.shape[2]
                    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M12.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M12.shape[0]
                    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_7_reshaped, _M11_reshaped.T, c=_M12_reshaped)
                    _M12             = _M12_reshaped.reshape(*shape_backup)
                    # step  24 slice _INPUT_21 with indices ['W']
                    _INPUT_21_sliced_offset = offset_8        
                    _INPUT_21_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_21_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_21.ctypes.data),
                                 ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_21.shape[0]),
                                 ctypes.c_int(_INPUT_21.shape[1]),
                                 ctypes.c_int(W_0),
                                 ctypes.c_int(W_1))
                    # step  25 cW,cSPV->WSPVc
                    offset_now       = offset_9        
                    _M13_offset      = offset_now      
                    _M13             = np.ndarray(((W_1-W_0), (S_1-S_0), (P_1-P_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M13_offset)
                    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                                                     ctypes.c_void_p(_M12.ctypes.data),
                                                     ctypes.c_void_p(_M13.ctypes.data),
                                                     ctypes.c_int(_INPUT_21_sliced.shape[0]),
                                                     ctypes.c_int(_INPUT_21_sliced.shape[1]),
                                                     ctypes.c_int(_M12.shape[1]),
                                                     ctypes.c_int(_M12.shape[2]),
                                                     ctypes.c_int(_M12.shape[3]))
                    # step  26 cT,WSPVc->TWSPV
                    offset_now       = offset_6        
                    _M15_offset      = offset_now      
                    _M15             = np.ndarray((NTHC_INT, (W_1-W_0), (S_1-S_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M15_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
                    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M13.shape[0]
                    _size_dim_1      = _size_dim_1 * _M13.shape[1]
                    _size_dim_1      = _size_dim_1 * _M13.shape[2]
                    _size_dim_1      = _size_dim_1 * _M13.shape[3]
                    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M15.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M15.shape[0]
                    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_12_reshaped.T, _M13_reshaped.T, c=_M15_reshaped)
                    _M15             = _M15_reshaped.reshape(*shape_backup)
                    # step  27 TWPV,TWSPV->STWPV
                    offset_now       = offset_8        
                    _M16_offset      = offset_now      
                    _M16             = np.ndarray(((S_1-S_0), NTHC_INT, (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M16_offset)
                    fn_contraction_0123_01423_40123_wob(ctypes.c_void_p(_M14.ctypes.data),
                                                        ctypes.c_void_p(_M15.ctypes.data),
                                                        ctypes.c_void_p(_M16.ctypes.data),
                                                        ctypes.c_int(_M14.shape[0]),
                                                        ctypes.c_int(_M14.shape[1]),
                                                        ctypes.c_int(_M14.shape[2]),
                                                        ctypes.c_int(_M14.shape[3]),
                                                        ctypes.c_int(_M15.shape[2]))
                    # step  28 STWPV->SWPVT
                    _M16_perm_offset = offset_6        
                    _M16_perm        = np.ndarray(((S_1-S_0), (W_1-W_0), (P_1-P_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M16_perm_offset)
                    fn_permutation_01234_02341_wob(ctypes.c_void_p(_M16.ctypes.data),
                                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                                   ctypes.c_int((S_1-S_0)),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  29 TU,SWPVT->USWPV
                    offset_now       = offset_8        
                    _M17_offset      = offset_now      
                    _M17             = np.ndarray((NTHC_INT, (S_1-S_0), (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M17_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
                    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
                    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M17.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M17.shape[0]
                    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
                    _M17             = _M17_reshaped.reshape(*shape_backup)
                    # step  30 slice _INPUT_0 with indices ['P']
                    _INPUT_0_sliced_offset = offset_6        
                    _INPUT_0_sliced  = np.ndarray(((P_1-P_0), NTHC_INT), buffer = buffer, offset = _INPUT_0_sliced_offset)
                    fn_slice_2_0(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                 ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_0.shape[0]),
                                 ctypes.c_int(_INPUT_0.shape[1]),
                                 ctypes.c_int(P_0),
                                 ctypes.c_int(P_1))
                    # step  31 slice _M6 with indices ['S', 'V']
                    _M6_sliced_offset = offset_9        
                    _M6_sliced       = np.ndarray((NTHC_INT, (S_1-S_0), (V_1-V_0)), buffer = buffer, offset = _M6_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                   ctypes.c_int(_M6.shape[0]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]),
                                   ctypes.c_int(S_0),
                                   ctypes.c_int(S_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  32 PQ,QSV->PSVQ
                    offset_now       = offset_10       
                    _M7_offset       = offset_now      
                    _M7              = np.ndarray(((P_1-P_0), (S_1-S_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M7_offset)
                    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M7.ctypes.data),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[2]))
                    # step  33 jQ,PSVQ->jPSV
                    offset_now       = offset_6        
                    _M8_offset       = offset_now      
                    _M8              = np.ndarray((NOCC, (P_1-P_0), (S_1-S_0), (V_1-V_0)), buffer = buffer, offset = _M8_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
                    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M7.shape[0]
                    _size_dim_1      = _size_dim_1 * _M7.shape[1]
                    _size_dim_1      = _size_dim_1 * _M7.shape[2]
                    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M8.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M8.shape[0]
                    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_3_reshaped, _M7_reshaped.T, c=_M8_reshaped)
                    _M8              = _M8_reshaped.reshape(*shape_backup)
                    # step  34 VWj,jPSV->WPSVj
                    offset_now       = offset_9        
                    _M9_offset       = offset_now      
                    _M9              = np.ndarray(((W_1-W_0), (P_1-P_0), (S_1-S_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M9_offset)
                    fn_contraction_012_2340_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                                      ctypes.c_void_p(_M8.ctypes.data),
                                                      ctypes.c_void_p(_M9.ctypes.data),
                                                      ctypes.c_int(_M4.shape[0]),
                                                      ctypes.c_int(_M4.shape[1]),
                                                      ctypes.c_int(_M4.shape[2]),
                                                      ctypes.c_int(_M8.shape[1]),
                                                      ctypes.c_int(_M8.shape[2]))
                    # step  35 jU,WPSVj->UWPSV
                    offset_now       = offset_6        
                    _M18_offset      = offset_now      
                    _M18             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (S_1-S_0), (V_1-V_0)), buffer = buffer, offset = _M18_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
                    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M9.shape[0]
                    _size_dim_1      = _size_dim_1 * _M9.shape[1]
                    _size_dim_1      = _size_dim_1 * _M9.shape[2]
                    _size_dim_1      = _size_dim_1 * _M9.shape[3]
                    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M18.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M18.shape[0]
                    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_13_reshaped.T, _M9_reshaped.T, c=_M18_reshaped)
                    _M18             = _M18_reshaped.reshape(*shape_backup)
                    # step  36 UWPSV->USWPV
                    _M18_perm_offset = offset_9        
                    _M18_perm        = np.ndarray((NTHC_INT, (S_1-S_0), (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M18_perm_offset)
                    fn_permutation_01234_03124_wob(ctypes.c_void_p(_M18.ctypes.data),
                                                   ctypes.c_void_p(_M18_perm.ctypes.data),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((S_1-S_0)),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  37 USWPV,USWPV->USW
                    offset_now       = offset_10       
                    _M19_packed_offset = offset_now      
                    _M19_packed      = np.ndarray((NTHC_INT, (S_1-S_0), (W_1-W_0)), buffer = buffer, offset = _M19_packed_offset)
                    fn_contraction_01234_01234_012_wob(ctypes.c_void_p(_M17.ctypes.data),
                                                       ctypes.c_void_p(_M18_perm.ctypes.data),
                                                       ctypes.c_void_p(_M19_packed.ctypes.data),
                                                       ctypes.c_int(_M17.shape[0]),
                                                       ctypes.c_int(_M17.shape[1]),
                                                       ctypes.c_int(_M17.shape[2]),
                                                       ctypes.c_int(_M17.shape[3]),
                                                       ctypes.c_int(_M17.shape[4]))
                    # step  38 pack  _M19 with indices ['W', 'S']
                    fn_packadd_3_1_2(ctypes.c_void_p(_M19.ctypes.data),
                                     ctypes.c_void_p(_M19_packed.ctypes.data),
                                     ctypes.c_int(_M19.shape[0]),
                                     ctypes.c_int(_M19.shape[1]),
                                     ctypes.c_int(_M19.shape[2]),
                                     ctypes.c_int(S_0),
                                     ctypes.c_int(S_1),
                                     ctypes.c_int(W_0),
                                     ctypes.c_int(W_1))
                # step  39 end   for loop with indices ('V', 'W', 'P', 'S')
                # step  40 deallocate ['_M14']
            # step  41 end   for loop with indices ('V', 'W', 'P')
            # step  42 deallocate ['_M4']
        # step  43 end   for loop with indices ('V', 'W')
    # step  44 end   for loop with indices ('V',)
    # step  45 deallocate ['_M0', '_M10', '_M6']
    # step  46 USW,USW->
    output_tmp       = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(output_tmp))
    _M21 = output_tmp.value
    # clean the final forloop
    # MPI finalize
    if use_mpi:
        _M21 = reduce(_M21, root=0)
        _M21 = bcast(_M21, root=0)
    return _M21

def RMP3_XX_4_forloop_P_R_determine_bucket_size_forloop(NVIR        : int,
                                                        NOCC        : int,
                                                        N_LAPLACE   : int,
                                                        NTHC_INT    : int,
                                                        P_bunchsize = 8,
                                                        R_bunchsize = 8,
                                                        V_bunchsize = 1,
                                                        W_bunchsize = 1):
    # init
    output = []     
    bucked_0_size    = 0               
    bucked_1_size    = 0               
    bucked_2_size    = 0               
    bucked_3_size    = 0               
    bucked_4_size    = 0               
    bucked_5_size    = 0               
    bucked_6_size    = 0               
    bucked_7_size    = 0               
    bucked_8_size    = 0               
    bucked_9_size    = 0               
    # assign the size of each tensor
    _M2_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M3_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M0_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M6_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M15_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M1_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _INPUT_16_sliced_size = (NOCC * N_LAPLACE)
    _INPUT_19_sliced_size = (NOCC * N_LAPLACE)
    _M14_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize)))
    _M10_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _INPUT_20_sliced_size = (NOCC * N_LAPLACE)
    _M0_sliced_size  = (P_bunchsize * (V_bunchsize * NOCC))
    _INPUT_0_sliced_size = (NTHC_INT * NTHC_INT)
    _M8_size         = (NOCC * (P_bunchsize * (R_bunchsize * V_bunchsize)))
    _M18_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * (R_bunchsize * V_bunchsize))))
    _INPUT_5_sliced_size = (NTHC_INT * NTHC_INT)
    _M12_size        = (NVIR * (R_bunchsize * (P_bunchsize * V_bunchsize)))
    _M20_size        = (NTHC_INT * (W_bunchsize * (R_bunchsize * (P_bunchsize * V_bunchsize))))
    _M4_size         = (V_bunchsize * (W_bunchsize * NOCC))
    _M5_size         = (W_bunchsize * (P_bunchsize * (V_bunchsize * NOCC)))
    _M6_sliced_size  = (NTHC_INT * (R_bunchsize * V_bunchsize))
    _M9_size         = (W_bunchsize * (P_bunchsize * (R_bunchsize * (V_bunchsize * NOCC))))
    _M15_sliced_size = (NTHC_INT * (R_bunchsize * W_bunchsize))
    _M16_perm_size   = (P_bunchsize * (V_bunchsize * (R_bunchsize * (NTHC_INT * W_bunchsize))))
    _M19_size        = (NTHC_INT * (P_bunchsize * (V_bunchsize * (R_bunchsize * W_bunchsize))))
    _M7_size         = (P_bunchsize * (R_bunchsize * (V_bunchsize * NTHC_INT)))
    _M16_size        = (P_bunchsize * (V_bunchsize * (R_bunchsize * (NTHC_INT * W_bunchsize))))
    _M17_size        = (NTHC_INT * (P_bunchsize * (V_bunchsize * (R_bunchsize * W_bunchsize))))
    _M10_sliced_size = (NTHC_INT * (P_bunchsize * V_bunchsize))
    _INPUT_22_sliced_size = (NVIR * N_LAPLACE)
    _M20_perm_size   = (NTHC_INT * (W_bunchsize * (R_bunchsize * (P_bunchsize * V_bunchsize))))
    _M11_size        = (R_bunchsize * (P_bunchsize * (V_bunchsize * NTHC_INT)))
    _M13_size        = (W_bunchsize * (R_bunchsize * (P_bunchsize * (V_bunchsize * NVIR))))
    # determine the size of each bucket
    # bucket 0
    bucked_0_size    = max(bucked_0_size, _M2_size)
    bucked_0_size    = max(bucked_0_size, _M3_size)
    bucked_0_size    = max(bucked_0_size, _M0_size)
    # bucket 1
    bucked_1_size    = max(bucked_1_size, _M6_size)
    # bucket 2
    bucked_2_size    = max(bucked_2_size, _M15_size)
    # bucket 3
    bucked_3_size    = max(bucked_3_size, _M1_size)
    bucked_3_size    = max(bucked_3_size, _INPUT_16_sliced_size)
    bucked_3_size    = max(bucked_3_size, _INPUT_19_sliced_size)
    bucked_3_size    = max(bucked_3_size, _M14_size)
    # bucket 4
    bucked_4_size    = max(bucked_4_size, _M10_size)
    # bucket 5
    bucked_5_size    = max(bucked_5_size, _INPUT_20_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M0_sliced_size)
    bucked_5_size    = max(bucked_5_size, _INPUT_0_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M8_size)
    bucked_5_size    = max(bucked_5_size, _M18_size)
    bucked_5_size    = max(bucked_5_size, _INPUT_5_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M12_size)
    bucked_5_size    = max(bucked_5_size, _M20_size)
    # bucket 6
    bucked_6_size    = max(bucked_6_size, _M4_size)
    # bucket 7
    bucked_7_size    = max(bucked_7_size, _M5_size)
    bucked_7_size    = max(bucked_7_size, _M6_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M9_size)
    bucked_7_size    = max(bucked_7_size, _M15_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M16_perm_size)
    bucked_7_size    = max(bucked_7_size, _M19_size)
    # bucket 8
    bucked_8_size    = max(bucked_8_size, _M7_size)
    bucked_8_size    = max(bucked_8_size, _M16_size)
    bucked_8_size    = max(bucked_8_size, _M17_size)
    bucked_8_size    = max(bucked_8_size, _M10_sliced_size)
    bucked_8_size    = max(bucked_8_size, _INPUT_22_sliced_size)
    bucked_8_size    = max(bucked_8_size, _M20_perm_size)
    # bucket 9
    bucked_9_size    = max(bucked_9_size, _M11_size)
    bucked_9_size    = max(bucked_9_size, _M13_size)
    # append each bucket size to the output
    output.append(bucked_0_size)
    output.append(bucked_1_size)
    output.append(bucked_2_size)
    output.append(bucked_3_size)
    output.append(bucked_4_size)
    output.append(bucked_5_size)
    output.append(bucked_6_size)
    output.append(bucked_7_size)
    output.append(bucked_8_size)
    output.append(bucked_9_size)
    return output

def RMP3_XX_4_forloop_P_R_naive(Z           : np.ndarray,
                                X_o         : np.ndarray,
                                X_v         : np.ndarray,
                                tau_o       : np.ndarray,
                                tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_v             
    _INPUT_7         = X_v             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    t1 = (logger.process_clock(), logger.perf_counter())
    _M2              = np.einsum("aR,aV->RVa"    , _INPUT_6        , _INPUT_17       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.einsum("aQ,RVa->QRV"   , _INPUT_4        , _M2             )
    del _M2         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M3              = np.einsum("cR,cW->RWc"    , _INPUT_7        , _INPUT_21       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.einsum("cT,RWc->TRW"   , _INPUT_12       , _M3             )
    del _M3         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M0              = np.einsum("iP,iV->PVi"    , _INPUT_1        , _INPUT_15       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M1              = np.einsum("bP,bV->PVb"    , _INPUT_2        , _INPUT_18       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.einsum("bS,PVb->SPV"   , _INPUT_8        , _M1             )
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M4              = np.einsum("jV,jW->VWj"    , _INPUT_16       , _INPUT_20       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M5              = np.einsum("iW,PVi->WPVi"  , _INPUT_19       , _M0             )
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.einsum("iT,WPVi->TWPV" , _INPUT_11       , _M5             )
    del _M5         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.einsum("PQ,QRV->PRVQ"  , _INPUT_0        , _M6             )
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.einsum("jQ,PRVQ->jPRV" , _INPUT_3        , _M7             )
    del _M7         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9              = np.einsum("VWj,jPRV->WPRVj", _M4             , _M8             )
    del _M4         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.einsum("jU,WPRVj->UWPRV", _INPUT_13       , _M9             )
    del _M9         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.einsum("TWPV,TRW->PVRTW", _M14            , _M15            )
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16_perm        = np.transpose(_M16            , (0, 1, 2, 4, 3) )
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.einsum("TU,PVRWT->UPVRW", _INPUT_10       , _M16_perm       )
    del _M16_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M19             = np.einsum("UPVRW,UWPRV->UPVRW", _M17            , _M18            )
    del _M17        
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11             = np.einsum("RS,SPV->RPVS"  , _INPUT_5        , _M10            )
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.einsum("dS,RPVS->dRPV" , _INPUT_9        , _M11            )
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M13             = np.einsum("dW,dRPV->WRPVd", _INPUT_22       , _M12            )
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.einsum("dU,WRPVd->UWRPV", _INPUT_14       , _M13            )
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20_perm        = np.transpose(_M20            , (0, 3, 4, 2, 1) )
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M21             = np.einsum("UPVRW,UPVRW->" , _M19            , _M20_perm       )
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    return _M21

def RMP3_XX_4_forloop_P_R(Z           : np.ndarray,
                          X_o         : np.ndarray,
                          X_v         : np.ndarray,
                          tau_o       : np.ndarray,
                          tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_v             
    _INPUT_7         = X_v             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # step 0 aR,aV->RVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_6.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_6.shape[0]),
                                 ctypes.c_int(_INPUT_6.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    # step 1 aQ,RVa->QRV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_4_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6          = _M6_reshaped.reshape(*shape_backup)
    del _M2         
    del _M2_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    # step 2 cR,cW->RWc 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_7.ctypes.data),
                                 ctypes.c_void_p(_INPUT_21.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_7.shape[0]),
                                 ctypes.c_int(_INPUT_7.shape[1]),
                                 ctypes.c_int(_INPUT_21.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    # step 3 cT,RWc->TRW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M15.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M15.shape[0]
    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_12_reshaped.T, _M3_reshaped.T, c=_M15_reshaped)
    _M15         = _M15_reshaped.reshape(*shape_backup)
    del _M3         
    del _M3_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    # step 4 iP,iV->PVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    # step 5 bP,bV->PVb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    # step 6 bS,PVb->SPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_8.shape[0]
    _INPUT_8_reshaped = _INPUT_8.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_8_reshaped.T, _M1_reshaped.T, c=_M10_reshaped)
    _M10         = _M10_reshaped.reshape(*shape_backup)
    del _M1         
    del _M1_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    # step 7 jV,jW->VWj 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M4              = np.ndarray((N_LAPLACE, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M4.ctypes.data),
                                 ctypes.c_int(_INPUT_16.shape[0]),
                                 ctypes.c_int(_INPUT_16.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    # step 8 iW,PVi->WPVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M5              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19.ctypes.data),
                                   ctypes.c_void_p(_M0.ctypes.data),
                                   ctypes.c_void_p(_M5.ctypes.data),
                                   ctypes.c_int(_INPUT_19.shape[0]),
                                   ctypes.c_int(_INPUT_19.shape[1]),
                                   ctypes.c_int(_M0.shape[0]),
                                   ctypes.c_int(_M0.shape[1]))
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    # step 9 iT,WPVi->TWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M5.shape[0]
    _size_dim_1      = _size_dim_1 * _M5.shape[1]
    _size_dim_1      = _size_dim_1 * _M5.shape[2]
    _M5_reshaped = _M5.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_11_reshaped.T, _M5_reshaped.T, c=_M14_reshaped)
    _M14         = _M14_reshaped.reshape(*shape_backup)
    del _M5         
    del _M5_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    # step 10 PQ,QRV->PRVQ 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                   ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M7.ctypes.data),
                                   ctypes.c_int(_INPUT_0.shape[0]),
                                   ctypes.c_int(_INPUT_0.shape[1]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]))
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    # step 11 jQ,PRVQ->jPRV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.ndarray((NOCC, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _size_dim_1      = _size_dim_1 * _M7.shape[1]
    _size_dim_1      = _size_dim_1 * _M7.shape[2]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M8.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M8.shape[0]
    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped, _M7_reshaped.T, c=_M8_reshaped)
    _M8          = _M8_reshaped.reshape(*shape_backup)
    del _M7         
    del _M7_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    # step 12 VWj,jPRV->WPRVj 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_2340_13402_wob = getattr(libpbc, "fn_contraction_012_2340_13402_wob", None)
    assert fn_contraction_012_2340_13402_wob is not None
    _M9              = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_012_2340_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                      ctypes.c_void_p(_M8.ctypes.data),
                                      ctypes.c_void_p(_M9.ctypes.data),
                                      ctypes.c_int(_M4.shape[0]),
                                      ctypes.c_int(_M4.shape[1]),
                                      ctypes.c_int(_M4.shape[2]),
                                      ctypes.c_int(_M8.shape[1]),
                                      ctypes.c_int(_M8.shape[2]))
    del _M4         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    # step 13 jU,WPRVj->UWPRV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M9.shape[0]
    _size_dim_1      = _size_dim_1 * _M9.shape[1]
    _size_dim_1      = _size_dim_1 * _M9.shape[2]
    _size_dim_1      = _size_dim_1 * _M9.shape[3]
    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_13_reshaped.T, _M9_reshaped.T, c=_M18_reshaped)
    _M18         = _M18_reshaped.reshape(*shape_backup)
    del _M9         
    del _M9_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    # step 14 TWPV,TRW->PVRTW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_0123_041_23401_wob = getattr(libpbc, "fn_contraction_0123_041_23401_wob", None)
    assert fn_contraction_0123_041_23401_wob is not None
    _M16             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_0123_041_23401_wob(ctypes.c_void_p(_M14.ctypes.data),
                                      ctypes.c_void_p(_M15.ctypes.data),
                                      ctypes.c_void_p(_M16.ctypes.data),
                                      ctypes.c_int(_M14.shape[0]),
                                      ctypes.c_int(_M14.shape[1]),
                                      ctypes.c_int(_M14.shape[2]),
                                      ctypes.c_int(_M14.shape[3]),
                                      ctypes.c_int(_M15.shape[1]))
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    # step 15 PVRTW->PVRWT 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_01243_wob = getattr(libpbc, "fn_permutation_01234_01243_wob", None)
    assert fn_permutation_01234_01243_wob is not None
    _M16_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_01243_wob(ctypes.c_void_p(_M16.ctypes.data),
                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                   ctypes.c_int(_M16.shape[0]),
                                   ctypes.c_int(_M16.shape[1]),
                                   ctypes.c_int(_M16.shape[2]),
                                   ctypes.c_int(_M16.shape[3]),
                                   ctypes.c_int(_M16.shape[4]))
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    # step 16 TU,PVRWT->UPVRW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M17.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M17.shape[0]
    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
    _M17         = _M17_reshaped.reshape(*shape_backup)
    del _M16_perm   
    del _M16_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    # step 17 UPVRW,UWPRV->UPVRW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01234_04132_01234_wob = getattr(libpbc, "fn_contraction_01234_04132_01234_wob", None)
    assert fn_contraction_01234_04132_01234_wob is not None
    _M19             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_01234_04132_01234_wob(ctypes.c_void_p(_M17.ctypes.data),
                                         ctypes.c_void_p(_M18.ctypes.data),
                                         ctypes.c_void_p(_M19.ctypes.data),
                                         ctypes.c_int(_M17.shape[0]),
                                         ctypes.c_int(_M17.shape[1]),
                                         ctypes.c_int(_M17.shape[2]),
                                         ctypes.c_int(_M17.shape[3]),
                                         ctypes.c_int(_M17.shape[4]))
    del _M17        
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    # step 18 RS,SPV->RPVS 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    _M11             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                   ctypes.c_void_p(_M10.ctypes.data),
                                   ctypes.c_void_p(_M11.ctypes.data),
                                   ctypes.c_int(_INPUT_5.shape[0]),
                                   ctypes.c_int(_INPUT_5.shape[1]),
                                   ctypes.c_int(_M10.shape[1]),
                                   ctypes.c_int(_M10.shape[2]))
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    # step 19 dS,RPVS->dRPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.ndarray((NVIR, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_9.shape[0]
    _INPUT_9_reshaped = _INPUT_9.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M11.shape[0]
    _size_dim_1      = _size_dim_1 * _M11.shape[1]
    _size_dim_1      = _size_dim_1 * _M11.shape[2]
    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M12.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M12.shape[0]
    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_9_reshaped, _M11_reshaped.T, c=_M12_reshaped)
    _M12         = _M12_reshaped.reshape(*shape_backup)
    del _M11        
    del _M11_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    # step 20 dW,dRPV->WRPVd 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    _M13             = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_22.ctypes.data),
                                     ctypes.c_void_p(_M12.ctypes.data),
                                     ctypes.c_void_p(_M13.ctypes.data),
                                     ctypes.c_int(_INPUT_22.shape[0]),
                                     ctypes.c_int(_INPUT_22.shape[1]),
                                     ctypes.c_int(_M12.shape[1]),
                                     ctypes.c_int(_M12.shape[2]),
                                     ctypes.c_int(_M12.shape[3]))
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    # step 21 dU,WRPVd->UWRPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M13.shape[0]
    _size_dim_1      = _size_dim_1 * _M13.shape[1]
    _size_dim_1      = _size_dim_1 * _M13.shape[2]
    _size_dim_1      = _size_dim_1 * _M13.shape[3]
    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_14_reshaped.T, _M13_reshaped.T, c=_M20_reshaped)
    _M20         = _M20_reshaped.reshape(*shape_backup)
    del _M13        
    del _M13_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    # step 22 UWRPV->UPVRW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_03421_wob = getattr(libpbc, "fn_permutation_01234_03421_wob", None)
    assert fn_permutation_01234_03421_wob is not None
    _M20_perm        = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_permutation_01234_03421_wob(ctypes.c_void_p(_M20.ctypes.data),
                                   ctypes.c_void_p(_M20_perm.ctypes.data),
                                   ctypes.c_int(_M20.shape[0]),
                                   ctypes.c_int(_M20.shape[1]),
                                   ctypes.c_int(_M20.shape[2]),
                                   ctypes.c_int(_M20.shape[3]),
                                   ctypes.c_int(_M20.shape[4]))
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    # step 23 UPVRW,UPVRW-> 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    _M21             = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20_perm.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(_M21))
    _M21 = _M21.value
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    return _M21

def RMP3_XX_4_forloop_P_R_forloop_P_R(Z           : np.ndarray,
                                      X_o         : np.ndarray,
                                      X_v         : np.ndarray,
                                      tau_o       : np.ndarray,
                                      tau_v       : np.ndarray,
                                      buffer      : np.ndarray,
                                      P_bunchsize = 8,
                                      R_bunchsize = 8,
                                      V_bunchsize = 1,
                                      W_bunchsize = 1,
                                      use_mpi = False):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_v             
    _INPUT_7         = X_v             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # fetch function pointers
    fn_contraction_0123_041_23401_wob = getattr(libpbc, "fn_contraction_0123_041_23401_wob", None)
    assert fn_contraction_0123_041_23401_wob is not None
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    fn_slice_3_1_2 = getattr(libpbc, "fn_slice_3_1_2", None)
    assert fn_slice_3_1_2 is not None
    fn_contraction_01234_04132_01234_wob = getattr(libpbc, "fn_contraction_01234_04132_01234_wob", None)
    assert fn_contraction_01234_04132_01234_wob is not None
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    fn_slice_2_1 = getattr(libpbc, "fn_slice_2_1", None)
    assert fn_slice_2_1 is not None
    fn_slice_2_0 = getattr(libpbc, "fn_slice_2_0", None)
    assert fn_slice_2_0 is not None
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    fn_slice_3_0_1 = getattr(libpbc, "fn_slice_3_0_1", None)
    assert fn_slice_3_0_1 is not None
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    fn_permutation_01234_03421_wob = getattr(libpbc, "fn_permutation_01234_03421_wob", None)
    assert fn_permutation_01234_03421_wob is not None
    fn_contraction_012_2340_13402_wob = getattr(libpbc, "fn_contraction_012_2340_13402_wob", None)
    assert fn_contraction_012_2340_13402_wob is not None
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    fn_permutation_01234_01243_wob = getattr(libpbc, "fn_permutation_01234_01243_wob", None)
    assert fn_permutation_01234_01243_wob is not None
    if use_mpi:
        bunchsize = NTHC_INT//comm_size + 1
        P_begin = rank*bunchsize
        P_end = (rank+1)*bunchsize
        P_begin          = min(P_begin, NTHC_INT)
        P_end            = min(P_end, NTHC_INT)
    else:
        P_begin          = 0               
        P_end            = NTHC_INT        
    # preallocate buffer
    bucket_size      = RMP3_XX_4_forloop_P_R_determine_bucket_size_forloop(NVIR = NVIR,
                                                                           NOCC = NOCC,
                                                                           N_LAPLACE = N_LAPLACE,
                                                                           NTHC_INT = NTHC_INT,
                                                                           V_bunchsize = V_bunchsize,
                                                                           W_bunchsize = W_bunchsize,
                                                                           P_bunchsize = P_bunchsize,
                                                                           R_bunchsize = R_bunchsize)
    bufsize_now      = buffer.size     
    _itemsize        = buffer.itemsize 
    offset_now       = 0               
    offset_0         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[0])
    offset_1         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[1])
    offset_2         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[2])
    offset_3         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[3])
    offset_4         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[4])
    offset_5         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[5])
    offset_6         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[6])
    offset_7         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[7])
    offset_8         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[8])
    offset_9         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[9])
    bufsize          = offset_now      
    if (bufsize > bufsize_now):
        buffer           = np.ndarray((bufsize), dtype=np.float64)
    # step   0 start for loop with indices ()
    # step   1 allocate   _M21
    _M21             = 0.0             
    # step   2 aR,aV->RVa
    offset_now       = offset_0        
    _M2_offset       = offset_now      
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M2_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_6.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_6.shape[0]),
                                 ctypes.c_int(_INPUT_6.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    # step   3 aQ,RVa->QRV
    offset_now       = offset_1        
    _M6_offset       = offset_now      
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M6_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_4_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6              = _M6_reshaped.reshape(*shape_backup)
    # step   4 cR,cW->RWc
    offset_now       = offset_0        
    _M3_offset       = offset_now      
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M3_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_7.ctypes.data),
                                 ctypes.c_void_p(_INPUT_21.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_7.shape[0]),
                                 ctypes.c_int(_INPUT_7.shape[1]),
                                 ctypes.c_int(_INPUT_21.shape[1]))
    # step   5 cT,RWc->TRW
    offset_now       = offset_2        
    _M15_offset      = offset_now      
    _M15             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M15_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M15.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M15.shape[0]
    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_12_reshaped.T, _M3_reshaped.T, c=_M15_reshaped)
    _M15             = _M15_reshaped.reshape(*shape_backup)
    # step   6 iP,iV->PVi
    offset_now       = offset_0        
    _M0_offset       = offset_now      
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M0_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    # step   7 bP,bV->PVb
    offset_now       = offset_3        
    _M1_offset       = offset_now      
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M1_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    # step   8 bS,PVb->SPV
    offset_now       = offset_4        
    _M10_offset      = offset_now      
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M10_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_8.shape[0]
    _INPUT_8_reshaped = _INPUT_8.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_8_reshaped.T, _M1_reshaped.T, c=_M10_reshaped)
    _M10             = _M10_reshaped.reshape(*shape_backup)
    # step   9 start for loop with indices ('V',)
    for V_0, V_1 in lib.prange(0,N_LAPLACE,V_bunchsize):
        # step  10 start for loop with indices ('V', 'W')
        for W_0, W_1 in lib.prange(0,N_LAPLACE,W_bunchsize):
            # step  11 slice _INPUT_16 with indices ['V']
            _INPUT_16_sliced_offset = offset_3        
            _INPUT_16_sliced = np.ndarray((NOCC, (V_1-V_0)), buffer = buffer, offset = _INPUT_16_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_16.ctypes.data),
                         ctypes.c_void_p(_INPUT_16_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_16.shape[0]),
                         ctypes.c_int(_INPUT_16.shape[1]),
                         ctypes.c_int(V_0),
                         ctypes.c_int(V_1))
            # step  12 slice _INPUT_20 with indices ['W']
            _INPUT_20_sliced_offset = offset_5        
            _INPUT_20_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_20_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_20.ctypes.data),
                         ctypes.c_void_p(_INPUT_20_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_20.shape[0]),
                         ctypes.c_int(_INPUT_20.shape[1]),
                         ctypes.c_int(W_0),
                         ctypes.c_int(W_1))
            # step  13 jV,jW->VWj
            offset_now       = offset_6        
            _M4_offset       = offset_now      
            _M4              = np.ndarray(((V_1-V_0), (W_1-W_0), NOCC), buffer = buffer, offset = _M4_offset)
            fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_16_sliced.ctypes.data),
                                         ctypes.c_void_p(_INPUT_20_sliced.ctypes.data),
                                         ctypes.c_void_p(_M4.ctypes.data),
                                         ctypes.c_int(_INPUT_16_sliced.shape[0]),
                                         ctypes.c_int(_INPUT_16_sliced.shape[1]),
                                         ctypes.c_int(_INPUT_20_sliced.shape[1]))
            # step  14 start for loop with indices ('V', 'W', 'P')
            for P_0, P_1 in lib.prange(P_begin,P_end,P_bunchsize):
                # step  15 slice _INPUT_19 with indices ['W']
                _INPUT_19_sliced_offset = offset_3        
                _INPUT_19_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_19_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_19.ctypes.data),
                             ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_19.shape[0]),
                             ctypes.c_int(_INPUT_19.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  16 slice _M0 with indices ['P', 'V']
                _M0_sliced_offset = offset_5        
                _M0_sliced       = np.ndarray(((P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M0_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M0.ctypes.data),
                               ctypes.c_void_p(_M0_sliced.ctypes.data),
                               ctypes.c_int(_M0.shape[0]),
                               ctypes.c_int(_M0.shape[1]),
                               ctypes.c_int(_M0.shape[2]),
                               ctypes.c_int(P_0),
                               ctypes.c_int(P_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  17 iW,PVi->WPVi
                offset_now       = offset_7        
                _M5_offset       = offset_now      
                _M5              = np.ndarray(((W_1-W_0), (P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M5_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                                               ctypes.c_void_p(_M0_sliced.ctypes.data),
                                               ctypes.c_void_p(_M5.ctypes.data),
                                               ctypes.c_int(_INPUT_19_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_19_sliced.shape[1]),
                                               ctypes.c_int(_M0_sliced.shape[0]),
                                               ctypes.c_int(_M0_sliced.shape[1]))
                # step  18 iT,WPVi->TWPV
                offset_now       = offset_3        
                _M14_offset      = offset_now      
                _M14             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M14_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
                _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M5.shape[0]
                _size_dim_1      = _size_dim_1 * _M5.shape[1]
                _size_dim_1      = _size_dim_1 * _M5.shape[2]
                _M5_reshaped = _M5.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M14.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M14.shape[0]
                _M14_reshaped = _M14.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_11_reshaped.T, _M5_reshaped.T, c=_M14_reshaped)
                _M14             = _M14_reshaped.reshape(*shape_backup)
                # step  19 start for loop with indices ('V', 'W', 'P', 'R')
                for R_0, R_1 in lib.prange(0,NTHC_INT,R_bunchsize):
                    # step  20 slice _INPUT_0 with indices ['P']
                    _INPUT_0_sliced_offset = offset_5        
                    _INPUT_0_sliced  = np.ndarray(((P_1-P_0), NTHC_INT), buffer = buffer, offset = _INPUT_0_sliced_offset)
                    fn_slice_2_0(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                 ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_0.shape[0]),
                                 ctypes.c_int(_INPUT_0.shape[1]),
                                 ctypes.c_int(P_0),
                                 ctypes.c_int(P_1))
                    # step  21 slice _M6 with indices ['R', 'V']
                    _M6_sliced_offset = offset_7        
                    _M6_sliced       = np.ndarray((NTHC_INT, (R_1-R_0), (V_1-V_0)), buffer = buffer, offset = _M6_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                   ctypes.c_int(_M6.shape[0]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]),
                                   ctypes.c_int(R_0),
                                   ctypes.c_int(R_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  22 PQ,QRV->PRVQ
                    offset_now       = offset_8        
                    _M7_offset       = offset_now      
                    _M7              = np.ndarray(((P_1-P_0), (R_1-R_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M7_offset)
                    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M7.ctypes.data),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[2]))
                    # step  23 jQ,PRVQ->jPRV
                    offset_now       = offset_5        
                    _M8_offset       = offset_now      
                    _M8              = np.ndarray((NOCC, (P_1-P_0), (R_1-R_0), (V_1-V_0)), buffer = buffer, offset = _M8_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
                    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M7.shape[0]
                    _size_dim_1      = _size_dim_1 * _M7.shape[1]
                    _size_dim_1      = _size_dim_1 * _M7.shape[2]
                    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M8.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M8.shape[0]
                    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_3_reshaped, _M7_reshaped.T, c=_M8_reshaped)
                    _M8              = _M8_reshaped.reshape(*shape_backup)
                    # step  24 VWj,jPRV->WPRVj
                    offset_now       = offset_7        
                    _M9_offset       = offset_now      
                    _M9              = np.ndarray(((W_1-W_0), (P_1-P_0), (R_1-R_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M9_offset)
                    fn_contraction_012_2340_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                                      ctypes.c_void_p(_M8.ctypes.data),
                                                      ctypes.c_void_p(_M9.ctypes.data),
                                                      ctypes.c_int(_M4.shape[0]),
                                                      ctypes.c_int(_M4.shape[1]),
                                                      ctypes.c_int(_M4.shape[2]),
                                                      ctypes.c_int(_M8.shape[1]),
                                                      ctypes.c_int(_M8.shape[2]))
                    # step  25 jU,WPRVj->UWPRV
                    offset_now       = offset_5        
                    _M18_offset      = offset_now      
                    _M18             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (R_1-R_0), (V_1-V_0)), buffer = buffer, offset = _M18_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
                    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M9.shape[0]
                    _size_dim_1      = _size_dim_1 * _M9.shape[1]
                    _size_dim_1      = _size_dim_1 * _M9.shape[2]
                    _size_dim_1      = _size_dim_1 * _M9.shape[3]
                    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M18.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M18.shape[0]
                    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_13_reshaped.T, _M9_reshaped.T, c=_M18_reshaped)
                    _M18             = _M18_reshaped.reshape(*shape_backup)
                    # step  26 slice _M15 with indices ['R', 'W']
                    _M15_sliced_offset = offset_7        
                    _M15_sliced      = np.ndarray((NTHC_INT, (R_1-R_0), (W_1-W_0)), buffer = buffer, offset = _M15_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M15.ctypes.data),
                                   ctypes.c_void_p(_M15_sliced.ctypes.data),
                                   ctypes.c_int(_M15.shape[0]),
                                   ctypes.c_int(_M15.shape[1]),
                                   ctypes.c_int(_M15.shape[2]),
                                   ctypes.c_int(R_0),
                                   ctypes.c_int(R_1),
                                   ctypes.c_int(W_0),
                                   ctypes.c_int(W_1))
                    # step  27 TWPV,TRW->PVRTW
                    offset_now       = offset_8        
                    _M16_offset      = offset_now      
                    _M16             = np.ndarray(((P_1-P_0), (V_1-V_0), (R_1-R_0), NTHC_INT, (W_1-W_0)), buffer = buffer, offset = _M16_offset)
                    fn_contraction_0123_041_23401_wob(ctypes.c_void_p(_M14.ctypes.data),
                                                      ctypes.c_void_p(_M15_sliced.ctypes.data),
                                                      ctypes.c_void_p(_M16.ctypes.data),
                                                      ctypes.c_int(_M14.shape[0]),
                                                      ctypes.c_int(_M14.shape[1]),
                                                      ctypes.c_int(_M14.shape[2]),
                                                      ctypes.c_int(_M14.shape[3]),
                                                      ctypes.c_int(_M15_sliced.shape[1]))
                    # step  28 PVRTW->PVRWT
                    _M16_perm_offset = offset_7        
                    _M16_perm        = np.ndarray(((P_1-P_0), (V_1-V_0), (R_1-R_0), (W_1-W_0), NTHC_INT), buffer = buffer, offset = _M16_perm_offset)
                    fn_permutation_01234_01243_wob(ctypes.c_void_p(_M16.ctypes.data),
                                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((V_1-V_0)),
                                                   ctypes.c_int((R_1-R_0)),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((W_1-W_0)))
                    # step  29 TU,PVRWT->UPVRW
                    offset_now       = offset_8        
                    _M17_offset      = offset_now      
                    _M17             = np.ndarray((NTHC_INT, (P_1-P_0), (V_1-V_0), (R_1-R_0), (W_1-W_0)), buffer = buffer, offset = _M17_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
                    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
                    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M17.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M17.shape[0]
                    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
                    _M17             = _M17_reshaped.reshape(*shape_backup)
                    # step  30 UPVRW,UWPRV->UPVRW
                    offset_now       = offset_7        
                    _M19_offset      = offset_now      
                    _M19             = np.ndarray((NTHC_INT, (P_1-P_0), (V_1-V_0), (R_1-R_0), (W_1-W_0)), buffer = buffer, offset = _M19_offset)
                    fn_contraction_01234_04132_01234_wob(ctypes.c_void_p(_M17.ctypes.data),
                                                         ctypes.c_void_p(_M18.ctypes.data),
                                                         ctypes.c_void_p(_M19.ctypes.data),
                                                         ctypes.c_int(_M17.shape[0]),
                                                         ctypes.c_int(_M17.shape[1]),
                                                         ctypes.c_int(_M17.shape[2]),
                                                         ctypes.c_int(_M17.shape[3]),
                                                         ctypes.c_int(_M17.shape[4]))
                    # step  31 slice _INPUT_5 with indices ['R']
                    _INPUT_5_sliced_offset = offset_5        
                    _INPUT_5_sliced  = np.ndarray(((R_1-R_0), NTHC_INT), buffer = buffer, offset = _INPUT_5_sliced_offset)
                    fn_slice_2_0(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                 ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_5.shape[0]),
                                 ctypes.c_int(_INPUT_5.shape[1]),
                                 ctypes.c_int(R_0),
                                 ctypes.c_int(R_1))
                    # step  32 slice _M10 with indices ['P', 'V']
                    _M10_sliced_offset = offset_8        
                    _M10_sliced      = np.ndarray((NTHC_INT, (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M10_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M10.ctypes.data),
                                   ctypes.c_void_p(_M10_sliced.ctypes.data),
                                   ctypes.c_int(_M10.shape[0]),
                                   ctypes.c_int(_M10.shape[1]),
                                   ctypes.c_int(_M10.shape[2]),
                                   ctypes.c_int(P_0),
                                   ctypes.c_int(P_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  33 RS,SPV->RPVS
                    offset_now       = offset_9        
                    _M11_offset      = offset_now      
                    _M11             = np.ndarray(((R_1-R_0), (P_1-P_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M11_offset)
                    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M10_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M11.ctypes.data),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[1]),
                                                   ctypes.c_int(_M10_sliced.shape[1]),
                                                   ctypes.c_int(_M10_sliced.shape[2]))
                    # step  34 dS,RPVS->dRPV
                    offset_now       = offset_5        
                    _M12_offset      = offset_now      
                    _M12             = np.ndarray((NVIR, (R_1-R_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M12_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_9.shape[0]
                    _INPUT_9_reshaped = _INPUT_9.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M11.shape[0]
                    _size_dim_1      = _size_dim_1 * _M11.shape[1]
                    _size_dim_1      = _size_dim_1 * _M11.shape[2]
                    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M12.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M12.shape[0]
                    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_9_reshaped, _M11_reshaped.T, c=_M12_reshaped)
                    _M12             = _M12_reshaped.reshape(*shape_backup)
                    # step  35 slice _INPUT_22 with indices ['W']
                    _INPUT_22_sliced_offset = offset_8        
                    _INPUT_22_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_22_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_22.shape[0]),
                                 ctypes.c_int(_INPUT_22.shape[1]),
                                 ctypes.c_int(W_0),
                                 ctypes.c_int(W_1))
                    # step  36 dW,dRPV->WRPVd
                    offset_now       = offset_9        
                    _M13_offset      = offset_now      
                    _M13             = np.ndarray(((W_1-W_0), (R_1-R_0), (P_1-P_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M13_offset)
                    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_22_sliced.ctypes.data),
                                                     ctypes.c_void_p(_M12.ctypes.data),
                                                     ctypes.c_void_p(_M13.ctypes.data),
                                                     ctypes.c_int(_INPUT_22_sliced.shape[0]),
                                                     ctypes.c_int(_INPUT_22_sliced.shape[1]),
                                                     ctypes.c_int(_M12.shape[1]),
                                                     ctypes.c_int(_M12.shape[2]),
                                                     ctypes.c_int(_M12.shape[3]))
                    # step  37 dU,WRPVd->UWRPV
                    offset_now       = offset_5        
                    _M20_offset      = offset_now      
                    _M20             = np.ndarray((NTHC_INT, (W_1-W_0), (R_1-R_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M20_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
                    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M13.shape[0]
                    _size_dim_1      = _size_dim_1 * _M13.shape[1]
                    _size_dim_1      = _size_dim_1 * _M13.shape[2]
                    _size_dim_1      = _size_dim_1 * _M13.shape[3]
                    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M20.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M20.shape[0]
                    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_14_reshaped.T, _M13_reshaped.T, c=_M20_reshaped)
                    _M20             = _M20_reshaped.reshape(*shape_backup)
                    # step  38 UWRPV->UPVRW
                    _M20_perm_offset = offset_8        
                    _M20_perm        = np.ndarray((NTHC_INT, (P_1-P_0), (V_1-V_0), (R_1-R_0), (W_1-W_0)), buffer = buffer, offset = _M20_perm_offset)
                    fn_permutation_01234_03421_wob(ctypes.c_void_p(_M20.ctypes.data),
                                                   ctypes.c_void_p(_M20_perm.ctypes.data),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((R_1-R_0)),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  39 UPVRW,UPVRW->
                    output_tmp       = ctypes.c_double(0.0)
                    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
                           ctypes.c_void_p(_M20_perm.ctypes.data),
                           ctypes.c_int(_M19.size),
                           ctypes.pointer(output_tmp))
                    output_tmp = output_tmp.value
                    _M21 += output_tmp
                # step  40 end   for loop with indices ('V', 'W', 'P', 'R')
            # step  41 end   for loop with indices ('V', 'W', 'P')
        # step  42 end   for loop with indices ('V', 'W')
    # step  43 end   for loop with indices ('V',)
    # clean the final forloop
    # MPI finalize
    if use_mpi:
        _M21 = reduce(_M21, root=0)
        _M21 = bcast(_M21, root=0)
    return _M21

def RMP3_XX_5_forloop_P_S_determine_bucket_size_forloop(NVIR        : int,
                                                        NOCC        : int,
                                                        N_LAPLACE   : int,
                                                        NTHC_INT    : int,
                                                        P_bunchsize = 8,
                                                        S_bunchsize = 8,
                                                        V_bunchsize = 1,
                                                        W_bunchsize = 1):
    # init
    output = []     
    bucked_0_size    = 0               
    bucked_1_size    = 0               
    bucked_2_size    = 0               
    bucked_3_size    = 0               
    bucked_4_size    = 0               
    bucked_5_size    = 0               
    bucked_6_size    = 0               
    bucked_7_size    = 0               
    bucked_8_size    = 0               
    bucked_9_size    = 0               
    # assign the size of each tensor
    _M3_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M1_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M18_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M0_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M2_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _INPUT_18_sliced_size = (NVIR * N_LAPLACE)
    _INPUT_21_sliced_size = (NVIR * N_LAPLACE)
    _M15_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize)))
    _M10_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M6_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _INPUT_22_sliced_size = (NVIR * N_LAPLACE)
    _M1_sliced_size  = (P_bunchsize * (V_bunchsize * NVIR))
    _INPUT_5_sliced_size = (NTHC_INT * NTHC_INT)
    _M12_size        = (NOCC * (S_bunchsize * (P_bunchsize * V_bunchsize)))
    _M14_size        = (NTHC_INT * (W_bunchsize * (S_bunchsize * (P_bunchsize * V_bunchsize))))
    _M16_perm_size   = (S_bunchsize * (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize))))
    _M18_sliced_size = (NTHC_INT * (S_bunchsize * W_bunchsize))
    _INPUT_0_sliced_size = (NTHC_INT * NTHC_INT)
    _M8_size         = (NVIR * (P_bunchsize * (S_bunchsize * V_bunchsize)))
    _M20_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * (S_bunchsize * V_bunchsize))))
    _M4_size         = (V_bunchsize * (W_bunchsize * NVIR))
    _M5_size         = (W_bunchsize * (P_bunchsize * (V_bunchsize * NVIR)))
    _M10_sliced_size = (NTHC_INT * (P_bunchsize * V_bunchsize))
    _INPUT_19_sliced_size = (NOCC * N_LAPLACE)
    _M16_size        = (S_bunchsize * (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize))))
    _M17_size        = (NTHC_INT * (S_bunchsize * (W_bunchsize * (P_bunchsize * V_bunchsize))))
    _M6_sliced_size  = (NTHC_INT * (S_bunchsize * V_bunchsize))
    _M9_size         = (W_bunchsize * (P_bunchsize * (S_bunchsize * (V_bunchsize * NVIR))))
    _M20_perm_size   = (NTHC_INT * (W_bunchsize * (P_bunchsize * (S_bunchsize * V_bunchsize))))
    _M11_size        = (S_bunchsize * (P_bunchsize * (V_bunchsize * NTHC_INT)))
    _M13_size        = (W_bunchsize * (S_bunchsize * (P_bunchsize * (V_bunchsize * NOCC))))
    _M19_size        = (P_bunchsize * (V_bunchsize * (NTHC_INT * (S_bunchsize * W_bunchsize))))
    _M7_size         = (P_bunchsize * (S_bunchsize * (V_bunchsize * NTHC_INT)))
    # determine the size of each bucket
    # bucket 0
    bucked_0_size    = max(bucked_0_size, _M3_size)
    bucked_0_size    = max(bucked_0_size, _M1_size)
    # bucket 1
    bucked_1_size    = max(bucked_1_size, _M18_size)
    # bucket 2
    bucked_2_size    = max(bucked_2_size, _M0_size)
    bucked_2_size    = max(bucked_2_size, _M2_size)
    bucked_2_size    = max(bucked_2_size, _INPUT_18_sliced_size)
    bucked_2_size    = max(bucked_2_size, _INPUT_21_sliced_size)
    bucked_2_size    = max(bucked_2_size, _M15_size)
    # bucket 3
    bucked_3_size    = max(bucked_3_size, _M10_size)
    # bucket 4
    bucked_4_size    = max(bucked_4_size, _M6_size)
    # bucket 5
    bucked_5_size    = max(bucked_5_size, _INPUT_22_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M1_sliced_size)
    bucked_5_size    = max(bucked_5_size, _INPUT_5_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M12_size)
    bucked_5_size    = max(bucked_5_size, _M14_size)
    bucked_5_size    = max(bucked_5_size, _M16_perm_size)
    bucked_5_size    = max(bucked_5_size, _M18_sliced_size)
    bucked_5_size    = max(bucked_5_size, _INPUT_0_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M8_size)
    bucked_5_size    = max(bucked_5_size, _M20_size)
    # bucket 6
    bucked_6_size    = max(bucked_6_size, _M4_size)
    # bucket 7
    bucked_7_size    = max(bucked_7_size, _M5_size)
    bucked_7_size    = max(bucked_7_size, _M10_sliced_size)
    bucked_7_size    = max(bucked_7_size, _INPUT_19_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M16_size)
    bucked_7_size    = max(bucked_7_size, _M17_size)
    bucked_7_size    = max(bucked_7_size, _M6_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M9_size)
    bucked_7_size    = max(bucked_7_size, _M20_perm_size)
    # bucket 8
    bucked_8_size    = max(bucked_8_size, _M11_size)
    bucked_8_size    = max(bucked_8_size, _M13_size)
    bucked_8_size    = max(bucked_8_size, _M19_size)
    # bucket 9
    bucked_9_size    = max(bucked_9_size, _M7_size)
    # append each bucket size to the output
    output.append(bucked_0_size)
    output.append(bucked_1_size)
    output.append(bucked_2_size)
    output.append(bucked_3_size)
    output.append(bucked_4_size)
    output.append(bucked_5_size)
    output.append(bucked_6_size)
    output.append(bucked_7_size)
    output.append(bucked_8_size)
    output.append(bucked_9_size)
    return output

def RMP3_XX_5_forloop_P_S_naive(Z           : np.ndarray,
                                X_o         : np.ndarray,
                                X_v         : np.ndarray,
                                tau_o       : np.ndarray,
                                tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_o             
    _INPUT_9         = X_o             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    t1 = (logger.process_clock(), logger.perf_counter())
    _M3              = np.einsum("lS,lW->SWl"    , _INPUT_9        , _INPUT_20       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.einsum("lU,SWl->USW"   , _INPUT_13       , _M3             )
    del _M3         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M1              = np.einsum("aP,aV->PVa"    , _INPUT_2        , _INPUT_17       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M0              = np.einsum("iP,iV->PVi"    , _INPUT_1        , _INPUT_15       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.einsum("iR,PVi->RPV"   , _INPUT_6        , _M0             )
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M2              = np.einsum("jS,jV->SVj"    , _INPUT_8        , _INPUT_16       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.einsum("jQ,SVj->QSV"   , _INPUT_3        , _M2             )
    del _M2         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M4              = np.einsum("bV,bW->VWb"    , _INPUT_18       , _INPUT_22       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M5              = np.einsum("aW,PVa->WPVa"  , _INPUT_21       , _M1             )
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.einsum("aT,WPVa->TWPV" , _INPUT_12       , _M5             )
    del _M5         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11             = np.einsum("RS,RPV->SPVR"  , _INPUT_5        , _M10            )
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.einsum("kR,SPVR->kSPV" , _INPUT_7        , _M11            )
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M13             = np.einsum("kW,kSPV->WSPVk", _INPUT_19       , _M12            )
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.einsum("kT,WSPVk->TWSPV", _INPUT_11       , _M13            )
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.einsum("TWSPV,TWPV->STWPV", _M14            , _M15            )
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16_perm        = np.transpose(_M16            , (0, 2, 3, 4, 1) )
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.einsum("TU,SWPVT->USWPV", _INPUT_10       , _M16_perm       )
    del _M16_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M19             = np.einsum("USWPV,USW->PVUSW", _M17            , _M18            )
    del _M17        
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.einsum("PQ,QSV->PSVQ"  , _INPUT_0        , _M6             )
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.einsum("bQ,PSVQ->bPSV" , _INPUT_4        , _M7             )
    del _M7         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9              = np.einsum("VWb,bPSV->WPSVb", _M4             , _M8             )
    del _M4         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.einsum("bU,WPSVb->UWPSV", _INPUT_14       , _M9             )
    del _M9         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20_perm        = np.transpose(_M20            , (2, 4, 0, 3, 1) )
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M21             = np.einsum("PVUSW,PVUSW->" , _M19            , _M20_perm       )
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    return _M21

def RMP3_XX_5_forloop_P_S(Z           : np.ndarray,
                          X_o         : np.ndarray,
                          X_v         : np.ndarray,
                          tau_o       : np.ndarray,
                          tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_o             
    _INPUT_9         = X_o             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # step 0 lS,lW->SWl 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_9.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_9.shape[0]),
                                 ctypes.c_int(_INPUT_9.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    # step 1 lU,SWl->USW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_13_reshaped.T, _M3_reshaped.T, c=_M18_reshaped)
    _M18         = _M18_reshaped.reshape(*shape_backup)
    del _M3         
    del _M3_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    # step 2 aP,aV->PVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    # step 3 iP,iV->PVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    # step 4 iR,PVi->RPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M0.shape[0]
    _size_dim_1      = _size_dim_1 * _M0.shape[1]
    _M0_reshaped = _M0.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_6_reshaped.T, _M0_reshaped.T, c=_M10_reshaped)
    _M10         = _M10_reshaped.reshape(*shape_backup)
    del _M0         
    del _M0_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    # step 5 jS,jV->SVj 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_8.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_8.shape[0]),
                                 ctypes.c_int(_INPUT_8.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    # step 6 jQ,SVj->QSV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6          = _M6_reshaped.reshape(*shape_backup)
    del _M2         
    del _M2_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    # step 7 bV,bW->VWb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M4              = np.ndarray((N_LAPLACE, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_M4.ctypes.data),
                                 ctypes.c_int(_INPUT_18.shape[0]),
                                 ctypes.c_int(_INPUT_18.shape[1]),
                                 ctypes.c_int(_INPUT_22.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    # step 8 aW,PVa->WPVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M5              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_21.ctypes.data),
                                   ctypes.c_void_p(_M1.ctypes.data),
                                   ctypes.c_void_p(_M5.ctypes.data),
                                   ctypes.c_int(_INPUT_21.shape[0]),
                                   ctypes.c_int(_INPUT_21.shape[1]),
                                   ctypes.c_int(_M1.shape[0]),
                                   ctypes.c_int(_M1.shape[1]))
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    # step 9 aT,WPVa->TWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M5.shape[0]
    _size_dim_1      = _size_dim_1 * _M5.shape[1]
    _size_dim_1      = _size_dim_1 * _M5.shape[2]
    _M5_reshaped = _M5.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M15.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M15.shape[0]
    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_12_reshaped.T, _M5_reshaped.T, c=_M15_reshaped)
    _M15         = _M15_reshaped.reshape(*shape_backup)
    del _M5         
    del _M5_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    # step 10 RS,RPV->SPVR 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_023_1230_wob = getattr(libpbc, "fn_contraction_01_023_1230_wob", None)
    assert fn_contraction_01_023_1230_wob is not None
    _M11             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_023_1230_wob(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                   ctypes.c_void_p(_M10.ctypes.data),
                                   ctypes.c_void_p(_M11.ctypes.data),
                                   ctypes.c_int(_INPUT_5.shape[0]),
                                   ctypes.c_int(_INPUT_5.shape[1]),
                                   ctypes.c_int(_M10.shape[1]),
                                   ctypes.c_int(_M10.shape[2]))
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    # step 11 kR,SPVR->kSPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.ndarray((NOCC, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M11.shape[0]
    _size_dim_1      = _size_dim_1 * _M11.shape[1]
    _size_dim_1      = _size_dim_1 * _M11.shape[2]
    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M12.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M12.shape[0]
    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_7_reshaped, _M11_reshaped.T, c=_M12_reshaped)
    _M12         = _M12_reshaped.reshape(*shape_backup)
    del _M11        
    del _M11_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    # step 12 kW,kSPV->WSPVk 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    _M13             = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_19.ctypes.data),
                                     ctypes.c_void_p(_M12.ctypes.data),
                                     ctypes.c_void_p(_M13.ctypes.data),
                                     ctypes.c_int(_INPUT_19.shape[0]),
                                     ctypes.c_int(_INPUT_19.shape[1]),
                                     ctypes.c_int(_M12.shape[1]),
                                     ctypes.c_int(_M12.shape[2]),
                                     ctypes.c_int(_M12.shape[3]))
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    # step 13 kT,WSPVk->TWSPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M13.shape[0]
    _size_dim_1      = _size_dim_1 * _M13.shape[1]
    _size_dim_1      = _size_dim_1 * _M13.shape[2]
    _size_dim_1      = _size_dim_1 * _M13.shape[3]
    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_11_reshaped.T, _M13_reshaped.T, c=_M14_reshaped)
    _M14         = _M14_reshaped.reshape(*shape_backup)
    del _M13        
    del _M13_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    # step 14 TWSPV,TWPV->STWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01234_0134_20134_wob = getattr(libpbc, "fn_contraction_01234_0134_20134_wob", None)
    assert fn_contraction_01234_0134_20134_wob is not None
    _M16             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_01234_0134_20134_wob(ctypes.c_void_p(_M14.ctypes.data),
                                        ctypes.c_void_p(_M15.ctypes.data),
                                        ctypes.c_void_p(_M16.ctypes.data),
                                        ctypes.c_int(_M14.shape[0]),
                                        ctypes.c_int(_M14.shape[1]),
                                        ctypes.c_int(_M14.shape[2]),
                                        ctypes.c_int(_M14.shape[3]),
                                        ctypes.c_int(_M14.shape[4]))
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    # step 15 STWPV->SWPVT 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_02341_wob = getattr(libpbc, "fn_permutation_01234_02341_wob", None)
    assert fn_permutation_01234_02341_wob is not None
    _M16_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_02341_wob(ctypes.c_void_p(_M16.ctypes.data),
                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                   ctypes.c_int(_M16.shape[0]),
                                   ctypes.c_int(_M16.shape[1]),
                                   ctypes.c_int(_M16.shape[2]),
                                   ctypes.c_int(_M16.shape[3]),
                                   ctypes.c_int(_M16.shape[4]))
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    # step 16 TU,SWPVT->USWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M17.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M17.shape[0]
    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
    _M17         = _M17_reshaped.reshape(*shape_backup)
    del _M16_perm   
    del _M16_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    # step 17 USWPV,USW->PVUSW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01234_012_34012_wob = getattr(libpbc, "fn_contraction_01234_012_34012_wob", None)
    assert fn_contraction_01234_012_34012_wob is not None
    _M19             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_01234_012_34012_wob(ctypes.c_void_p(_M17.ctypes.data),
                                       ctypes.c_void_p(_M18.ctypes.data),
                                       ctypes.c_void_p(_M19.ctypes.data),
                                       ctypes.c_int(_M17.shape[0]),
                                       ctypes.c_int(_M17.shape[1]),
                                       ctypes.c_int(_M17.shape[2]),
                                       ctypes.c_int(_M17.shape[3]),
                                       ctypes.c_int(_M17.shape[4]))
    del _M17        
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    # step 18 PQ,QSV->PSVQ 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                   ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M7.ctypes.data),
                                   ctypes.c_int(_INPUT_0.shape[0]),
                                   ctypes.c_int(_INPUT_0.shape[1]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]))
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    # step 19 bQ,PSVQ->bPSV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.ndarray((NVIR, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _size_dim_1      = _size_dim_1 * _M7.shape[1]
    _size_dim_1      = _size_dim_1 * _M7.shape[2]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M8.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M8.shape[0]
    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_4_reshaped, _M7_reshaped.T, c=_M8_reshaped)
    _M8          = _M8_reshaped.reshape(*shape_backup)
    del _M7         
    del _M7_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    # step 20 VWb,bPSV->WPSVb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_2340_13402_wob = getattr(libpbc, "fn_contraction_012_2340_13402_wob", None)
    assert fn_contraction_012_2340_13402_wob is not None
    _M9              = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_012_2340_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                      ctypes.c_void_p(_M8.ctypes.data),
                                      ctypes.c_void_p(_M9.ctypes.data),
                                      ctypes.c_int(_M4.shape[0]),
                                      ctypes.c_int(_M4.shape[1]),
                                      ctypes.c_int(_M4.shape[2]),
                                      ctypes.c_int(_M8.shape[1]),
                                      ctypes.c_int(_M8.shape[2]))
    del _M4         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    # step 21 bU,WPSVb->UWPSV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M9.shape[0]
    _size_dim_1      = _size_dim_1 * _M9.shape[1]
    _size_dim_1      = _size_dim_1 * _M9.shape[2]
    _size_dim_1      = _size_dim_1 * _M9.shape[3]
    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_14_reshaped.T, _M9_reshaped.T, c=_M20_reshaped)
    _M20         = _M20_reshaped.reshape(*shape_backup)
    del _M9         
    del _M9_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    # step 22 UWPSV->PVUSW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_24031_wob = getattr(libpbc, "fn_permutation_01234_24031_wob", None)
    assert fn_permutation_01234_24031_wob is not None
    _M20_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_permutation_01234_24031_wob(ctypes.c_void_p(_M20.ctypes.data),
                                   ctypes.c_void_p(_M20_perm.ctypes.data),
                                   ctypes.c_int(_M20.shape[0]),
                                   ctypes.c_int(_M20.shape[1]),
                                   ctypes.c_int(_M20.shape[2]),
                                   ctypes.c_int(_M20.shape[3]),
                                   ctypes.c_int(_M20.shape[4]))
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    # step 23 PVUSW,PVUSW-> 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    _M21             = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20_perm.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(_M21))
    _M21 = _M21.value
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    return _M21

def RMP3_XX_5_forloop_P_S_forloop_P_S(Z           : np.ndarray,
                                      X_o         : np.ndarray,
                                      X_v         : np.ndarray,
                                      tau_o       : np.ndarray,
                                      tau_v       : np.ndarray,
                                      buffer      : np.ndarray,
                                      P_bunchsize = 8,
                                      S_bunchsize = 8,
                                      V_bunchsize = 1,
                                      W_bunchsize = 1,
                                      use_mpi = False):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_o             
    _INPUT_9         = X_o             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # fetch function pointers
    fn_permutation_01234_24031_wob = getattr(libpbc, "fn_permutation_01234_24031_wob", None)
    assert fn_permutation_01234_24031_wob is not None
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    fn_slice_3_1_2 = getattr(libpbc, "fn_slice_3_1_2", None)
    assert fn_slice_3_1_2 is not None
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    fn_slice_2_1 = getattr(libpbc, "fn_slice_2_1", None)
    assert fn_slice_2_1 is not None
    fn_slice_2_0 = getattr(libpbc, "fn_slice_2_0", None)
    assert fn_slice_2_0 is not None
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    fn_slice_3_0_1 = getattr(libpbc, "fn_slice_3_0_1", None)
    assert fn_slice_3_0_1 is not None
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    fn_contraction_01_023_1230_wob = getattr(libpbc, "fn_contraction_01_023_1230_wob", None)
    assert fn_contraction_01_023_1230_wob is not None
    fn_permutation_01234_02341_wob = getattr(libpbc, "fn_permutation_01234_02341_wob", None)
    assert fn_permutation_01234_02341_wob is not None
    fn_contraction_012_2340_13402_wob = getattr(libpbc, "fn_contraction_012_2340_13402_wob", None)
    assert fn_contraction_012_2340_13402_wob is not None
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    fn_contraction_01234_012_34012_wob = getattr(libpbc, "fn_contraction_01234_012_34012_wob", None)
    assert fn_contraction_01234_012_34012_wob is not None
    fn_contraction_01234_0134_20134_wob = getattr(libpbc, "fn_contraction_01234_0134_20134_wob", None)
    assert fn_contraction_01234_0134_20134_wob is not None
    if use_mpi:
        bunchsize = NTHC_INT//comm_size + 1
        P_begin = rank*bunchsize
        P_end = (rank+1)*bunchsize
        P_begin          = min(P_begin, NTHC_INT)
        P_end            = min(P_end, NTHC_INT)
    else:
        P_begin          = 0               
        P_end            = NTHC_INT        
    # preallocate buffer
    bucket_size      = RMP3_XX_5_forloop_P_S_determine_bucket_size_forloop(NVIR = NVIR,
                                                                           NOCC = NOCC,
                                                                           N_LAPLACE = N_LAPLACE,
                                                                           NTHC_INT = NTHC_INT,
                                                                           V_bunchsize = V_bunchsize,
                                                                           W_bunchsize = W_bunchsize,
                                                                           P_bunchsize = P_bunchsize,
                                                                           S_bunchsize = S_bunchsize)
    bufsize_now      = buffer.size     
    _itemsize        = buffer.itemsize 
    offset_now       = 0               
    offset_0         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[0])
    offset_1         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[1])
    offset_2         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[2])
    offset_3         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[3])
    offset_4         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[4])
    offset_5         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[5])
    offset_6         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[6])
    offset_7         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[7])
    offset_8         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[8])
    offset_9         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[9])
    bufsize          = offset_now      
    if (bufsize > bufsize_now):
        buffer           = np.ndarray((bufsize), dtype=np.float64)
    # step   0 start for loop with indices ()
    # step   1 allocate   _M21
    _M21             = 0.0             
    # step   2 lS,lW->SWl
    offset_now       = offset_0        
    _M3_offset       = offset_now      
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M3_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_9.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_9.shape[0]),
                                 ctypes.c_int(_INPUT_9.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    # step   3 lU,SWl->USW
    offset_now       = offset_1        
    _M18_offset      = offset_now      
    _M18             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M18_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_13_reshaped.T, _M3_reshaped.T, c=_M18_reshaped)
    _M18             = _M18_reshaped.reshape(*shape_backup)
    # step   4 aP,aV->PVa
    offset_now       = offset_0        
    _M1_offset       = offset_now      
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M1_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    # step   5 iP,iV->PVi
    offset_now       = offset_2        
    _M0_offset       = offset_now      
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M0_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    # step   6 iR,PVi->RPV
    offset_now       = offset_3        
    _M10_offset      = offset_now      
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M10_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M0.shape[0]
    _size_dim_1      = _size_dim_1 * _M0.shape[1]
    _M0_reshaped = _M0.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_6_reshaped.T, _M0_reshaped.T, c=_M10_reshaped)
    _M10             = _M10_reshaped.reshape(*shape_backup)
    # step   7 jS,jV->SVj
    offset_now       = offset_2        
    _M2_offset       = offset_now      
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M2_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_8.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_8.shape[0]),
                                 ctypes.c_int(_INPUT_8.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    # step   8 jQ,SVj->QSV
    offset_now       = offset_4        
    _M6_offset       = offset_now      
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M6_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6              = _M6_reshaped.reshape(*shape_backup)
    # step   9 start for loop with indices ('V',)
    for V_0, V_1 in lib.prange(0,N_LAPLACE,V_bunchsize):
        # step  10 start for loop with indices ('V', 'W')
        for W_0, W_1 in lib.prange(0,N_LAPLACE,W_bunchsize):
            # step  11 slice _INPUT_18 with indices ['V']
            _INPUT_18_sliced_offset = offset_2        
            _INPUT_18_sliced = np.ndarray((NVIR, (V_1-V_0)), buffer = buffer, offset = _INPUT_18_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_18.ctypes.data),
                         ctypes.c_void_p(_INPUT_18_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_18.shape[0]),
                         ctypes.c_int(_INPUT_18.shape[1]),
                         ctypes.c_int(V_0),
                         ctypes.c_int(V_1))
            # step  12 slice _INPUT_22 with indices ['W']
            _INPUT_22_sliced_offset = offset_5        
            _INPUT_22_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_22_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_22.ctypes.data),
                         ctypes.c_void_p(_INPUT_22_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_22.shape[0]),
                         ctypes.c_int(_INPUT_22.shape[1]),
                         ctypes.c_int(W_0),
                         ctypes.c_int(W_1))
            # step  13 bV,bW->VWb
            offset_now       = offset_6        
            _M4_offset       = offset_now      
            _M4              = np.ndarray(((V_1-V_0), (W_1-W_0), NVIR), buffer = buffer, offset = _M4_offset)
            fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_18_sliced.ctypes.data),
                                         ctypes.c_void_p(_INPUT_22_sliced.ctypes.data),
                                         ctypes.c_void_p(_M4.ctypes.data),
                                         ctypes.c_int(_INPUT_18_sliced.shape[0]),
                                         ctypes.c_int(_INPUT_18_sliced.shape[1]),
                                         ctypes.c_int(_INPUT_22_sliced.shape[1]))
            # step  14 start for loop with indices ('V', 'W', 'P')
            for P_0, P_1 in lib.prange(P_begin,P_end,P_bunchsize):
                # step  15 slice _INPUT_21 with indices ['W']
                _INPUT_21_sliced_offset = offset_2        
                _INPUT_21_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_21_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_21.ctypes.data),
                             ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_21.shape[0]),
                             ctypes.c_int(_INPUT_21.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  16 slice _M1 with indices ['P', 'V']
                _M1_sliced_offset = offset_5        
                _M1_sliced       = np.ndarray(((P_1-P_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M1_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M1.ctypes.data),
                               ctypes.c_void_p(_M1_sliced.ctypes.data),
                               ctypes.c_int(_M1.shape[0]),
                               ctypes.c_int(_M1.shape[1]),
                               ctypes.c_int(_M1.shape[2]),
                               ctypes.c_int(P_0),
                               ctypes.c_int(P_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  17 aW,PVa->WPVa
                offset_now       = offset_7        
                _M5_offset       = offset_now      
                _M5              = np.ndarray(((W_1-W_0), (P_1-P_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M5_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                                               ctypes.c_void_p(_M1_sliced.ctypes.data),
                                               ctypes.c_void_p(_M5.ctypes.data),
                                               ctypes.c_int(_INPUT_21_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_21_sliced.shape[1]),
                                               ctypes.c_int(_M1_sliced.shape[0]),
                                               ctypes.c_int(_M1_sliced.shape[1]))
                # step  18 aT,WPVa->TWPV
                offset_now       = offset_2        
                _M15_offset      = offset_now      
                _M15             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M15_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
                _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M5.shape[0]
                _size_dim_1      = _size_dim_1 * _M5.shape[1]
                _size_dim_1      = _size_dim_1 * _M5.shape[2]
                _M5_reshaped = _M5.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M15.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M15.shape[0]
                _M15_reshaped = _M15.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_12_reshaped.T, _M5_reshaped.T, c=_M15_reshaped)
                _M15             = _M15_reshaped.reshape(*shape_backup)
                # step  19 start for loop with indices ('V', 'W', 'P', 'S')
                for S_0, S_1 in lib.prange(0,NTHC_INT,S_bunchsize):
                    # step  20 slice _INPUT_5 with indices ['S']
                    _INPUT_5_sliced_offset = offset_5        
                    _INPUT_5_sliced  = np.ndarray((NTHC_INT, (S_1-S_0)), buffer = buffer, offset = _INPUT_5_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                 ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_5.shape[0]),
                                 ctypes.c_int(_INPUT_5.shape[1]),
                                 ctypes.c_int(S_0),
                                 ctypes.c_int(S_1))
                    # step  21 slice _M10 with indices ['P', 'V']
                    _M10_sliced_offset = offset_7        
                    _M10_sliced      = np.ndarray((NTHC_INT, (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M10_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M10.ctypes.data),
                                   ctypes.c_void_p(_M10_sliced.ctypes.data),
                                   ctypes.c_int(_M10.shape[0]),
                                   ctypes.c_int(_M10.shape[1]),
                                   ctypes.c_int(_M10.shape[2]),
                                   ctypes.c_int(P_0),
                                   ctypes.c_int(P_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  22 RS,RPV->SPVR
                    offset_now       = offset_8        
                    _M11_offset      = offset_now      
                    _M11             = np.ndarray(((S_1-S_0), (P_1-P_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M11_offset)
                    fn_contraction_01_023_1230_wob(ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M10_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M11.ctypes.data),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[1]),
                                                   ctypes.c_int(_M10_sliced.shape[1]),
                                                   ctypes.c_int(_M10_sliced.shape[2]))
                    # step  23 kR,SPVR->kSPV
                    offset_now       = offset_5        
                    _M12_offset      = offset_now      
                    _M12             = np.ndarray((NOCC, (S_1-S_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M12_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
                    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M11.shape[0]
                    _size_dim_1      = _size_dim_1 * _M11.shape[1]
                    _size_dim_1      = _size_dim_1 * _M11.shape[2]
                    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M12.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M12.shape[0]
                    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_7_reshaped, _M11_reshaped.T, c=_M12_reshaped)
                    _M12             = _M12_reshaped.reshape(*shape_backup)
                    # step  24 slice _INPUT_19 with indices ['W']
                    _INPUT_19_sliced_offset = offset_7        
                    _INPUT_19_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_19_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_19.ctypes.data),
                                 ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_19.shape[0]),
                                 ctypes.c_int(_INPUT_19.shape[1]),
                                 ctypes.c_int(W_0),
                                 ctypes.c_int(W_1))
                    # step  25 kW,kSPV->WSPVk
                    offset_now       = offset_8        
                    _M13_offset      = offset_now      
                    _M13             = np.ndarray(((W_1-W_0), (S_1-S_0), (P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M13_offset)
                    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                                                     ctypes.c_void_p(_M12.ctypes.data),
                                                     ctypes.c_void_p(_M13.ctypes.data),
                                                     ctypes.c_int(_INPUT_19_sliced.shape[0]),
                                                     ctypes.c_int(_INPUT_19_sliced.shape[1]),
                                                     ctypes.c_int(_M12.shape[1]),
                                                     ctypes.c_int(_M12.shape[2]),
                                                     ctypes.c_int(_M12.shape[3]))
                    # step  26 kT,WSPVk->TWSPV
                    offset_now       = offset_5        
                    _M14_offset      = offset_now      
                    _M14             = np.ndarray((NTHC_INT, (W_1-W_0), (S_1-S_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M14_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
                    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M13.shape[0]
                    _size_dim_1      = _size_dim_1 * _M13.shape[1]
                    _size_dim_1      = _size_dim_1 * _M13.shape[2]
                    _size_dim_1      = _size_dim_1 * _M13.shape[3]
                    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M14.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M14.shape[0]
                    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_11_reshaped.T, _M13_reshaped.T, c=_M14_reshaped)
                    _M14             = _M14_reshaped.reshape(*shape_backup)
                    # step  27 TWSPV,TWPV->STWPV
                    offset_now       = offset_7        
                    _M16_offset      = offset_now      
                    _M16             = np.ndarray(((S_1-S_0), NTHC_INT, (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M16_offset)
                    fn_contraction_01234_0134_20134_wob(ctypes.c_void_p(_M14.ctypes.data),
                                                        ctypes.c_void_p(_M15.ctypes.data),
                                                        ctypes.c_void_p(_M16.ctypes.data),
                                                        ctypes.c_int(_M14.shape[0]),
                                                        ctypes.c_int(_M14.shape[1]),
                                                        ctypes.c_int(_M14.shape[2]),
                                                        ctypes.c_int(_M14.shape[3]),
                                                        ctypes.c_int(_M14.shape[4]))
                    # step  28 STWPV->SWPVT
                    _M16_perm_offset = offset_5        
                    _M16_perm        = np.ndarray(((S_1-S_0), (W_1-W_0), (P_1-P_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M16_perm_offset)
                    fn_permutation_01234_02341_wob(ctypes.c_void_p(_M16.ctypes.data),
                                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                                   ctypes.c_int((S_1-S_0)),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  29 TU,SWPVT->USWPV
                    offset_now       = offset_7        
                    _M17_offset      = offset_now      
                    _M17             = np.ndarray((NTHC_INT, (S_1-S_0), (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M17_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
                    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
                    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M17.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M17.shape[0]
                    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
                    _M17             = _M17_reshaped.reshape(*shape_backup)
                    # step  30 slice _M18 with indices ['S', 'W']
                    _M18_sliced_offset = offset_5        
                    _M18_sliced      = np.ndarray((NTHC_INT, (S_1-S_0), (W_1-W_0)), buffer = buffer, offset = _M18_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M18.ctypes.data),
                                   ctypes.c_void_p(_M18_sliced.ctypes.data),
                                   ctypes.c_int(_M18.shape[0]),
                                   ctypes.c_int(_M18.shape[1]),
                                   ctypes.c_int(_M18.shape[2]),
                                   ctypes.c_int(S_0),
                                   ctypes.c_int(S_1),
                                   ctypes.c_int(W_0),
                                   ctypes.c_int(W_1))
                    # step  31 USWPV,USW->PVUSW
                    offset_now       = offset_8        
                    _M19_offset      = offset_now      
                    _M19             = np.ndarray(((P_1-P_0), (V_1-V_0), NTHC_INT, (S_1-S_0), (W_1-W_0)), buffer = buffer, offset = _M19_offset)
                    fn_contraction_01234_012_34012_wob(ctypes.c_void_p(_M17.ctypes.data),
                                                       ctypes.c_void_p(_M18_sliced.ctypes.data),
                                                       ctypes.c_void_p(_M19.ctypes.data),
                                                       ctypes.c_int(_M17.shape[0]),
                                                       ctypes.c_int(_M17.shape[1]),
                                                       ctypes.c_int(_M17.shape[2]),
                                                       ctypes.c_int(_M17.shape[3]),
                                                       ctypes.c_int(_M17.shape[4]))
                    # step  32 slice _INPUT_0 with indices ['P']
                    _INPUT_0_sliced_offset = offset_5        
                    _INPUT_0_sliced  = np.ndarray(((P_1-P_0), NTHC_INT), buffer = buffer, offset = _INPUT_0_sliced_offset)
                    fn_slice_2_0(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                 ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_0.shape[0]),
                                 ctypes.c_int(_INPUT_0.shape[1]),
                                 ctypes.c_int(P_0),
                                 ctypes.c_int(P_1))
                    # step  33 slice _M6 with indices ['S', 'V']
                    _M6_sliced_offset = offset_7        
                    _M6_sliced       = np.ndarray((NTHC_INT, (S_1-S_0), (V_1-V_0)), buffer = buffer, offset = _M6_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                   ctypes.c_int(_M6.shape[0]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]),
                                   ctypes.c_int(S_0),
                                   ctypes.c_int(S_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  34 PQ,QSV->PSVQ
                    offset_now       = offset_9        
                    _M7_offset       = offset_now      
                    _M7              = np.ndarray(((P_1-P_0), (S_1-S_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M7_offset)
                    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M7.ctypes.data),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[2]))
                    # step  35 bQ,PSVQ->bPSV
                    offset_now       = offset_5        
                    _M8_offset       = offset_now      
                    _M8              = np.ndarray((NVIR, (P_1-P_0), (S_1-S_0), (V_1-V_0)), buffer = buffer, offset = _M8_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
                    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M7.shape[0]
                    _size_dim_1      = _size_dim_1 * _M7.shape[1]
                    _size_dim_1      = _size_dim_1 * _M7.shape[2]
                    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M8.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M8.shape[0]
                    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_4_reshaped, _M7_reshaped.T, c=_M8_reshaped)
                    _M8              = _M8_reshaped.reshape(*shape_backup)
                    # step  36 VWb,bPSV->WPSVb
                    offset_now       = offset_7        
                    _M9_offset       = offset_now      
                    _M9              = np.ndarray(((W_1-W_0), (P_1-P_0), (S_1-S_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M9_offset)
                    fn_contraction_012_2340_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                                      ctypes.c_void_p(_M8.ctypes.data),
                                                      ctypes.c_void_p(_M9.ctypes.data),
                                                      ctypes.c_int(_M4.shape[0]),
                                                      ctypes.c_int(_M4.shape[1]),
                                                      ctypes.c_int(_M4.shape[2]),
                                                      ctypes.c_int(_M8.shape[1]),
                                                      ctypes.c_int(_M8.shape[2]))
                    # step  37 bU,WPSVb->UWPSV
                    offset_now       = offset_5        
                    _M20_offset      = offset_now      
                    _M20             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (S_1-S_0), (V_1-V_0)), buffer = buffer, offset = _M20_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
                    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M9.shape[0]
                    _size_dim_1      = _size_dim_1 * _M9.shape[1]
                    _size_dim_1      = _size_dim_1 * _M9.shape[2]
                    _size_dim_1      = _size_dim_1 * _M9.shape[3]
                    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M20.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M20.shape[0]
                    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_14_reshaped.T, _M9_reshaped.T, c=_M20_reshaped)
                    _M20             = _M20_reshaped.reshape(*shape_backup)
                    # step  38 UWPSV->PVUSW
                    _M20_perm_offset = offset_7        
                    _M20_perm        = np.ndarray(((P_1-P_0), (V_1-V_0), NTHC_INT, (S_1-S_0), (W_1-W_0)), buffer = buffer, offset = _M20_perm_offset)
                    fn_permutation_01234_24031_wob(ctypes.c_void_p(_M20.ctypes.data),
                                                   ctypes.c_void_p(_M20_perm.ctypes.data),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((S_1-S_0)),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  39 PVUSW,PVUSW->
                    output_tmp       = ctypes.c_double(0.0)
                    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
                           ctypes.c_void_p(_M20_perm.ctypes.data),
                           ctypes.c_int(_M19.size),
                           ctypes.pointer(output_tmp))
                    output_tmp = output_tmp.value
                    _M21 += output_tmp
                # step  40 end   for loop with indices ('V', 'W', 'P', 'S')
            # step  41 end   for loop with indices ('V', 'W', 'P')
        # step  42 end   for loop with indices ('V', 'W')
    # step  43 end   for loop with indices ('V',)
    # clean the final forloop
    # MPI finalize
    if use_mpi:
        _M21 = reduce(_M21, root=0)
        _M21 = bcast(_M21, root=0)
    return _M21

def RMP3_XX_6_forloop_P_S_determine_bucket_size_forloop(NVIR        : int,
                                                        NOCC        : int,
                                                        N_LAPLACE   : int,
                                                        NTHC_INT    : int,
                                                        P_bunchsize = 8,
                                                        S_bunchsize = 8,
                                                        V_bunchsize = 1,
                                                        W_bunchsize = 1):
    # init
    output = []     
    bucked_0_size    = 0               
    bucked_1_size    = 0               
    bucked_2_size    = 0               
    bucked_3_size    = 0               
    bucked_4_size    = 0               
    bucked_5_size    = 0               
    bucked_6_size    = 0               
    bucked_7_size    = 0               
    bucked_8_size    = 0               
    bucked_9_size    = 0               
    bucked_10_size   = 0               
    # assign the size of each tensor
    _M1_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M3_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M18_perm_size   = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M18_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M0_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M2_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _INPUT_17_sliced_size = (NVIR * N_LAPLACE)
    _INPUT_22_sliced_size = (NVIR * N_LAPLACE)
    _M20_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize)))
    _M10_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M6_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _INPUT_21_sliced_size = (NVIR * N_LAPLACE)
    _M1_sliced_size  = (P_bunchsize * (V_bunchsize * NVIR))
    _M19_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize)))
    _M4_size         = (V_bunchsize * (W_bunchsize * NVIR))
    _M5_size         = (W_bunchsize * (P_bunchsize * (V_bunchsize * NVIR)))
    _INPUT_5_sliced_size = (NTHC_INT * NTHC_INT)
    _M12_size        = (NOCC * (S_bunchsize * (P_bunchsize * V_bunchsize)))
    _M14_size        = (NTHC_INT * (W_bunchsize * (S_bunchsize * (P_bunchsize * V_bunchsize))))
    _M17_size        = (NTHC_INT * (W_bunchsize * (S_bunchsize * (P_bunchsize * V_bunchsize))))
    _M10_sliced_size = (NTHC_INT * (P_bunchsize * V_bunchsize))
    _INPUT_19_sliced_size = (NOCC * N_LAPLACE)
    _INPUT_0_sliced_size = (NTHC_INT * NTHC_INT)
    _M8_size         = (NVIR * (P_bunchsize * (S_bunchsize * V_bunchsize)))
    _M15_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * (S_bunchsize * V_bunchsize))))
    _M18_perm_sliced_size = (NTHC_INT * (S_bunchsize * W_bunchsize))
    _M11_size        = (S_bunchsize * (P_bunchsize * (V_bunchsize * NTHC_INT)))
    _M13_size        = (W_bunchsize * (S_bunchsize * (P_bunchsize * (V_bunchsize * NOCC))))
    _M6_sliced_size  = (NTHC_INT * (S_bunchsize * V_bunchsize))
    _M9_size         = (W_bunchsize * (P_bunchsize * (S_bunchsize * (V_bunchsize * NVIR))))
    _M16_size        = (NTHC_INT * (W_bunchsize * (S_bunchsize * (P_bunchsize * V_bunchsize))))
    _M7_size         = (P_bunchsize * (S_bunchsize * (V_bunchsize * NTHC_INT)))
    # determine the size of each bucket
    # bucket 0
    bucked_0_size    = max(bucked_0_size, _M1_size)
    # bucket 1
    bucked_1_size    = max(bucked_1_size, _M3_size)
    bucked_1_size    = max(bucked_1_size, _M18_perm_size)
    # bucket 2
    bucked_2_size    = max(bucked_2_size, _M18_size)
    bucked_2_size    = max(bucked_2_size, _M0_size)
    bucked_2_size    = max(bucked_2_size, _M2_size)
    bucked_2_size    = max(bucked_2_size, _INPUT_17_sliced_size)
    bucked_2_size    = max(bucked_2_size, _INPUT_22_sliced_size)
    bucked_2_size    = max(bucked_2_size, _M20_size)
    # bucket 3
    bucked_3_size    = max(bucked_3_size, _M10_size)
    # bucket 4
    bucked_4_size    = max(bucked_4_size, _M6_size)
    # bucket 5
    bucked_5_size    = max(bucked_5_size, _INPUT_21_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M1_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M19_size)
    # bucket 6
    bucked_6_size    = max(bucked_6_size, _M4_size)
    # bucket 7
    bucked_7_size    = max(bucked_7_size, _M5_size)
    bucked_7_size    = max(bucked_7_size, _INPUT_5_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M12_size)
    bucked_7_size    = max(bucked_7_size, _M14_size)
    bucked_7_size    = max(bucked_7_size, _M17_size)
    # bucket 8
    bucked_8_size    = max(bucked_8_size, _M10_sliced_size)
    bucked_8_size    = max(bucked_8_size, _INPUT_19_sliced_size)
    bucked_8_size    = max(bucked_8_size, _INPUT_0_sliced_size)
    bucked_8_size    = max(bucked_8_size, _M8_size)
    bucked_8_size    = max(bucked_8_size, _M15_size)
    bucked_8_size    = max(bucked_8_size, _M18_perm_sliced_size)
    # bucket 9
    bucked_9_size    = max(bucked_9_size, _M11_size)
    bucked_9_size    = max(bucked_9_size, _M13_size)
    bucked_9_size    = max(bucked_9_size, _M6_sliced_size)
    bucked_9_size    = max(bucked_9_size, _M9_size)
    bucked_9_size    = max(bucked_9_size, _M16_size)
    # bucket 10
    bucked_10_size   = max(bucked_10_size, _M7_size)
    # append each bucket size to the output
    output.append(bucked_0_size)
    output.append(bucked_1_size)
    output.append(bucked_2_size)
    output.append(bucked_3_size)
    output.append(bucked_4_size)
    output.append(bucked_5_size)
    output.append(bucked_6_size)
    output.append(bucked_7_size)
    output.append(bucked_8_size)
    output.append(bucked_9_size)
    output.append(bucked_10_size)
    return output

def RMP3_XX_6_forloop_P_S_naive(Z           : np.ndarray,
                                X_o         : np.ndarray,
                                X_v         : np.ndarray,
                                tau_o       : np.ndarray,
                                tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_o             
    _INPUT_9         = X_o             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    t1 = (logger.process_clock(), logger.perf_counter())
    _M1              = np.einsum("bP,bV->PVb"    , _INPUT_2        , _INPUT_18       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M3              = np.einsum("lS,lW->SWl"    , _INPUT_9        , _INPUT_20       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.einsum("lU,SWl->USW"   , _INPUT_13       , _M3             )
    del _M3         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18_perm        = np.transpose(_M18            , (0, 2, 1)       )
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M0              = np.einsum("iP,iV->PVi"    , _INPUT_1        , _INPUT_15       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.einsum("iR,PVi->RPV"   , _INPUT_6        , _M0             )
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M2              = np.einsum("jS,jV->SVj"    , _INPUT_8        , _INPUT_16       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.einsum("jQ,SVj->QSV"   , _INPUT_3        , _M2             )
    del _M2         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M4              = np.einsum("aV,aW->VWa"    , _INPUT_17       , _INPUT_21       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M5              = np.einsum("bW,PVb->WPVb"  , _INPUT_22       , _M1             )
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.einsum("bU,WPVb->UWPV" , _INPUT_14       , _M5             )
    del _M5         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11             = np.einsum("RS,RPV->SPVR"  , _INPUT_5        , _M10            )
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.einsum("kR,SPVR->kSPV" , _INPUT_7        , _M11            )
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M13             = np.einsum("kW,kSPV->WSPVk", _INPUT_19       , _M12            )
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.einsum("kT,WSPVk->TWSPV", _INPUT_11       , _M13            )
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.einsum("PQ,QSV->PSVQ"  , _INPUT_0        , _M6             )
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.einsum("aQ,PSVQ->aPSV" , _INPUT_4        , _M7             )
    del _M7         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9              = np.einsum("VWa,aPSV->WPSVa", _M4             , _M8             )
    del _M4         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.einsum("aT,WPSVa->TWPSV", _INPUT_12       , _M9             )
    del _M9         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.einsum("TWSPV,TWPSV->TWSPV", _M14            , _M15            )
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.einsum("TU,TWSPV->UWSPV", _INPUT_10       , _M16            )
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M19             = np.einsum("UWSPV,UWS->UWPV", _M17            , _M18_perm       )
    del _M17        
    del _M18_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M21             = np.einsum("UWPV,UWPV->"   , _M19            , _M20            )
    del _M19        
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    return _M21

def RMP3_XX_6_forloop_P_S(Z           : np.ndarray,
                          X_o         : np.ndarray,
                          X_v         : np.ndarray,
                          tau_o       : np.ndarray,
                          tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_o             
    _INPUT_9         = X_o             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # step 0 bP,bV->PVb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    # step 1 lS,lW->SWl 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_9.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_9.shape[0]),
                                 ctypes.c_int(_INPUT_9.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    # step 2 lU,SWl->USW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_13_reshaped.T, _M3_reshaped.T, c=_M18_reshaped)
    _M18         = _M18_reshaped.reshape(*shape_backup)
    del _M3         
    del _M3_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    # step 3 USW->UWS 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_012_021_wob = getattr(libpbc, "fn_permutation_012_021_wob", None)
    assert fn_permutation_012_021_wob is not None
    _M18_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_012_021_wob(ctypes.c_void_p(_M18.ctypes.data),
                               ctypes.c_void_p(_M18_perm.ctypes.data),
                               ctypes.c_int(_M18.shape[0]),
                               ctypes.c_int(_M18.shape[1]),
                               ctypes.c_int(_M18.shape[2]))
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    # step 4 iP,iV->PVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    # step 5 iR,PVi->RPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M0.shape[0]
    _size_dim_1      = _size_dim_1 * _M0.shape[1]
    _M0_reshaped = _M0.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_6_reshaped.T, _M0_reshaped.T, c=_M10_reshaped)
    _M10         = _M10_reshaped.reshape(*shape_backup)
    del _M0         
    del _M0_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    # step 6 jS,jV->SVj 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_8.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_8.shape[0]),
                                 ctypes.c_int(_INPUT_8.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    # step 7 jQ,SVj->QSV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6          = _M6_reshaped.reshape(*shape_backup)
    del _M2         
    del _M2_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    # step 8 aV,aW->VWa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M4              = np.ndarray((N_LAPLACE, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_INPUT_21.ctypes.data),
                                 ctypes.c_void_p(_M4.ctypes.data),
                                 ctypes.c_int(_INPUT_17.shape[0]),
                                 ctypes.c_int(_INPUT_17.shape[1]),
                                 ctypes.c_int(_INPUT_21.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    # step 9 bW,PVb->WPVb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M5              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_22.ctypes.data),
                                   ctypes.c_void_p(_M1.ctypes.data),
                                   ctypes.c_void_p(_M5.ctypes.data),
                                   ctypes.c_int(_INPUT_22.shape[0]),
                                   ctypes.c_int(_INPUT_22.shape[1]),
                                   ctypes.c_int(_M1.shape[0]),
                                   ctypes.c_int(_M1.shape[1]))
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    # step 10 bU,WPVb->UWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M5.shape[0]
    _size_dim_1      = _size_dim_1 * _M5.shape[1]
    _size_dim_1      = _size_dim_1 * _M5.shape[2]
    _M5_reshaped = _M5.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_14_reshaped.T, _M5_reshaped.T, c=_M20_reshaped)
    _M20         = _M20_reshaped.reshape(*shape_backup)
    del _M5         
    del _M5_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    # step 11 RS,RPV->SPVR 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_023_1230_wob = getattr(libpbc, "fn_contraction_01_023_1230_wob", None)
    assert fn_contraction_01_023_1230_wob is not None
    _M11             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_023_1230_wob(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                   ctypes.c_void_p(_M10.ctypes.data),
                                   ctypes.c_void_p(_M11.ctypes.data),
                                   ctypes.c_int(_INPUT_5.shape[0]),
                                   ctypes.c_int(_INPUT_5.shape[1]),
                                   ctypes.c_int(_M10.shape[1]),
                                   ctypes.c_int(_M10.shape[2]))
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    # step 12 kR,SPVR->kSPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.ndarray((NOCC, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M11.shape[0]
    _size_dim_1      = _size_dim_1 * _M11.shape[1]
    _size_dim_1      = _size_dim_1 * _M11.shape[2]
    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M12.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M12.shape[0]
    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_7_reshaped, _M11_reshaped.T, c=_M12_reshaped)
    _M12         = _M12_reshaped.reshape(*shape_backup)
    del _M11        
    del _M11_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    # step 13 kW,kSPV->WSPVk 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    _M13             = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_19.ctypes.data),
                                     ctypes.c_void_p(_M12.ctypes.data),
                                     ctypes.c_void_p(_M13.ctypes.data),
                                     ctypes.c_int(_INPUT_19.shape[0]),
                                     ctypes.c_int(_INPUT_19.shape[1]),
                                     ctypes.c_int(_M12.shape[1]),
                                     ctypes.c_int(_M12.shape[2]),
                                     ctypes.c_int(_M12.shape[3]))
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    # step 14 kT,WSPVk->TWSPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M13.shape[0]
    _size_dim_1      = _size_dim_1 * _M13.shape[1]
    _size_dim_1      = _size_dim_1 * _M13.shape[2]
    _size_dim_1      = _size_dim_1 * _M13.shape[3]
    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_11_reshaped.T, _M13_reshaped.T, c=_M14_reshaped)
    _M14         = _M14_reshaped.reshape(*shape_backup)
    del _M13        
    del _M13_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    # step 15 PQ,QSV->PSVQ 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                   ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M7.ctypes.data),
                                   ctypes.c_int(_INPUT_0.shape[0]),
                                   ctypes.c_int(_INPUT_0.shape[1]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]))
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    # step 16 aQ,PSVQ->aPSV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.ndarray((NVIR, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _size_dim_1      = _size_dim_1 * _M7.shape[1]
    _size_dim_1      = _size_dim_1 * _M7.shape[2]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M8.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M8.shape[0]
    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_4_reshaped, _M7_reshaped.T, c=_M8_reshaped)
    _M8          = _M8_reshaped.reshape(*shape_backup)
    del _M7         
    del _M7_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    # step 17 VWa,aPSV->WPSVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_2340_13402_wob = getattr(libpbc, "fn_contraction_012_2340_13402_wob", None)
    assert fn_contraction_012_2340_13402_wob is not None
    _M9              = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_012_2340_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                      ctypes.c_void_p(_M8.ctypes.data),
                                      ctypes.c_void_p(_M9.ctypes.data),
                                      ctypes.c_int(_M4.shape[0]),
                                      ctypes.c_int(_M4.shape[1]),
                                      ctypes.c_int(_M4.shape[2]),
                                      ctypes.c_int(_M8.shape[1]),
                                      ctypes.c_int(_M8.shape[2]))
    del _M4         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    # step 18 aT,WPSVa->TWPSV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M9.shape[0]
    _size_dim_1      = _size_dim_1 * _M9.shape[1]
    _size_dim_1      = _size_dim_1 * _M9.shape[2]
    _size_dim_1      = _size_dim_1 * _M9.shape[3]
    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M15.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M15.shape[0]
    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_12_reshaped.T, _M9_reshaped.T, c=_M15_reshaped)
    _M15         = _M15_reshaped.reshape(*shape_backup)
    del _M9         
    del _M9_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    # step 19 TWSPV,TWPSV->TWSPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01234_01324_01234_wob = getattr(libpbc, "fn_contraction_01234_01324_01234_wob", None)
    assert fn_contraction_01234_01324_01234_wob is not None
    _M16             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_01234_01324_01234_wob(ctypes.c_void_p(_M14.ctypes.data),
                                         ctypes.c_void_p(_M15.ctypes.data),
                                         ctypes.c_void_p(_M16.ctypes.data),
                                         ctypes.c_int(_M14.shape[0]),
                                         ctypes.c_int(_M14.shape[1]),
                                         ctypes.c_int(_M14.shape[2]),
                                         ctypes.c_int(_M14.shape[3]),
                                         ctypes.c_int(_M14.shape[4]))
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    # step 20 TU,TWSPV->UWSPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M16.shape[0]
    _M16_reshaped = _M16.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M17.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M17.shape[0]
    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_10_reshaped.T, _M16_reshaped, c=_M17_reshaped)
    _M17         = _M17_reshaped.reshape(*shape_backup)
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    # step 21 UWSPV,UWS->UWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01234_012_0134_wob = getattr(libpbc, "fn_contraction_01234_012_0134_wob", None)
    assert fn_contraction_01234_012_0134_wob is not None
    _M19             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_01234_012_0134_wob(ctypes.c_void_p(_M17.ctypes.data),
                                      ctypes.c_void_p(_M18_perm.ctypes.data),
                                      ctypes.c_void_p(_M19.ctypes.data),
                                      ctypes.c_int(_M17.shape[0]),
                                      ctypes.c_int(_M17.shape[1]),
                                      ctypes.c_int(_M17.shape[2]),
                                      ctypes.c_int(_M17.shape[3]),
                                      ctypes.c_int(_M17.shape[4]))
    del _M17        
    del _M18_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    # step 22 UWPV,UWPV-> 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    _M21             = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(_M21))
    _M21 = _M21.value
    del _M19        
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    return _M21

def RMP3_XX_6_forloop_P_S_forloop_P_S(Z           : np.ndarray,
                                      X_o         : np.ndarray,
                                      X_v         : np.ndarray,
                                      tau_o       : np.ndarray,
                                      tau_v       : np.ndarray,
                                      buffer      : np.ndarray,
                                      P_bunchsize = 8,
                                      S_bunchsize = 8,
                                      V_bunchsize = 1,
                                      W_bunchsize = 1,
                                      use_mpi = False):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_o             
    _INPUT_9         = X_o             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # fetch function pointers
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    fn_slice_3_1_2 = getattr(libpbc, "fn_slice_3_1_2", None)
    assert fn_slice_3_1_2 is not None
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    fn_slice_2_1 = getattr(libpbc, "fn_slice_2_1", None)
    assert fn_slice_2_1 is not None
    fn_slice_2_0 = getattr(libpbc, "fn_slice_2_0", None)
    assert fn_slice_2_0 is not None
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    fn_slice_3_0_1 = getattr(libpbc, "fn_slice_3_0_1", None)
    assert fn_slice_3_0_1 is not None
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    fn_contraction_01234_012_0134_plus_wob = getattr(libpbc, "fn_contraction_01234_012_0134_plus_wob", None)
    assert fn_contraction_01234_012_0134_plus_wob is not None
    fn_contraction_01_023_1230_wob = getattr(libpbc, "fn_contraction_01_023_1230_wob", None)
    assert fn_contraction_01_023_1230_wob is not None
    fn_permutation_012_021_wob = getattr(libpbc, "fn_permutation_012_021_wob", None)
    assert fn_permutation_012_021_wob is not None
    fn_contraction_012_2340_13402_wob = getattr(libpbc, "fn_contraction_012_2340_13402_wob", None)
    assert fn_contraction_012_2340_13402_wob is not None
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    fn_contraction_01234_01324_01234_wob = getattr(libpbc, "fn_contraction_01234_01324_01234_wob", None)
    assert fn_contraction_01234_01324_01234_wob is not None
    if use_mpi:
        bunchsize = NTHC_INT//comm_size + 1
        P_begin = rank*bunchsize
        P_end = (rank+1)*bunchsize
        P_begin          = min(P_begin, NTHC_INT)
        P_end            = min(P_end, NTHC_INT)
    else:
        P_begin          = 0               
        P_end            = NTHC_INT        
    # preallocate buffer
    bucket_size      = RMP3_XX_6_forloop_P_S_determine_bucket_size_forloop(NVIR = NVIR,
                                                                           NOCC = NOCC,
                                                                           N_LAPLACE = N_LAPLACE,
                                                                           NTHC_INT = NTHC_INT,
                                                                           V_bunchsize = V_bunchsize,
                                                                           W_bunchsize = W_bunchsize,
                                                                           P_bunchsize = P_bunchsize,
                                                                           S_bunchsize = S_bunchsize)
    bufsize_now      = buffer.size     
    _itemsize        = buffer.itemsize 
    offset_now       = 0               
    offset_0         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[0])
    offset_1         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[1])
    offset_2         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[2])
    offset_3         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[3])
    offset_4         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[4])
    offset_5         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[5])
    offset_6         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[6])
    offset_7         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[7])
    offset_8         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[8])
    offset_9         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[9])
    offset_10        = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[10])
    bufsize          = offset_now      
    if (bufsize > bufsize_now):
        buffer           = np.ndarray((bufsize), dtype=np.float64)
    # step   0 start for loop with indices ()
    # step   1 allocate   _M21
    _M21             = 0.0             
    # step   2 bP,bV->PVb
    offset_now       = offset_0        
    _M1_offset       = offset_now      
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M1_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    # step   3 lS,lW->SWl
    offset_now       = offset_1        
    _M3_offset       = offset_now      
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M3_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_9.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_9.shape[0]),
                                 ctypes.c_int(_INPUT_9.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    # step   4 lU,SWl->USW
    offset_now       = offset_2        
    _M18_offset      = offset_now      
    _M18             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M18_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_13_reshaped.T, _M3_reshaped.T, c=_M18_reshaped)
    _M18             = _M18_reshaped.reshape(*shape_backup)
    # step   5 USW->UWS
    _M18_perm_offset = offset_1        
    _M18_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT), buffer = buffer, offset = _M18_perm_offset)
    fn_permutation_012_021_wob(ctypes.c_void_p(_M18.ctypes.data),
                               ctypes.c_void_p(_M18_perm.ctypes.data),
                               ctypes.c_int(NTHC_INT),
                               ctypes.c_int(NTHC_INT),
                               ctypes.c_int(N_LAPLACE))
    # step   6 iP,iV->PVi
    offset_now       = offset_2        
    _M0_offset       = offset_now      
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M0_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    # step   7 iR,PVi->RPV
    offset_now       = offset_3        
    _M10_offset      = offset_now      
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M10_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_6.shape[0]
    _INPUT_6_reshaped = _INPUT_6.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M0.shape[0]
    _size_dim_1      = _size_dim_1 * _M0.shape[1]
    _M0_reshaped = _M0.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_6_reshaped.T, _M0_reshaped.T, c=_M10_reshaped)
    _M10             = _M10_reshaped.reshape(*shape_backup)
    # step   8 jS,jV->SVj
    offset_now       = offset_2        
    _M2_offset       = offset_now      
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M2_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_8.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_8.shape[0]),
                                 ctypes.c_int(_INPUT_8.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    # step   9 jQ,SVj->QSV
    offset_now       = offset_4        
    _M6_offset       = offset_now      
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M6_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6              = _M6_reshaped.reshape(*shape_backup)
    # step  10 start for loop with indices ('V',)
    for V_0, V_1 in lib.prange(0,N_LAPLACE,V_bunchsize):
        # step  11 start for loop with indices ('V', 'W')
        for W_0, W_1 in lib.prange(0,N_LAPLACE,W_bunchsize):
            # step  12 slice _INPUT_17 with indices ['V']
            _INPUT_17_sliced_offset = offset_2        
            _INPUT_17_sliced = np.ndarray((NVIR, (V_1-V_0)), buffer = buffer, offset = _INPUT_17_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_17.ctypes.data),
                         ctypes.c_void_p(_INPUT_17_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_17.shape[0]),
                         ctypes.c_int(_INPUT_17.shape[1]),
                         ctypes.c_int(V_0),
                         ctypes.c_int(V_1))
            # step  13 slice _INPUT_21 with indices ['W']
            _INPUT_21_sliced_offset = offset_5        
            _INPUT_21_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_21_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_21.ctypes.data),
                         ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_21.shape[0]),
                         ctypes.c_int(_INPUT_21.shape[1]),
                         ctypes.c_int(W_0),
                         ctypes.c_int(W_1))
            # step  14 aV,aW->VWa
            offset_now       = offset_6        
            _M4_offset       = offset_now      
            _M4              = np.ndarray(((V_1-V_0), (W_1-W_0), NVIR), buffer = buffer, offset = _M4_offset)
            fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_17_sliced.ctypes.data),
                                         ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                                         ctypes.c_void_p(_M4.ctypes.data),
                                         ctypes.c_int(_INPUT_17_sliced.shape[0]),
                                         ctypes.c_int(_INPUT_17_sliced.shape[1]),
                                         ctypes.c_int(_INPUT_21_sliced.shape[1]))
            # step  15 start for loop with indices ('V', 'W', 'P')
            for P_0, P_1 in lib.prange(P_begin,P_end,P_bunchsize):
                # step  16 slice _INPUT_22 with indices ['W']
                _INPUT_22_sliced_offset = offset_2        
                _INPUT_22_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_22_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_22.ctypes.data),
                             ctypes.c_void_p(_INPUT_22_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_22.shape[0]),
                             ctypes.c_int(_INPUT_22.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  17 slice _M1 with indices ['P', 'V']
                _M1_sliced_offset = offset_5        
                _M1_sliced       = np.ndarray(((P_1-P_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M1_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M1.ctypes.data),
                               ctypes.c_void_p(_M1_sliced.ctypes.data),
                               ctypes.c_int(_M1.shape[0]),
                               ctypes.c_int(_M1.shape[1]),
                               ctypes.c_int(_M1.shape[2]),
                               ctypes.c_int(P_0),
                               ctypes.c_int(P_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  18 bW,PVb->WPVb
                offset_now       = offset_7        
                _M5_offset       = offset_now      
                _M5              = np.ndarray(((W_1-W_0), (P_1-P_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M5_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_22_sliced.ctypes.data),
                                               ctypes.c_void_p(_M1_sliced.ctypes.data),
                                               ctypes.c_void_p(_M5.ctypes.data),
                                               ctypes.c_int(_INPUT_22_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_22_sliced.shape[1]),
                                               ctypes.c_int(_M1_sliced.shape[0]),
                                               ctypes.c_int(_M1_sliced.shape[1]))
                # step  19 bU,WPVb->UWPV
                offset_now       = offset_2        
                _M20_offset      = offset_now      
                _M20             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M20_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
                _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M5.shape[0]
                _size_dim_1      = _size_dim_1 * _M5.shape[1]
                _size_dim_1      = _size_dim_1 * _M5.shape[2]
                _M5_reshaped = _M5.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M20.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M20.shape[0]
                _M20_reshaped = _M20.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_14_reshaped.T, _M5_reshaped.T, c=_M20_reshaped)
                _M20             = _M20_reshaped.reshape(*shape_backup)
                # step  20 allocate   _M19
                offset_now       = offset_5        
                _M19             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = offset_now)
                _M19_offset      = offset_now      
                _M19.ravel()[:] = 0.0
                # step  21 start for loop with indices ('V', 'W', 'P', 'S')
                for S_0, S_1 in lib.prange(0,NTHC_INT,S_bunchsize):
                    # step  22 slice _INPUT_5 with indices ['S']
                    _INPUT_5_sliced_offset = offset_7        
                    _INPUT_5_sliced  = np.ndarray((NTHC_INT, (S_1-S_0)), buffer = buffer, offset = _INPUT_5_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                 ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_5.shape[0]),
                                 ctypes.c_int(_INPUT_5.shape[1]),
                                 ctypes.c_int(S_0),
                                 ctypes.c_int(S_1))
                    # step  23 slice _M10 with indices ['P', 'V']
                    _M10_sliced_offset = offset_8        
                    _M10_sliced      = np.ndarray((NTHC_INT, (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M10_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M10.ctypes.data),
                                   ctypes.c_void_p(_M10_sliced.ctypes.data),
                                   ctypes.c_int(_M10.shape[0]),
                                   ctypes.c_int(_M10.shape[1]),
                                   ctypes.c_int(_M10.shape[2]),
                                   ctypes.c_int(P_0),
                                   ctypes.c_int(P_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  24 RS,RPV->SPVR
                    offset_now       = offset_9        
                    _M11_offset      = offset_now      
                    _M11             = np.ndarray(((S_1-S_0), (P_1-P_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M11_offset)
                    fn_contraction_01_023_1230_wob(ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M10_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M11.ctypes.data),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[1]),
                                                   ctypes.c_int(_M10_sliced.shape[1]),
                                                   ctypes.c_int(_M10_sliced.shape[2]))
                    # step  25 kR,SPVR->kSPV
                    offset_now       = offset_7        
                    _M12_offset      = offset_now      
                    _M12             = np.ndarray((NOCC, (S_1-S_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M12_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_7.shape[0]
                    _INPUT_7_reshaped = _INPUT_7.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M11.shape[0]
                    _size_dim_1      = _size_dim_1 * _M11.shape[1]
                    _size_dim_1      = _size_dim_1 * _M11.shape[2]
                    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M12.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M12.shape[0]
                    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_7_reshaped, _M11_reshaped.T, c=_M12_reshaped)
                    _M12             = _M12_reshaped.reshape(*shape_backup)
                    # step  26 slice _INPUT_19 with indices ['W']
                    _INPUT_19_sliced_offset = offset_8        
                    _INPUT_19_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_19_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_19.ctypes.data),
                                 ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_19.shape[0]),
                                 ctypes.c_int(_INPUT_19.shape[1]),
                                 ctypes.c_int(W_0),
                                 ctypes.c_int(W_1))
                    # step  27 kW,kSPV->WSPVk
                    offset_now       = offset_9        
                    _M13_offset      = offset_now      
                    _M13             = np.ndarray(((W_1-W_0), (S_1-S_0), (P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M13_offset)
                    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                                                     ctypes.c_void_p(_M12.ctypes.data),
                                                     ctypes.c_void_p(_M13.ctypes.data),
                                                     ctypes.c_int(_INPUT_19_sliced.shape[0]),
                                                     ctypes.c_int(_INPUT_19_sliced.shape[1]),
                                                     ctypes.c_int(_M12.shape[1]),
                                                     ctypes.c_int(_M12.shape[2]),
                                                     ctypes.c_int(_M12.shape[3]))
                    # step  28 kT,WSPVk->TWSPV
                    offset_now       = offset_7        
                    _M14_offset      = offset_now      
                    _M14             = np.ndarray((NTHC_INT, (W_1-W_0), (S_1-S_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M14_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
                    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M13.shape[0]
                    _size_dim_1      = _size_dim_1 * _M13.shape[1]
                    _size_dim_1      = _size_dim_1 * _M13.shape[2]
                    _size_dim_1      = _size_dim_1 * _M13.shape[3]
                    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M14.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M14.shape[0]
                    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_11_reshaped.T, _M13_reshaped.T, c=_M14_reshaped)
                    _M14             = _M14_reshaped.reshape(*shape_backup)
                    # step  29 slice _INPUT_0 with indices ['P']
                    _INPUT_0_sliced_offset = offset_8        
                    _INPUT_0_sliced  = np.ndarray(((P_1-P_0), NTHC_INT), buffer = buffer, offset = _INPUT_0_sliced_offset)
                    fn_slice_2_0(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                 ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_0.shape[0]),
                                 ctypes.c_int(_INPUT_0.shape[1]),
                                 ctypes.c_int(P_0),
                                 ctypes.c_int(P_1))
                    # step  30 slice _M6 with indices ['S', 'V']
                    _M6_sliced_offset = offset_9        
                    _M6_sliced       = np.ndarray((NTHC_INT, (S_1-S_0), (V_1-V_0)), buffer = buffer, offset = _M6_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                   ctypes.c_int(_M6.shape[0]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]),
                                   ctypes.c_int(S_0),
                                   ctypes.c_int(S_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  31 PQ,QSV->PSVQ
                    offset_now       = offset_10       
                    _M7_offset       = offset_now      
                    _M7              = np.ndarray(((P_1-P_0), (S_1-S_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M7_offset)
                    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M7.ctypes.data),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[2]))
                    # step  32 aQ,PSVQ->aPSV
                    offset_now       = offset_8        
                    _M8_offset       = offset_now      
                    _M8              = np.ndarray((NVIR, (P_1-P_0), (S_1-S_0), (V_1-V_0)), buffer = buffer, offset = _M8_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
                    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M7.shape[0]
                    _size_dim_1      = _size_dim_1 * _M7.shape[1]
                    _size_dim_1      = _size_dim_1 * _M7.shape[2]
                    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M8.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M8.shape[0]
                    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_4_reshaped, _M7_reshaped.T, c=_M8_reshaped)
                    _M8              = _M8_reshaped.reshape(*shape_backup)
                    # step  33 VWa,aPSV->WPSVa
                    offset_now       = offset_9        
                    _M9_offset       = offset_now      
                    _M9              = np.ndarray(((W_1-W_0), (P_1-P_0), (S_1-S_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M9_offset)
                    fn_contraction_012_2340_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                                      ctypes.c_void_p(_M8.ctypes.data),
                                                      ctypes.c_void_p(_M9.ctypes.data),
                                                      ctypes.c_int(_M4.shape[0]),
                                                      ctypes.c_int(_M4.shape[1]),
                                                      ctypes.c_int(_M4.shape[2]),
                                                      ctypes.c_int(_M8.shape[1]),
                                                      ctypes.c_int(_M8.shape[2]))
                    # step  34 aT,WPSVa->TWPSV
                    offset_now       = offset_8        
                    _M15_offset      = offset_now      
                    _M15             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (S_1-S_0), (V_1-V_0)), buffer = buffer, offset = _M15_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
                    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M9.shape[0]
                    _size_dim_1      = _size_dim_1 * _M9.shape[1]
                    _size_dim_1      = _size_dim_1 * _M9.shape[2]
                    _size_dim_1      = _size_dim_1 * _M9.shape[3]
                    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M15.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M15.shape[0]
                    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_12_reshaped.T, _M9_reshaped.T, c=_M15_reshaped)
                    _M15             = _M15_reshaped.reshape(*shape_backup)
                    # step  35 TWSPV,TWPSV->TWSPV
                    offset_now       = offset_9        
                    _M16_offset      = offset_now      
                    _M16             = np.ndarray((NTHC_INT, (W_1-W_0), (S_1-S_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M16_offset)
                    fn_contraction_01234_01324_01234_wob(ctypes.c_void_p(_M14.ctypes.data),
                                                         ctypes.c_void_p(_M15.ctypes.data),
                                                         ctypes.c_void_p(_M16.ctypes.data),
                                                         ctypes.c_int(_M14.shape[0]),
                                                         ctypes.c_int(_M14.shape[1]),
                                                         ctypes.c_int(_M14.shape[2]),
                                                         ctypes.c_int(_M14.shape[3]),
                                                         ctypes.c_int(_M14.shape[4]))
                    # step  36 TU,TWSPV->UWSPV
                    offset_now       = offset_7        
                    _M17_offset      = offset_now      
                    _M17             = np.ndarray((NTHC_INT, (W_1-W_0), (S_1-S_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M17_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
                    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M16.shape[0]
                    _M16_reshaped = _M16.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M17.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M17.shape[0]
                    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_10_reshaped.T, _M16_reshaped, c=_M17_reshaped)
                    _M17             = _M17_reshaped.reshape(*shape_backup)
                    # step  37 slice _M18 with indices ['S', 'W']
                    _M18_perm_sliced_offset = offset_8        
                    _M18_perm_sliced = np.ndarray((NTHC_INT, (W_1-W_0), (S_1-S_0)), buffer = buffer, offset = _M18_perm_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M18_perm.ctypes.data),
                                   ctypes.c_void_p(_M18_perm_sliced.ctypes.data),
                                   ctypes.c_int(_M18_perm.shape[0]),
                                   ctypes.c_int(_M18_perm.shape[1]),
                                   ctypes.c_int(_M18_perm.shape[2]),
                                   ctypes.c_int(W_0),
                                   ctypes.c_int(W_1),
                                   ctypes.c_int(S_0),
                                   ctypes.c_int(S_1))
                    # step  38 UWSPV,UWS->UWPV
                    offset_now       = offset_5        
                    fn_contraction_01234_012_0134_plus_wob(ctypes.c_void_p(_M17.ctypes.data),
                                                           ctypes.c_void_p(_M18_perm_sliced.ctypes.data),
                                                           ctypes.c_void_p(_M19.ctypes.data),
                                                           ctypes.c_int(_M17.shape[0]),
                                                           ctypes.c_int(_M17.shape[1]),
                                                           ctypes.c_int(_M17.shape[2]),
                                                           ctypes.c_int(_M17.shape[3]),
                                                           ctypes.c_int(_M17.shape[4]))
                # step  39 end   for loop with indices ('V', 'W', 'P', 'S')
                # step  40 UWPV,UWPV->
                output_tmp       = ctypes.c_double(0.0)
                fn_dot(ctypes.c_void_p(_M19.ctypes.data),
                       ctypes.c_void_p(_M20.ctypes.data),
                       ctypes.c_int(_M19.size),
                       ctypes.pointer(output_tmp))
                output_tmp = output_tmp.value
                _M21 += output_tmp
            # step  41 end   for loop with indices ('V', 'W', 'P')
        # step  42 end   for loop with indices ('V', 'W')
    # step  43 end   for loop with indices ('V',)
    # clean the final forloop
    # MPI finalize
    if use_mpi:
        _M21 = reduce(_M21, root=0)
        _M21 = bcast(_M21, root=0)
    return _M21

def RMP3_XX_7_forloop_P_R_determine_bucket_size_forloop(NVIR        : int,
                                                        NOCC        : int,
                                                        N_LAPLACE   : int,
                                                        NTHC_INT    : int,
                                                        P_bunchsize = 8,
                                                        R_bunchsize = 8,
                                                        V_bunchsize = 1,
                                                        W_bunchsize = 1):
    # init
    output = []     
    bucked_0_size    = 0               
    bucked_1_size    = 0               
    bucked_2_size    = 0               
    bucked_3_size    = 0               
    bucked_4_size    = 0               
    bucked_5_size    = 0               
    bucked_6_size    = 0               
    bucked_7_size    = 0               
    bucked_8_size    = 0               
    bucked_9_size    = 0               
    # assign the size of each tensor
    _M0_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M3_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M2_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M1_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _INPUT_18_sliced_size = (NVIR * N_LAPLACE)
    _INPUT_19_sliced_size = (NOCC * N_LAPLACE)
    _M18_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize)))
    _M14_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M6_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M10_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _INPUT_21_sliced_size = (NVIR * N_LAPLACE)
    _M0_sliced_size  = (P_bunchsize * (V_bunchsize * NOCC))
    _INPUT_0_sliced_size = (NTHC_INT * NTHC_INT)
    _M8_size         = (NVIR * (P_bunchsize * (R_bunchsize * V_bunchsize)))
    _M15_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * (R_bunchsize * V_bunchsize))))
    _M16_perm_size   = (P_bunchsize * (V_bunchsize * (NTHC_INT * (R_bunchsize * W_bunchsize))))
    _M19_size        = (R_bunchsize * (NTHC_INT * (P_bunchsize * (V_bunchsize * W_bunchsize))))
    _M4_size         = (V_bunchsize * (W_bunchsize * NVIR))
    _M5_size         = (W_bunchsize * (P_bunchsize * (V_bunchsize * NOCC)))
    _M6_sliced_size  = (NTHC_INT * (R_bunchsize * V_bunchsize))
    _M9_size         = (W_bunchsize * (P_bunchsize * (R_bunchsize * (V_bunchsize * NVIR))))
    _M14_sliced_size = (NTHC_INT * (R_bunchsize * W_bunchsize))
    _M17_size        = (NTHC_INT * (P_bunchsize * (V_bunchsize * (R_bunchsize * W_bunchsize))))
    _INPUT_5_sliced_size = (NTHC_INT * NTHC_INT)
    _M12_size        = (NVIR * (R_bunchsize * (P_bunchsize * V_bunchsize)))
    _M20_size        = (NTHC_INT * (W_bunchsize * (R_bunchsize * (P_bunchsize * V_bunchsize))))
    _M7_size         = (P_bunchsize * (R_bunchsize * (V_bunchsize * NTHC_INT)))
    _M16_size        = (P_bunchsize * (V_bunchsize * (NTHC_INT * (R_bunchsize * W_bunchsize))))
    _M10_sliced_size = (NTHC_INT * (P_bunchsize * V_bunchsize))
    _INPUT_22_sliced_size = (NVIR * N_LAPLACE)
    _M20_perm_size   = (NTHC_INT * (W_bunchsize * (R_bunchsize * (P_bunchsize * V_bunchsize))))
    _M11_size        = (R_bunchsize * (P_bunchsize * (V_bunchsize * NTHC_INT)))
    _M13_size        = (W_bunchsize * (R_bunchsize * (P_bunchsize * (V_bunchsize * NVIR))))
    # determine the size of each bucket
    # bucket 0
    bucked_0_size    = max(bucked_0_size, _M0_size)
    # bucket 1
    bucked_1_size    = max(bucked_1_size, _M3_size)
    bucked_1_size    = max(bucked_1_size, _M2_size)
    bucked_1_size    = max(bucked_1_size, _M1_size)
    bucked_1_size    = max(bucked_1_size, _INPUT_18_sliced_size)
    bucked_1_size    = max(bucked_1_size, _INPUT_19_sliced_size)
    bucked_1_size    = max(bucked_1_size, _M18_size)
    # bucket 2
    bucked_2_size    = max(bucked_2_size, _M14_size)
    # bucket 3
    bucked_3_size    = max(bucked_3_size, _M6_size)
    # bucket 4
    bucked_4_size    = max(bucked_4_size, _M10_size)
    # bucket 5
    bucked_5_size    = max(bucked_5_size, _INPUT_21_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M0_sliced_size)
    bucked_5_size    = max(bucked_5_size, _INPUT_0_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M8_size)
    bucked_5_size    = max(bucked_5_size, _M15_size)
    bucked_5_size    = max(bucked_5_size, _M16_perm_size)
    bucked_5_size    = max(bucked_5_size, _M19_size)
    # bucket 6
    bucked_6_size    = max(bucked_6_size, _M4_size)
    # bucket 7
    bucked_7_size    = max(bucked_7_size, _M5_size)
    bucked_7_size    = max(bucked_7_size, _M6_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M9_size)
    bucked_7_size    = max(bucked_7_size, _M14_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M17_size)
    bucked_7_size    = max(bucked_7_size, _INPUT_5_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M12_size)
    bucked_7_size    = max(bucked_7_size, _M20_size)
    # bucket 8
    bucked_8_size    = max(bucked_8_size, _M7_size)
    bucked_8_size    = max(bucked_8_size, _M16_size)
    bucked_8_size    = max(bucked_8_size, _M10_sliced_size)
    bucked_8_size    = max(bucked_8_size, _INPUT_22_sliced_size)
    bucked_8_size    = max(bucked_8_size, _M20_perm_size)
    # bucket 9
    bucked_9_size    = max(bucked_9_size, _M11_size)
    bucked_9_size    = max(bucked_9_size, _M13_size)
    # append each bucket size to the output
    output.append(bucked_0_size)
    output.append(bucked_1_size)
    output.append(bucked_2_size)
    output.append(bucked_3_size)
    output.append(bucked_4_size)
    output.append(bucked_5_size)
    output.append(bucked_6_size)
    output.append(bucked_7_size)
    output.append(bucked_8_size)
    output.append(bucked_9_size)
    return output

def RMP3_XX_7_forloop_P_R_naive(Z           : np.ndarray,
                                X_o         : np.ndarray,
                                X_v         : np.ndarray,
                                tau_o       : np.ndarray,
                                tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    t1 = (logger.process_clock(), logger.perf_counter())
    _M0              = np.einsum("iP,iV->PVi"    , _INPUT_1        , _INPUT_15       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M3              = np.einsum("kR,kW->RWk"    , _INPUT_7        , _INPUT_20       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.einsum("kT,RWk->TRW"   , _INPUT_11       , _M3             )
    del _M3         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M2              = np.einsum("jR,jV->RVj"    , _INPUT_6        , _INPUT_16       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.einsum("jQ,RVj->QRV"   , _INPUT_3        , _M2             )
    del _M2         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M1              = np.einsum("aP,aV->PVa"    , _INPUT_2        , _INPUT_17       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.einsum("aS,PVa->SPV"   , _INPUT_8        , _M1             )
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M4              = np.einsum("bV,bW->VWb"    , _INPUT_18       , _INPUT_21       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M5              = np.einsum("iW,PVi->WPVi"  , _INPUT_19       , _M0             )
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.einsum("iU,WPVi->UWPV" , _INPUT_13       , _M5             )
    del _M5         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.einsum("PQ,QRV->PRVQ"  , _INPUT_0        , _M6             )
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.einsum("bQ,PRVQ->bPRV" , _INPUT_4        , _M7             )
    del _M7         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9              = np.einsum("VWb,bPRV->WPRVb", _M4             , _M8             )
    del _M4         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.einsum("bT,WPRVb->TWPRV", _INPUT_12       , _M9             )
    del _M9         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.einsum("TRW,TWPRV->PVTRW", _M14            , _M15            )
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16_perm        = np.transpose(_M16            , (0, 1, 3, 4, 2) )
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.einsum("TU,PVRWT->UPVRW", _INPUT_10       , _M16_perm       )
    del _M16_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M19             = np.einsum("UPVRW,UWPV->RUPVW", _M17            , _M18            )
    del _M17        
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11             = np.einsum("RS,SPV->RPVS"  , _INPUT_5        , _M10            )
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.einsum("cS,RPVS->cRPV" , _INPUT_9        , _M11            )
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M13             = np.einsum("cW,cRPV->WRPVc", _INPUT_22       , _M12            )
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.einsum("cU,WRPVc->UWRPV", _INPUT_14       , _M13            )
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20_perm        = np.transpose(_M20            , (2, 0, 3, 4, 1) )
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M21             = np.einsum("RUPVW,RUPVW->" , _M19            , _M20_perm       )
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    return _M21

def RMP3_XX_7_forloop_P_R(Z           : np.ndarray,
                          X_o         : np.ndarray,
                          X_v         : np.ndarray,
                          tau_o       : np.ndarray,
                          tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # step 0 iP,iV->PVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    # step 1 kR,kW->RWk 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_7.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_7.shape[0]),
                                 ctypes.c_int(_INPUT_7.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    # step 2 kT,RWk->TRW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_11_reshaped.T, _M3_reshaped.T, c=_M14_reshaped)
    _M14         = _M14_reshaped.reshape(*shape_backup)
    del _M3         
    del _M3_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    # step 3 jR,jV->RVj 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_6.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_6.shape[0]),
                                 ctypes.c_int(_INPUT_6.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    # step 4 jQ,RVj->QRV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6          = _M6_reshaped.reshape(*shape_backup)
    del _M2         
    del _M2_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    # step 5 aP,aV->PVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    # step 6 aS,PVa->SPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_8.shape[0]
    _INPUT_8_reshaped = _INPUT_8.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_8_reshaped.T, _M1_reshaped.T, c=_M10_reshaped)
    _M10         = _M10_reshaped.reshape(*shape_backup)
    del _M1         
    del _M1_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    # step 7 bV,bW->VWb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M4              = np.ndarray((N_LAPLACE, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_INPUT_21.ctypes.data),
                                 ctypes.c_void_p(_M4.ctypes.data),
                                 ctypes.c_int(_INPUT_18.shape[0]),
                                 ctypes.c_int(_INPUT_18.shape[1]),
                                 ctypes.c_int(_INPUT_21.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    # step 8 iW,PVi->WPVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M5              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19.ctypes.data),
                                   ctypes.c_void_p(_M0.ctypes.data),
                                   ctypes.c_void_p(_M5.ctypes.data),
                                   ctypes.c_int(_INPUT_19.shape[0]),
                                   ctypes.c_int(_INPUT_19.shape[1]),
                                   ctypes.c_int(_M0.shape[0]),
                                   ctypes.c_int(_M0.shape[1]))
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    # step 9 iU,WPVi->UWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M5.shape[0]
    _size_dim_1      = _size_dim_1 * _M5.shape[1]
    _size_dim_1      = _size_dim_1 * _M5.shape[2]
    _M5_reshaped = _M5.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_13_reshaped.T, _M5_reshaped.T, c=_M18_reshaped)
    _M18         = _M18_reshaped.reshape(*shape_backup)
    del _M5         
    del _M5_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    # step 10 PQ,QRV->PRVQ 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                   ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M7.ctypes.data),
                                   ctypes.c_int(_INPUT_0.shape[0]),
                                   ctypes.c_int(_INPUT_0.shape[1]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]))
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    # step 11 bQ,PRVQ->bPRV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.ndarray((NVIR, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _size_dim_1      = _size_dim_1 * _M7.shape[1]
    _size_dim_1      = _size_dim_1 * _M7.shape[2]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M8.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M8.shape[0]
    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_4_reshaped, _M7_reshaped.T, c=_M8_reshaped)
    _M8          = _M8_reshaped.reshape(*shape_backup)
    del _M7         
    del _M7_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    # step 12 VWb,bPRV->WPRVb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_2340_13402_wob = getattr(libpbc, "fn_contraction_012_2340_13402_wob", None)
    assert fn_contraction_012_2340_13402_wob is not None
    _M9              = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_012_2340_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                      ctypes.c_void_p(_M8.ctypes.data),
                                      ctypes.c_void_p(_M9.ctypes.data),
                                      ctypes.c_int(_M4.shape[0]),
                                      ctypes.c_int(_M4.shape[1]),
                                      ctypes.c_int(_M4.shape[2]),
                                      ctypes.c_int(_M8.shape[1]),
                                      ctypes.c_int(_M8.shape[2]))
    del _M4         
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    # step 13 bT,WPRVb->TWPRV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M9.shape[0]
    _size_dim_1      = _size_dim_1 * _M9.shape[1]
    _size_dim_1      = _size_dim_1 * _M9.shape[2]
    _size_dim_1      = _size_dim_1 * _M9.shape[3]
    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M15.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M15.shape[0]
    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_12_reshaped.T, _M9_reshaped.T, c=_M15_reshaped)
    _M15         = _M15_reshaped.reshape(*shape_backup)
    del _M9         
    del _M9_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    # step 14 TRW,TWPRV->PVTRW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_02314_34012_wob = getattr(libpbc, "fn_contraction_012_02314_34012_wob", None)
    assert fn_contraction_012_02314_34012_wob is not None
    _M16             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_012_02314_34012_wob(ctypes.c_void_p(_M14.ctypes.data),
                                       ctypes.c_void_p(_M15.ctypes.data),
                                       ctypes.c_void_p(_M16.ctypes.data),
                                       ctypes.c_int(_M14.shape[0]),
                                       ctypes.c_int(_M14.shape[1]),
                                       ctypes.c_int(_M14.shape[2]),
                                       ctypes.c_int(_M15.shape[2]),
                                       ctypes.c_int(_M15.shape[4]))
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    # step 15 PVTRW->PVRWT 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_01342_wob = getattr(libpbc, "fn_permutation_01234_01342_wob", None)
    assert fn_permutation_01234_01342_wob is not None
    _M16_perm        = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_01342_wob(ctypes.c_void_p(_M16.ctypes.data),
                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                   ctypes.c_int(_M16.shape[0]),
                                   ctypes.c_int(_M16.shape[1]),
                                   ctypes.c_int(_M16.shape[2]),
                                   ctypes.c_int(_M16.shape[3]),
                                   ctypes.c_int(_M16.shape[4]))
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    # step 16 TU,PVRWT->UPVRW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M17.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M17.shape[0]
    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
    _M17         = _M17_reshaped.reshape(*shape_backup)
    del _M16_perm   
    del _M16_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    # step 17 UPVRW,UWPV->RUPVW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01234_0412_30124_wob = getattr(libpbc, "fn_contraction_01234_0412_30124_wob", None)
    assert fn_contraction_01234_0412_30124_wob is not None
    _M19             = np.ndarray((NTHC_INT, NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE), dtype=np.float64)
    fn_contraction_01234_0412_30124_wob(ctypes.c_void_p(_M17.ctypes.data),
                                        ctypes.c_void_p(_M18.ctypes.data),
                                        ctypes.c_void_p(_M19.ctypes.data),
                                        ctypes.c_int(_M17.shape[0]),
                                        ctypes.c_int(_M17.shape[1]),
                                        ctypes.c_int(_M17.shape[2]),
                                        ctypes.c_int(_M17.shape[3]),
                                        ctypes.c_int(_M17.shape[4]))
    del _M17        
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    # step 18 RS,SPV->RPVS 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    _M11             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                   ctypes.c_void_p(_M10.ctypes.data),
                                   ctypes.c_void_p(_M11.ctypes.data),
                                   ctypes.c_int(_INPUT_5.shape[0]),
                                   ctypes.c_int(_INPUT_5.shape[1]),
                                   ctypes.c_int(_M10.shape[1]),
                                   ctypes.c_int(_M10.shape[2]))
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    # step 19 cS,RPVS->cRPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.ndarray((NVIR, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_9.shape[0]
    _INPUT_9_reshaped = _INPUT_9.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M11.shape[0]
    _size_dim_1      = _size_dim_1 * _M11.shape[1]
    _size_dim_1      = _size_dim_1 * _M11.shape[2]
    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M12.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M12.shape[0]
    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_9_reshaped, _M11_reshaped.T, c=_M12_reshaped)
    _M12         = _M12_reshaped.reshape(*shape_backup)
    del _M11        
    del _M11_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    # step 20 cW,cRPV->WRPVc 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    _M13             = np.ndarray((N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_22.ctypes.data),
                                     ctypes.c_void_p(_M12.ctypes.data),
                                     ctypes.c_void_p(_M13.ctypes.data),
                                     ctypes.c_int(_INPUT_22.shape[0]),
                                     ctypes.c_int(_INPUT_22.shape[1]),
                                     ctypes.c_int(_M12.shape[1]),
                                     ctypes.c_int(_M12.shape[2]),
                                     ctypes.c_int(_M12.shape[3]))
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    # step 21 cU,WRPVc->UWRPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M13.shape[0]
    _size_dim_1      = _size_dim_1 * _M13.shape[1]
    _size_dim_1      = _size_dim_1 * _M13.shape[2]
    _size_dim_1      = _size_dim_1 * _M13.shape[3]
    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_14_reshaped.T, _M13_reshaped.T, c=_M20_reshaped)
    _M20         = _M20_reshaped.reshape(*shape_backup)
    del _M13        
    del _M13_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    # step 22 UWRPV->RUPVW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_20341_wob = getattr(libpbc, "fn_permutation_01234_20341_wob", None)
    assert fn_permutation_01234_20341_wob is not None
    _M20_perm        = np.ndarray((NTHC_INT, NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE), dtype=np.float64)
    fn_permutation_01234_20341_wob(ctypes.c_void_p(_M20.ctypes.data),
                                   ctypes.c_void_p(_M20_perm.ctypes.data),
                                   ctypes.c_int(_M20.shape[0]),
                                   ctypes.c_int(_M20.shape[1]),
                                   ctypes.c_int(_M20.shape[2]),
                                   ctypes.c_int(_M20.shape[3]),
                                   ctypes.c_int(_M20.shape[4]))
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    # step 23 RUPVW,RUPVW-> 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    _M21             = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20_perm.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(_M21))
    _M21 = _M21.value
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    return _M21

def RMP3_XX_7_forloop_P_R_forloop_P_R(Z           : np.ndarray,
                                      X_o         : np.ndarray,
                                      X_v         : np.ndarray,
                                      tau_o       : np.ndarray,
                                      tau_v       : np.ndarray,
                                      buffer      : np.ndarray,
                                      P_bunchsize = 8,
                                      R_bunchsize = 8,
                                      V_bunchsize = 1,
                                      W_bunchsize = 1,
                                      use_mpi = False):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # fetch function pointers
    fn_permutation_01234_01342_wob = getattr(libpbc, "fn_permutation_01234_01342_wob", None)
    assert fn_permutation_01234_01342_wob is not None
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    fn_slice_3_1_2 = getattr(libpbc, "fn_slice_3_1_2", None)
    assert fn_slice_3_1_2 is not None
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    fn_slice_2_1 = getattr(libpbc, "fn_slice_2_1", None)
    assert fn_slice_2_1 is not None
    fn_slice_2_0 = getattr(libpbc, "fn_slice_2_0", None)
    assert fn_slice_2_0 is not None
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    fn_slice_3_0_1 = getattr(libpbc, "fn_slice_3_0_1", None)
    assert fn_slice_3_0_1 is not None
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    fn_contraction_012_02314_34012_wob = getattr(libpbc, "fn_contraction_012_02314_34012_wob", None)
    assert fn_contraction_012_02314_34012_wob is not None
    fn_permutation_01234_20341_wob = getattr(libpbc, "fn_permutation_01234_20341_wob", None)
    assert fn_permutation_01234_20341_wob is not None
    fn_contraction_012_2340_13402_wob = getattr(libpbc, "fn_contraction_012_2340_13402_wob", None)
    assert fn_contraction_012_2340_13402_wob is not None
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    fn_contraction_01234_0412_30124_wob = getattr(libpbc, "fn_contraction_01234_0412_30124_wob", None)
    assert fn_contraction_01234_0412_30124_wob is not None
    if use_mpi:
        bunchsize = NTHC_INT//comm_size + 1
        P_begin = rank*bunchsize
        P_end = (rank+1)*bunchsize
        P_begin          = min(P_begin, NTHC_INT)
        P_end            = min(P_end, NTHC_INT)
    else:
        P_begin          = 0               
        P_end            = NTHC_INT        
    # preallocate buffer
    bucket_size      = RMP3_XX_7_forloop_P_R_determine_bucket_size_forloop(NVIR = NVIR,
                                                                           NOCC = NOCC,
                                                                           N_LAPLACE = N_LAPLACE,
                                                                           NTHC_INT = NTHC_INT,
                                                                           V_bunchsize = V_bunchsize,
                                                                           W_bunchsize = W_bunchsize,
                                                                           P_bunchsize = P_bunchsize,
                                                                           R_bunchsize = R_bunchsize)
    bufsize_now      = buffer.size     
    _itemsize        = buffer.itemsize 
    offset_now       = 0               
    offset_0         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[0])
    offset_1         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[1])
    offset_2         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[2])
    offset_3         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[3])
    offset_4         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[4])
    offset_5         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[5])
    offset_6         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[6])
    offset_7         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[7])
    offset_8         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[8])
    offset_9         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[9])
    bufsize          = offset_now      
    if (bufsize > bufsize_now):
        buffer           = np.ndarray((bufsize), dtype=np.float64)
    # step   0 start for loop with indices ()
    # step   1 allocate   _M21
    _M21             = 0.0             
    # step   2 iP,iV->PVi
    offset_now       = offset_0        
    _M0_offset       = offset_now      
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M0_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    # step   3 kR,kW->RWk
    offset_now       = offset_1        
    _M3_offset       = offset_now      
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M3_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_7.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_7.shape[0]),
                                 ctypes.c_int(_INPUT_7.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    # step   4 kT,RWk->TRW
    offset_now       = offset_2        
    _M14_offset      = offset_now      
    _M14             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M14_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_11_reshaped.T, _M3_reshaped.T, c=_M14_reshaped)
    _M14             = _M14_reshaped.reshape(*shape_backup)
    # step   5 jR,jV->RVj
    offset_now       = offset_1        
    _M2_offset       = offset_now      
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M2_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_6.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_6.shape[0]),
                                 ctypes.c_int(_INPUT_6.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    # step   6 jQ,RVj->QRV
    offset_now       = offset_3        
    _M6_offset       = offset_now      
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M6_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6              = _M6_reshaped.reshape(*shape_backup)
    # step   7 aP,aV->PVa
    offset_now       = offset_1        
    _M1_offset       = offset_now      
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M1_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_17.shape[1]))
    # step   8 aS,PVa->SPV
    offset_now       = offset_4        
    _M10_offset      = offset_now      
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M10_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_8.shape[0]
    _INPUT_8_reshaped = _INPUT_8.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M1.shape[0]
    _size_dim_1      = _size_dim_1 * _M1.shape[1]
    _M1_reshaped = _M1.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_8_reshaped.T, _M1_reshaped.T, c=_M10_reshaped)
    _M10             = _M10_reshaped.reshape(*shape_backup)
    # step   9 start for loop with indices ('V',)
    for V_0, V_1 in lib.prange(0,N_LAPLACE,V_bunchsize):
        # step  10 start for loop with indices ('V', 'W')
        for W_0, W_1 in lib.prange(0,N_LAPLACE,W_bunchsize):
            # step  11 slice _INPUT_18 with indices ['V']
            _INPUT_18_sliced_offset = offset_1        
            _INPUT_18_sliced = np.ndarray((NVIR, (V_1-V_0)), buffer = buffer, offset = _INPUT_18_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_18.ctypes.data),
                         ctypes.c_void_p(_INPUT_18_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_18.shape[0]),
                         ctypes.c_int(_INPUT_18.shape[1]),
                         ctypes.c_int(V_0),
                         ctypes.c_int(V_1))
            # step  12 slice _INPUT_21 with indices ['W']
            _INPUT_21_sliced_offset = offset_5        
            _INPUT_21_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_21_sliced_offset)
            fn_slice_2_1(ctypes.c_void_p(_INPUT_21.ctypes.data),
                         ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                         ctypes.c_int(_INPUT_21.shape[0]),
                         ctypes.c_int(_INPUT_21.shape[1]),
                         ctypes.c_int(W_0),
                         ctypes.c_int(W_1))
            # step  13 bV,bW->VWb
            offset_now       = offset_6        
            _M4_offset       = offset_now      
            _M4              = np.ndarray(((V_1-V_0), (W_1-W_0), NVIR), buffer = buffer, offset = _M4_offset)
            fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_18_sliced.ctypes.data),
                                         ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                                         ctypes.c_void_p(_M4.ctypes.data),
                                         ctypes.c_int(_INPUT_18_sliced.shape[0]),
                                         ctypes.c_int(_INPUT_18_sliced.shape[1]),
                                         ctypes.c_int(_INPUT_21_sliced.shape[1]))
            # step  14 start for loop with indices ('V', 'W', 'P')
            for P_0, P_1 in lib.prange(P_begin,P_end,P_bunchsize):
                # step  15 slice _INPUT_19 with indices ['W']
                _INPUT_19_sliced_offset = offset_1        
                _INPUT_19_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_19_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_19.ctypes.data),
                             ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_19.shape[0]),
                             ctypes.c_int(_INPUT_19.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  16 slice _M0 with indices ['P', 'V']
                _M0_sliced_offset = offset_5        
                _M0_sliced       = np.ndarray(((P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M0_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M0.ctypes.data),
                               ctypes.c_void_p(_M0_sliced.ctypes.data),
                               ctypes.c_int(_M0.shape[0]),
                               ctypes.c_int(_M0.shape[1]),
                               ctypes.c_int(_M0.shape[2]),
                               ctypes.c_int(P_0),
                               ctypes.c_int(P_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  17 iW,PVi->WPVi
                offset_now       = offset_7        
                _M5_offset       = offset_now      
                _M5              = np.ndarray(((W_1-W_0), (P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M5_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                                               ctypes.c_void_p(_M0_sliced.ctypes.data),
                                               ctypes.c_void_p(_M5.ctypes.data),
                                               ctypes.c_int(_INPUT_19_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_19_sliced.shape[1]),
                                               ctypes.c_int(_M0_sliced.shape[0]),
                                               ctypes.c_int(_M0_sliced.shape[1]))
                # step  18 iU,WPVi->UWPV
                offset_now       = offset_1        
                _M18_offset      = offset_now      
                _M18             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M18_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
                _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M5.shape[0]
                _size_dim_1      = _size_dim_1 * _M5.shape[1]
                _size_dim_1      = _size_dim_1 * _M5.shape[2]
                _M5_reshaped = _M5.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M18.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M18.shape[0]
                _M18_reshaped = _M18.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_13_reshaped.T, _M5_reshaped.T, c=_M18_reshaped)
                _M18             = _M18_reshaped.reshape(*shape_backup)
                # step  19 start for loop with indices ('V', 'W', 'P', 'R')
                for R_0, R_1 in lib.prange(0,NTHC_INT,R_bunchsize):
                    # step  20 slice _INPUT_0 with indices ['P']
                    _INPUT_0_sliced_offset = offset_5        
                    _INPUT_0_sliced  = np.ndarray(((P_1-P_0), NTHC_INT), buffer = buffer, offset = _INPUT_0_sliced_offset)
                    fn_slice_2_0(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                 ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_0.shape[0]),
                                 ctypes.c_int(_INPUT_0.shape[1]),
                                 ctypes.c_int(P_0),
                                 ctypes.c_int(P_1))
                    # step  21 slice _M6 with indices ['R', 'V']
                    _M6_sliced_offset = offset_7        
                    _M6_sliced       = np.ndarray((NTHC_INT, (R_1-R_0), (V_1-V_0)), buffer = buffer, offset = _M6_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                   ctypes.c_int(_M6.shape[0]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]),
                                   ctypes.c_int(R_0),
                                   ctypes.c_int(R_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  22 PQ,QRV->PRVQ
                    offset_now       = offset_8        
                    _M7_offset       = offset_now      
                    _M7              = np.ndarray(((P_1-P_0), (R_1-R_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M7_offset)
                    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M7.ctypes.data),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[2]))
                    # step  23 bQ,PRVQ->bPRV
                    offset_now       = offset_5        
                    _M8_offset       = offset_now      
                    _M8              = np.ndarray((NVIR, (P_1-P_0), (R_1-R_0), (V_1-V_0)), buffer = buffer, offset = _M8_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
                    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M7.shape[0]
                    _size_dim_1      = _size_dim_1 * _M7.shape[1]
                    _size_dim_1      = _size_dim_1 * _M7.shape[2]
                    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M8.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M8.shape[0]
                    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_4_reshaped, _M7_reshaped.T, c=_M8_reshaped)
                    _M8              = _M8_reshaped.reshape(*shape_backup)
                    # step  24 VWb,bPRV->WPRVb
                    offset_now       = offset_7        
                    _M9_offset       = offset_now      
                    _M9              = np.ndarray(((W_1-W_0), (P_1-P_0), (R_1-R_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M9_offset)
                    fn_contraction_012_2340_13402_wob(ctypes.c_void_p(_M4.ctypes.data),
                                                      ctypes.c_void_p(_M8.ctypes.data),
                                                      ctypes.c_void_p(_M9.ctypes.data),
                                                      ctypes.c_int(_M4.shape[0]),
                                                      ctypes.c_int(_M4.shape[1]),
                                                      ctypes.c_int(_M4.shape[2]),
                                                      ctypes.c_int(_M8.shape[1]),
                                                      ctypes.c_int(_M8.shape[2]))
                    # step  25 bT,WPRVb->TWPRV
                    offset_now       = offset_5        
                    _M15_offset      = offset_now      
                    _M15             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (R_1-R_0), (V_1-V_0)), buffer = buffer, offset = _M15_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
                    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M9.shape[0]
                    _size_dim_1      = _size_dim_1 * _M9.shape[1]
                    _size_dim_1      = _size_dim_1 * _M9.shape[2]
                    _size_dim_1      = _size_dim_1 * _M9.shape[3]
                    _M9_reshaped = _M9.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M15.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M15.shape[0]
                    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_12_reshaped.T, _M9_reshaped.T, c=_M15_reshaped)
                    _M15             = _M15_reshaped.reshape(*shape_backup)
                    # step  26 slice _M14 with indices ['R', 'W']
                    _M14_sliced_offset = offset_7        
                    _M14_sliced      = np.ndarray((NTHC_INT, (R_1-R_0), (W_1-W_0)), buffer = buffer, offset = _M14_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M14.ctypes.data),
                                   ctypes.c_void_p(_M14_sliced.ctypes.data),
                                   ctypes.c_int(_M14.shape[0]),
                                   ctypes.c_int(_M14.shape[1]),
                                   ctypes.c_int(_M14.shape[2]),
                                   ctypes.c_int(R_0),
                                   ctypes.c_int(R_1),
                                   ctypes.c_int(W_0),
                                   ctypes.c_int(W_1))
                    # step  27 TRW,TWPRV->PVTRW
                    offset_now       = offset_8        
                    _M16_offset      = offset_now      
                    _M16             = np.ndarray(((P_1-P_0), (V_1-V_0), NTHC_INT, (R_1-R_0), (W_1-W_0)), buffer = buffer, offset = _M16_offset)
                    fn_contraction_012_02314_34012_wob(ctypes.c_void_p(_M14_sliced.ctypes.data),
                                                       ctypes.c_void_p(_M15.ctypes.data),
                                                       ctypes.c_void_p(_M16.ctypes.data),
                                                       ctypes.c_int(_M14_sliced.shape[0]),
                                                       ctypes.c_int(_M14_sliced.shape[1]),
                                                       ctypes.c_int(_M14_sliced.shape[2]),
                                                       ctypes.c_int(_M15.shape[2]),
                                                       ctypes.c_int(_M15.shape[4]))
                    # step  28 PVTRW->PVRWT
                    _M16_perm_offset = offset_5        
                    _M16_perm        = np.ndarray(((P_1-P_0), (V_1-V_0), (R_1-R_0), (W_1-W_0), NTHC_INT), buffer = buffer, offset = _M16_perm_offset)
                    fn_permutation_01234_01342_wob(ctypes.c_void_p(_M16.ctypes.data),
                                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((V_1-V_0)),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((R_1-R_0)),
                                                   ctypes.c_int((W_1-W_0)))
                    # step  29 TU,PVRWT->UPVRW
                    offset_now       = offset_7        
                    _M17_offset      = offset_now      
                    _M17             = np.ndarray((NTHC_INT, (P_1-P_0), (V_1-V_0), (R_1-R_0), (W_1-W_0)), buffer = buffer, offset = _M17_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
                    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
                    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M17.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M17.shape[0]
                    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
                    _M17             = _M17_reshaped.reshape(*shape_backup)
                    # step  30 UPVRW,UWPV->RUPVW
                    offset_now       = offset_5        
                    _M19_offset      = offset_now      
                    _M19             = np.ndarray(((R_1-R_0), NTHC_INT, (P_1-P_0), (V_1-V_0), (W_1-W_0)), buffer = buffer, offset = _M19_offset)
                    fn_contraction_01234_0412_30124_wob(ctypes.c_void_p(_M17.ctypes.data),
                                                        ctypes.c_void_p(_M18.ctypes.data),
                                                        ctypes.c_void_p(_M19.ctypes.data),
                                                        ctypes.c_int(_M17.shape[0]),
                                                        ctypes.c_int(_M17.shape[1]),
                                                        ctypes.c_int(_M17.shape[2]),
                                                        ctypes.c_int(_M17.shape[3]),
                                                        ctypes.c_int(_M17.shape[4]))
                    # step  31 slice _INPUT_5 with indices ['R']
                    _INPUT_5_sliced_offset = offset_7        
                    _INPUT_5_sliced  = np.ndarray(((R_1-R_0), NTHC_INT), buffer = buffer, offset = _INPUT_5_sliced_offset)
                    fn_slice_2_0(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                 ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_5.shape[0]),
                                 ctypes.c_int(_INPUT_5.shape[1]),
                                 ctypes.c_int(R_0),
                                 ctypes.c_int(R_1))
                    # step  32 slice _M10 with indices ['P', 'V']
                    _M10_sliced_offset = offset_8        
                    _M10_sliced      = np.ndarray((NTHC_INT, (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M10_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M10.ctypes.data),
                                   ctypes.c_void_p(_M10_sliced.ctypes.data),
                                   ctypes.c_int(_M10.shape[0]),
                                   ctypes.c_int(_M10.shape[1]),
                                   ctypes.c_int(_M10.shape[2]),
                                   ctypes.c_int(P_0),
                                   ctypes.c_int(P_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  33 RS,SPV->RPVS
                    offset_now       = offset_9        
                    _M11_offset      = offset_now      
                    _M11             = np.ndarray(((R_1-R_0), (P_1-P_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M11_offset)
                    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M10_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M11.ctypes.data),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_5_sliced.shape[1]),
                                                   ctypes.c_int(_M10_sliced.shape[1]),
                                                   ctypes.c_int(_M10_sliced.shape[2]))
                    # step  34 cS,RPVS->cRPV
                    offset_now       = offset_7        
                    _M12_offset      = offset_now      
                    _M12             = np.ndarray((NVIR, (R_1-R_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M12_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_9.shape[0]
                    _INPUT_9_reshaped = _INPUT_9.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M11.shape[0]
                    _size_dim_1      = _size_dim_1 * _M11.shape[1]
                    _size_dim_1      = _size_dim_1 * _M11.shape[2]
                    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M12.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M12.shape[0]
                    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_9_reshaped, _M11_reshaped.T, c=_M12_reshaped)
                    _M12             = _M12_reshaped.reshape(*shape_backup)
                    # step  35 slice _INPUT_22 with indices ['W']
                    _INPUT_22_sliced_offset = offset_8        
                    _INPUT_22_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_22_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_22.shape[0]),
                                 ctypes.c_int(_INPUT_22.shape[1]),
                                 ctypes.c_int(W_0),
                                 ctypes.c_int(W_1))
                    # step  36 cW,cRPV->WRPVc
                    offset_now       = offset_9        
                    _M13_offset      = offset_now      
                    _M13             = np.ndarray(((W_1-W_0), (R_1-R_0), (P_1-P_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M13_offset)
                    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_22_sliced.ctypes.data),
                                                     ctypes.c_void_p(_M12.ctypes.data),
                                                     ctypes.c_void_p(_M13.ctypes.data),
                                                     ctypes.c_int(_INPUT_22_sliced.shape[0]),
                                                     ctypes.c_int(_INPUT_22_sliced.shape[1]),
                                                     ctypes.c_int(_M12.shape[1]),
                                                     ctypes.c_int(_M12.shape[2]),
                                                     ctypes.c_int(_M12.shape[3]))
                    # step  37 cU,WRPVc->UWRPV
                    offset_now       = offset_7        
                    _M20_offset      = offset_now      
                    _M20             = np.ndarray((NTHC_INT, (W_1-W_0), (R_1-R_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M20_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
                    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M13.shape[0]
                    _size_dim_1      = _size_dim_1 * _M13.shape[1]
                    _size_dim_1      = _size_dim_1 * _M13.shape[2]
                    _size_dim_1      = _size_dim_1 * _M13.shape[3]
                    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M20.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M20.shape[0]
                    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_14_reshaped.T, _M13_reshaped.T, c=_M20_reshaped)
                    _M20             = _M20_reshaped.reshape(*shape_backup)
                    # step  38 UWRPV->RUPVW
                    _M20_perm_offset = offset_8        
                    _M20_perm        = np.ndarray(((R_1-R_0), NTHC_INT, (P_1-P_0), (V_1-V_0), (W_1-W_0)), buffer = buffer, offset = _M20_perm_offset)
                    fn_permutation_01234_20341_wob(ctypes.c_void_p(_M20.ctypes.data),
                                                   ctypes.c_void_p(_M20_perm.ctypes.data),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((R_1-R_0)),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((V_1-V_0)))
                    # step  39 RUPVW,RUPVW->
                    output_tmp       = ctypes.c_double(0.0)
                    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
                           ctypes.c_void_p(_M20_perm.ctypes.data),
                           ctypes.c_int(_M19.size),
                           ctypes.pointer(output_tmp))
                    output_tmp = output_tmp.value
                    _M21 += output_tmp
                # step  40 end   for loop with indices ('V', 'W', 'P', 'R')
            # step  41 end   for loop with indices ('V', 'W', 'P')
        # step  42 end   for loop with indices ('V', 'W')
    # step  43 end   for loop with indices ('V',)
    # clean the final forloop
    # MPI finalize
    if use_mpi:
        _M21 = reduce(_M21, root=0)
        _M21 = bcast(_M21, root=0)
    return _M21

def RMP3_XX_8_forloop_P_R_determine_bucket_size_forloop(NVIR        : int,
                                                        NOCC        : int,
                                                        N_LAPLACE   : int,
                                                        NTHC_INT    : int,
                                                        P_bunchsize = 8,
                                                        R_bunchsize = 8,
                                                        V_bunchsize = 1,
                                                        W_bunchsize = 1):
    # init
    output = []     
    bucked_0_size    = 0               
    bucked_1_size    = 0               
    bucked_2_size    = 0               
    bucked_3_size    = 0               
    bucked_4_size    = 0               
    bucked_5_size    = 0               
    bucked_6_size    = 0               
    bucked_7_size    = 0               
    bucked_8_size    = 0               
    # assign the size of each tensor
    _M2_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M0_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M6_size         = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _M3_size         = (NTHC_INT * (N_LAPLACE * NOCC))
    _M1_size         = (NTHC_INT * (N_LAPLACE * NVIR))
    _M14_size        = (NTHC_INT * (NTHC_INT * N_LAPLACE))
    _INPUT_19_sliced_size = (NOCC * N_LAPLACE)
    _M18_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize)))
    _M0_sliced_size  = (P_bunchsize * (V_bunchsize * NOCC))
    _INPUT_21_sliced_size = (NVIR * N_LAPLACE)
    _M15_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * V_bunchsize)))
    _M4_size         = (W_bunchsize * (P_bunchsize * (V_bunchsize * NOCC)))
    _M1_sliced_size  = (P_bunchsize * (V_bunchsize * NVIR))
    _INPUT_0_sliced_size = (NTHC_INT * NTHC_INT)
    _M8_size         = (NVIR * (P_bunchsize * (R_bunchsize * V_bunchsize)))
    _M9_perm_size    = (P_bunchsize * (R_bunchsize * (NVIR * V_bunchsize)))
    _INPUT_5_sliced_size = (NTHC_INT * NTHC_INT)
    _M12_size        = (NVIR * (P_bunchsize * (V_bunchsize * R_bunchsize)))
    _M20_size        = (NTHC_INT * (W_bunchsize * (P_bunchsize * (V_bunchsize * R_bunchsize))))
    _M14_sliced_size = (NTHC_INT * (R_bunchsize * W_bunchsize))
    _M16_perm_size   = (R_bunchsize * (P_bunchsize * (V_bunchsize * (NTHC_INT * W_bunchsize))))
    _M19_size        = (R_bunchsize * (NTHC_INT * (P_bunchsize * (V_bunchsize * W_bunchsize))))
    _M5_size         = (W_bunchsize * (P_bunchsize * (V_bunchsize * NVIR)))
    _M6_sliced_size  = (NTHC_INT * (R_bunchsize * V_bunchsize))
    _INPUT_17_sliced_size = (NVIR * N_LAPLACE)
    _M10_size        = (NTHC_INT * (P_bunchsize * (R_bunchsize * V_bunchsize)))
    _INPUT_22_sliced_size = (NVIR * N_LAPLACE)
    _M20_perm_size   = (NTHC_INT * (W_bunchsize * (P_bunchsize * (V_bunchsize * R_bunchsize))))
    _M7_size         = (P_bunchsize * (R_bunchsize * (V_bunchsize * NTHC_INT)))
    _M9_size         = (P_bunchsize * (R_bunchsize * (NVIR * V_bunchsize)))
    _M11_size        = (P_bunchsize * (V_bunchsize * (R_bunchsize * NTHC_INT)))
    _M13_size        = (W_bunchsize * (P_bunchsize * (V_bunchsize * (R_bunchsize * NVIR))))
    _M16_size        = (R_bunchsize * (P_bunchsize * (V_bunchsize * (NTHC_INT * W_bunchsize))))
    _M17_size        = (NTHC_INT * (R_bunchsize * (P_bunchsize * (V_bunchsize * W_bunchsize))))
    # determine the size of each bucket
    # bucket 0
    bucked_0_size    = max(bucked_0_size, _M2_size)
    bucked_0_size    = max(bucked_0_size, _M0_size)
    # bucket 1
    bucked_1_size    = max(bucked_1_size, _M6_size)
    # bucket 2
    bucked_2_size    = max(bucked_2_size, _M3_size)
    bucked_2_size    = max(bucked_2_size, _M1_size)
    # bucket 3
    bucked_3_size    = max(bucked_3_size, _M14_size)
    # bucket 4
    bucked_4_size    = max(bucked_4_size, _INPUT_19_sliced_size)
    bucked_4_size    = max(bucked_4_size, _M18_size)
    # bucket 5
    bucked_5_size    = max(bucked_5_size, _M0_sliced_size)
    bucked_5_size    = max(bucked_5_size, _INPUT_21_sliced_size)
    bucked_5_size    = max(bucked_5_size, _M15_size)
    # bucket 6
    bucked_6_size    = max(bucked_6_size, _M4_size)
    bucked_6_size    = max(bucked_6_size, _M1_sliced_size)
    bucked_6_size    = max(bucked_6_size, _INPUT_0_sliced_size)
    bucked_6_size    = max(bucked_6_size, _M8_size)
    bucked_6_size    = max(bucked_6_size, _M9_perm_size)
    bucked_6_size    = max(bucked_6_size, _INPUT_5_sliced_size)
    bucked_6_size    = max(bucked_6_size, _M12_size)
    bucked_6_size    = max(bucked_6_size, _M20_size)
    bucked_6_size    = max(bucked_6_size, _M14_sliced_size)
    bucked_6_size    = max(bucked_6_size, _M16_perm_size)
    bucked_6_size    = max(bucked_6_size, _M19_size)
    # bucket 7
    bucked_7_size    = max(bucked_7_size, _M5_size)
    bucked_7_size    = max(bucked_7_size, _M6_sliced_size)
    bucked_7_size    = max(bucked_7_size, _INPUT_17_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M10_size)
    bucked_7_size    = max(bucked_7_size, _INPUT_22_sliced_size)
    bucked_7_size    = max(bucked_7_size, _M20_perm_size)
    # bucket 8
    bucked_8_size    = max(bucked_8_size, _M7_size)
    bucked_8_size    = max(bucked_8_size, _M9_size)
    bucked_8_size    = max(bucked_8_size, _M11_size)
    bucked_8_size    = max(bucked_8_size, _M13_size)
    bucked_8_size    = max(bucked_8_size, _M16_size)
    bucked_8_size    = max(bucked_8_size, _M17_size)
    # append each bucket size to the output
    output.append(bucked_0_size)
    output.append(bucked_1_size)
    output.append(bucked_2_size)
    output.append(bucked_3_size)
    output.append(bucked_4_size)
    output.append(bucked_5_size)
    output.append(bucked_6_size)
    output.append(bucked_7_size)
    output.append(bucked_8_size)
    return output

def RMP3_XX_8_forloop_P_R_naive(Z           : np.ndarray,
                                X_o         : np.ndarray,
                                X_v         : np.ndarray,
                                tau_o       : np.ndarray,
                                tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    t1 = (logger.process_clock(), logger.perf_counter())
    _M2              = np.einsum("jR,jV->RVj"    , _INPUT_6        , _INPUT_16       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.einsum("jQ,RVj->QRV"   , _INPUT_3        , _M2             )
    del _M2         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M0              = np.einsum("iP,iV->PVi"    , _INPUT_1        , _INPUT_15       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M3              = np.einsum("kR,kW->RWk"    , _INPUT_7        , _INPUT_20       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.einsum("kT,RWk->TRW"   , _INPUT_11       , _M3             )
    del _M3         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M1              = np.einsum("bP,bV->PVb"    , _INPUT_2        , _INPUT_18       )
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M4              = np.einsum("iW,PVi->WPVi"  , _INPUT_19       , _M0             )
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.einsum("iU,WPVi->UWPV" , _INPUT_13       , _M4             )
    del _M4         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M5              = np.einsum("bW,PVb->WPVb"  , _INPUT_21       , _M1             )
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.einsum("bT,WPVb->TWPV" , _INPUT_12       , _M5             )
    del _M5         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M7              = np.einsum("PQ,QRV->PRVQ"  , _INPUT_0        , _M6             )
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.einsum("aQ,PRVQ->aPRV" , _INPUT_4        , _M7             )
    del _M7         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9              = np.einsum("aV,aPRV->PRaV" , _INPUT_17       , _M8             )
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M9_perm         = np.transpose(_M9             , (0, 1, 3, 2)    )
    del _M9         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.einsum("aS,PRVa->SPRV" , _INPUT_8        , _M9_perm        )
    del _M9_perm    
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M11             = np.einsum("RS,SPRV->PVRS" , _INPUT_5        , _M10            )
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.einsum("cS,PVRS->cPVR" , _INPUT_9        , _M11            )
    del _M11        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M13             = np.einsum("cW,cPVR->WPVRc", _INPUT_22       , _M12            )
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.einsum("cU,WPVRc->UWPVR", _INPUT_14       , _M13            )
    del _M13        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20_perm        = np.transpose(_M20            , (4, 0, 2, 3, 1) )
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16             = np.einsum("TRW,TWPV->RPVTW", _M14            , _M15            )
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M16_perm        = np.transpose(_M16            , (0, 1, 2, 4, 3) )
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.einsum("TU,RPVWT->URPVW", _INPUT_10       , _M16_perm       )
    del _M16_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M19             = np.einsum("URPVW,UWPV->RUPVW", _M17            , _M18            )
    del _M17        
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    t1 = (logger.process_clock(), logger.perf_counter())
    _M21             = np.einsum("RUPVW,RUPVW->" , _M19            , _M20_perm       )
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 25")
    return _M21

def RMP3_XX_8_forloop_P_R(Z           : np.ndarray,
                          X_o         : np.ndarray,
                          X_v         : np.ndarray,
                          tau_o       : np.ndarray,
                          tau_v       : np.ndarray):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # step 0 jR,jV->RVj 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_6.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_6.shape[0]),
                                 ctypes.c_int(_INPUT_6.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 1")
    # step 1 jQ,RVj->QRV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6          = _M6_reshaped.reshape(*shape_backup)
    del _M2         
    del _M2_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 2")
    # step 2 iP,iV->PVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 3")
    # step 3 kR,kW->RWk 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_7.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_7.shape[0]),
                                 ctypes.c_int(_INPUT_7.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 4")
    # step 4 kT,RWk->TRW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M14             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_11_reshaped.T, _M3_reshaped.T, c=_M14_reshaped)
    _M14         = _M14_reshaped.reshape(*shape_backup)
    del _M3         
    del _M3_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 5")
    # step 5 bP,bV->PVb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 6")
    # step 6 iW,PVi->WPVi 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M4              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NOCC), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19.ctypes.data),
                                   ctypes.c_void_p(_M0.ctypes.data),
                                   ctypes.c_void_p(_M4.ctypes.data),
                                   ctypes.c_int(_INPUT_19.shape[0]),
                                   ctypes.c_int(_INPUT_19.shape[1]),
                                   ctypes.c_int(_M0.shape[0]),
                                   ctypes.c_int(_M0.shape[1]))
    del _M0         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 7")
    # step 7 iU,WPVi->UWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M18             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
    _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M4.shape[0]
    _size_dim_1      = _size_dim_1 * _M4.shape[1]
    _size_dim_1      = _size_dim_1 * _M4.shape[2]
    _M4_reshaped = _M4.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M18.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M18.shape[0]
    _M18_reshaped = _M18.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_13_reshaped.T, _M4_reshaped.T, c=_M18_reshaped)
    _M18         = _M18_reshaped.reshape(*shape_backup)
    del _M4         
    del _M4_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 8")
    # step 8 bW,PVb->WPVb 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    _M5              = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_21.ctypes.data),
                                   ctypes.c_void_p(_M1.ctypes.data),
                                   ctypes.c_void_p(_M5.ctypes.data),
                                   ctypes.c_int(_INPUT_21.shape[0]),
                                   ctypes.c_int(_INPUT_21.shape[1]),
                                   ctypes.c_int(_M1.shape[0]),
                                   ctypes.c_int(_M1.shape[1]))
    del _M1         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 9")
    # step 9 bT,WPVb->TWPV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M15             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
    _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M5.shape[0]
    _size_dim_1      = _size_dim_1 * _M5.shape[1]
    _size_dim_1      = _size_dim_1 * _M5.shape[2]
    _M5_reshaped = _M5.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M15.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M15.shape[0]
    _M15_reshaped = _M15.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_12_reshaped.T, _M5_reshaped.T, c=_M15_reshaped)
    _M15         = _M15_reshaped.reshape(*shape_backup)
    del _M5         
    del _M5_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 10")
    # step 10 PQ,QRV->PRVQ 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    _M7              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                   ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M7.ctypes.data),
                                   ctypes.c_int(_INPUT_0.shape[0]),
                                   ctypes.c_int(_INPUT_0.shape[1]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]))
    del _M6         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 11")
    # step 11 aQ,PRVQ->aPRV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M8              = np.ndarray((NVIR, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M7.shape[0]
    _size_dim_1      = _size_dim_1 * _M7.shape[1]
    _size_dim_1      = _size_dim_1 * _M7.shape[2]
    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M8.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M8.shape[0]
    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_4_reshaped, _M7_reshaped.T, c=_M8_reshaped)
    _M8          = _M8_reshaped.reshape(*shape_backup)
    del _M7         
    del _M7_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 12")
    # step 12 aV,aPRV->PRaV 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_0231_2301_wob = getattr(libpbc, "fn_contraction_01_0231_2301_wob", None)
    assert fn_contraction_01_0231_2301_wob is not None
    _M9              = np.ndarray((NTHC_INT, NTHC_INT, NVIR, N_LAPLACE), dtype=np.float64)
    fn_contraction_01_0231_2301_wob(ctypes.c_void_p(_INPUT_17.ctypes.data),
                                    ctypes.c_void_p(_M8.ctypes.data),
                                    ctypes.c_void_p(_M9.ctypes.data),
                                    ctypes.c_int(_INPUT_17.shape[0]),
                                    ctypes.c_int(_INPUT_17.shape[1]),
                                    ctypes.c_int(_M8.shape[1]),
                                    ctypes.c_int(_M8.shape[2]))
    del _M8         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 13")
    # step 13 PRaV->PRVa 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_0123_0132_wob = getattr(libpbc, "fn_permutation_0123_0132_wob", None)
    assert fn_permutation_0123_0132_wob is not None
    _M9_perm         = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NVIR), dtype=np.float64)
    fn_permutation_0123_0132_wob(ctypes.c_void_p(_M9.ctypes.data),
                                 ctypes.c_void_p(_M9_perm.ctypes.data),
                                 ctypes.c_int(_M9.shape[0]),
                                 ctypes.c_int(_M9.shape[1]),
                                 ctypes.c_int(_M9.shape[2]),
                                 ctypes.c_int(_M9.shape[3]))
    del _M9         
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 14")
    # step 14 aS,PRVa->SPRV 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M10             = np.ndarray((NTHC_INT, NTHC_INT, NTHC_INT, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_8.shape[0]
    _INPUT_8_reshaped = _INPUT_8.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M9_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M9_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M9_perm.shape[2]
    _M9_perm_reshaped = _M9_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M10.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M10.shape[0]
    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_8_reshaped.T, _M9_perm_reshaped.T, c=_M10_reshaped)
    _M10         = _M10_reshaped.reshape(*shape_backup)
    del _M9_perm    
    del _M9_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 15")
    # step 15 RS,SPRV->PVRS 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_1203_2301_wob = getattr(libpbc, "fn_contraction_01_1203_2301_wob", None)
    assert fn_contraction_01_1203_2301_wob is not None
    _M11             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, NTHC_INT), dtype=np.float64)
    fn_contraction_01_1203_2301_wob(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                    ctypes.c_void_p(_M10.ctypes.data),
                                    ctypes.c_void_p(_M11.ctypes.data),
                                    ctypes.c_int(_INPUT_5.shape[0]),
                                    ctypes.c_int(_INPUT_5.shape[1]),
                                    ctypes.c_int(_M10.shape[1]),
                                    ctypes.c_int(_M10.shape[3]))
    del _M10        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 16")
    # step 16 cS,PVRS->cPVR 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M12             = np.ndarray((NVIR, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_9.shape[0]
    _INPUT_9_reshaped = _INPUT_9.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M11.shape[0]
    _size_dim_1      = _size_dim_1 * _M11.shape[1]
    _size_dim_1      = _size_dim_1 * _M11.shape[2]
    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M12.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M12.shape[0]
    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_9_reshaped, _M11_reshaped.T, c=_M12_reshaped)
    _M12         = _M12_reshaped.reshape(*shape_backup)
    del _M11        
    del _M11_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 17")
    # step 17 cW,cPVR->WPVRc 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    _M13             = np.ndarray((N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT, NVIR), dtype=np.float64)
    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_22.ctypes.data),
                                     ctypes.c_void_p(_M12.ctypes.data),
                                     ctypes.c_void_p(_M13.ctypes.data),
                                     ctypes.c_int(_INPUT_22.shape[0]),
                                     ctypes.c_int(_INPUT_22.shape[1]),
                                     ctypes.c_int(_M12.shape[1]),
                                     ctypes.c_int(_M12.shape[2]),
                                     ctypes.c_int(_M12.shape[3]))
    del _M12        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 18")
    # step 18 cU,WPVRc->UWPVR 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M20             = np.ndarray((NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE, NTHC_INT), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M13.shape[0]
    _size_dim_1      = _size_dim_1 * _M13.shape[1]
    _size_dim_1      = _size_dim_1 * _M13.shape[2]
    _size_dim_1      = _size_dim_1 * _M13.shape[3]
    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M20.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M20.shape[0]
    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_14_reshaped.T, _M13_reshaped.T, c=_M20_reshaped)
    _M20         = _M20_reshaped.reshape(*shape_backup)
    del _M13        
    del _M13_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 19")
    # step 19 UWPVR->RUPVW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_40231_wob = getattr(libpbc, "fn_permutation_01234_40231_wob", None)
    assert fn_permutation_01234_40231_wob is not None
    _M20_perm        = np.ndarray((NTHC_INT, NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE), dtype=np.float64)
    fn_permutation_01234_40231_wob(ctypes.c_void_p(_M20.ctypes.data),
                                   ctypes.c_void_p(_M20_perm.ctypes.data),
                                   ctypes.c_int(_M20.shape[0]),
                                   ctypes.c_int(_M20.shape[1]),
                                   ctypes.c_int(_M20.shape[2]),
                                   ctypes.c_int(_M20.shape[3]),
                                   ctypes.c_int(_M20.shape[4]))
    del _M20        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 20")
    # step 20 TRW,TWPV->RPVTW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_012_0234_13402_wob = getattr(libpbc, "fn_contraction_012_0234_13402_wob", None)
    assert fn_contraction_012_0234_13402_wob is not None
    _M16             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, NTHC_INT, N_LAPLACE), dtype=np.float64)
    fn_contraction_012_0234_13402_wob(ctypes.c_void_p(_M14.ctypes.data),
                                      ctypes.c_void_p(_M15.ctypes.data),
                                      ctypes.c_void_p(_M16.ctypes.data),
                                      ctypes.c_int(_M14.shape[0]),
                                      ctypes.c_int(_M14.shape[1]),
                                      ctypes.c_int(_M14.shape[2]),
                                      ctypes.c_int(_M15.shape[2]),
                                      ctypes.c_int(_M15.shape[3]))
    del _M14        
    del _M15        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 21")
    # step 21 RPVTW->RPVWT 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_permutation_01234_01243_wob = getattr(libpbc, "fn_permutation_01234_01243_wob", None)
    assert fn_permutation_01234_01243_wob is not None
    _M16_perm        = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE, NTHC_INT), dtype=np.float64)
    fn_permutation_01234_01243_wob(ctypes.c_void_p(_M16.ctypes.data),
                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                   ctypes.c_int(_M16.shape[0]),
                                   ctypes.c_int(_M16.shape[1]),
                                   ctypes.c_int(_M16.shape[2]),
                                   ctypes.c_int(_M16.shape[3]),
                                   ctypes.c_int(_M16.shape[4]))
    del _M16        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 22")
    # step 22 TU,RPVWT->URPVW 
    t1 = (logger.process_clock(), logger.perf_counter())
    _M17             = np.ndarray((NTHC_INT, NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE), dtype=np.float64)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M17.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M17.shape[0]
    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
    _M17         = _M17_reshaped.reshape(*shape_backup)
    del _M16_perm   
    del _M16_perm_reshaped
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 23")
    # step 23 URPVW,UWPV->RUPVW 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_contraction_01234_0423_10234_wob = getattr(libpbc, "fn_contraction_01234_0423_10234_wob", None)
    assert fn_contraction_01234_0423_10234_wob is not None
    _M19             = np.ndarray((NTHC_INT, NTHC_INT, NTHC_INT, N_LAPLACE, N_LAPLACE), dtype=np.float64)
    fn_contraction_01234_0423_10234_wob(ctypes.c_void_p(_M17.ctypes.data),
                                        ctypes.c_void_p(_M18.ctypes.data),
                                        ctypes.c_void_p(_M19.ctypes.data),
                                        ctypes.c_int(_M17.shape[0]),
                                        ctypes.c_int(_M17.shape[1]),
                                        ctypes.c_int(_M17.shape[2]),
                                        ctypes.c_int(_M17.shape[3]),
                                        ctypes.c_int(_M17.shape[4]))
    del _M17        
    del _M18        
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 24")
    # step 24 RUPVW,RUPVW-> 
    t1 = (logger.process_clock(), logger.perf_counter())
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    _M21             = ctypes.c_double(0.0)
    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
           ctypes.c_void_p(_M20_perm.ctypes.data),
           ctypes.c_int(_M19.size),
           ctypes.pointer(_M21))
    _M21 = _M21.value
    del _M19        
    del _M20_perm   
    t2 = (logger.process_clock(), logger.perf_counter())
    _benchmark_time(t1, t2, "step 25")
    return _M21

def RMP3_XX_8_forloop_P_R_forloop_P_R(Z           : np.ndarray,
                                      X_o         : np.ndarray,
                                      X_v         : np.ndarray,
                                      tau_o       : np.ndarray,
                                      tau_v       : np.ndarray,
                                      buffer      : np.ndarray,
                                      P_bunchsize = 8,
                                      R_bunchsize = 8,
                                      V_bunchsize = 1,
                                      W_bunchsize = 1,
                                      use_mpi = False):
    # assign the size of the indices
    NVIR             = X_v.shape[0]    
    NOCC             = X_o.shape[0]    
    N_LAPLACE        = tau_o.shape[1]  
    NTHC_INT         = Z.shape[0]      
    # check the input parameters
    assert NTHC_INT == Z.shape[0]
    assert NTHC_INT == Z.shape[1]
    assert NOCC == X_o.shape[0]
    assert NTHC_INT == X_o.shape[1]
    assert NVIR == X_v.shape[0]
    assert NTHC_INT == X_v.shape[1]
    assert NOCC == tau_o.shape[0]
    assert N_LAPLACE == tau_o.shape[1]
    assert NVIR == tau_v.shape[0]
    assert N_LAPLACE == tau_v.shape[1]
    # assign the input/output parameters
    _INPUT_0         = Z               
    _INPUT_1         = X_o             
    _INPUT_2         = X_v             
    _INPUT_3         = X_o             
    _INPUT_4         = X_v             
    _INPUT_5         = Z               
    _INPUT_6         = X_o             
    _INPUT_7         = X_o             
    _INPUT_8         = X_v             
    _INPUT_9         = X_v             
    _INPUT_10        = Z               
    _INPUT_11        = X_o             
    _INPUT_12        = X_v             
    _INPUT_13        = X_o             
    _INPUT_14        = X_v             
    _INPUT_15        = tau_o           
    _INPUT_16        = tau_o           
    _INPUT_17        = tau_v           
    _INPUT_18        = tau_v           
    _INPUT_19        = tau_o           
    _INPUT_20        = tau_o           
    _INPUT_21        = tau_v           
    _INPUT_22        = tau_v           
    nthreads         = lib.num_threads()
    _M21             = 0.0             
    fn_copy      = getattr(libpbc, "fn_copy", None)
    assert fn_copy is not None
    fn_add       = getattr(libpbc, "fn_add", None)
    assert fn_add is not None
    fn_clean     = getattr(libpbc, "fn_clean", None)
    assert fn_clean is not None
    # fetch function pointers
    fn_contraction_01_0231_2301_wob = getattr(libpbc, "fn_contraction_01_0231_2301_wob", None)
    assert fn_contraction_01_0231_2301_wob is not None
    fn_permutation_0123_0132_wob = getattr(libpbc, "fn_permutation_0123_0132_wob", None)
    assert fn_permutation_0123_0132_wob is not None
    fn_contraction_01_0234_12340_wob = getattr(libpbc, "fn_contraction_01_0234_12340_wob", None)
    assert fn_contraction_01_0234_12340_wob is not None
    fn_slice_3_1_2 = getattr(libpbc, "fn_slice_3_1_2", None)
    assert fn_slice_3_1_2 is not None
    fn_contraction_01_1203_2301_wob = getattr(libpbc, "fn_contraction_01_1203_2301_wob", None)
    assert fn_contraction_01_1203_2301_wob is not None
    fn_contraction_01234_0423_10234_wob = getattr(libpbc, "fn_contraction_01234_0423_10234_wob", None)
    assert fn_contraction_01234_0423_10234_wob is not None
    fn_dot       = getattr(libpbc, "fn_dot", None)
    assert fn_dot is not None
    fn_slice_2_1 = getattr(libpbc, "fn_slice_2_1", None)
    assert fn_slice_2_1 is not None
    fn_slice_2_0 = getattr(libpbc, "fn_slice_2_0", None)
    assert fn_slice_2_0 is not None
    fn_contraction_01_02_120_wob = getattr(libpbc, "fn_contraction_01_02_120_wob", None)
    assert fn_contraction_01_02_120_wob is not None
    fn_slice_3_0_1 = getattr(libpbc, "fn_slice_3_0_1", None)
    assert fn_slice_3_0_1 is not None
    fn_contraction_01_230_1230_wob = getattr(libpbc, "fn_contraction_01_230_1230_wob", None)
    assert fn_contraction_01_230_1230_wob is not None
    fn_permutation_01234_40231_wob = getattr(libpbc, "fn_permutation_01234_40231_wob", None)
    assert fn_permutation_01234_40231_wob is not None
    fn_contraction_012_0234_13402_wob = getattr(libpbc, "fn_contraction_012_0234_13402_wob", None)
    assert fn_contraction_012_0234_13402_wob is not None
    fn_contraction_01_123_0231_wob = getattr(libpbc, "fn_contraction_01_123_0231_wob", None)
    assert fn_contraction_01_123_0231_wob is not None
    fn_permutation_01234_01243_wob = getattr(libpbc, "fn_permutation_01234_01243_wob", None)
    assert fn_permutation_01234_01243_wob is not None
    if use_mpi:
        bunchsize = NTHC_INT//comm_size + 1
        P_begin = rank*bunchsize
        P_end = (rank+1)*bunchsize
        P_begin          = min(P_begin, NTHC_INT)
        P_end            = min(P_end, NTHC_INT)
    else:
        P_begin          = 0               
        P_end            = NTHC_INT        
    # preallocate buffer
    bucket_size      = RMP3_XX_8_forloop_P_R_determine_bucket_size_forloop(NVIR = NVIR,
                                                                           NOCC = NOCC,
                                                                           N_LAPLACE = N_LAPLACE,
                                                                           NTHC_INT = NTHC_INT,
                                                                           P_bunchsize = P_bunchsize,
                                                                           V_bunchsize = V_bunchsize,
                                                                           W_bunchsize = W_bunchsize,
                                                                           R_bunchsize = R_bunchsize)
    bufsize_now      = buffer.size     
    _itemsize        = buffer.itemsize 
    offset_now       = 0               
    offset_0         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[0])
    offset_1         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[1])
    offset_2         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[2])
    offset_3         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[3])
    offset_4         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[4])
    offset_5         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[5])
    offset_6         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[6])
    offset_7         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[7])
    offset_8         = (offset_now * _itemsize)
    offset_now       = (offset_now + bucket_size[8])
    bufsize          = offset_now      
    if (bufsize > bufsize_now):
        buffer           = np.ndarray((bufsize), dtype=np.float64)
    # step   0 start for loop with indices ()
    # step   1 allocate   _M21
    _M21             = 0.0             
    # step   2 jR,jV->RVj
    offset_now       = offset_0        
    _M2_offset       = offset_now      
    _M2              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M2_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_6.ctypes.data),
                                 ctypes.c_void_p(_INPUT_16.ctypes.data),
                                 ctypes.c_void_p(_M2.ctypes.data),
                                 ctypes.c_int(_INPUT_6.shape[0]),
                                 ctypes.c_int(_INPUT_6.shape[1]),
                                 ctypes.c_int(_INPUT_16.shape[1]))
    # step   3 jQ,RVj->QRV
    offset_now       = offset_1        
    _M6_offset       = offset_now      
    _M6              = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M6_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_3.shape[0]
    _INPUT_3_reshaped = _INPUT_3.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M2.shape[0]
    _size_dim_1      = _size_dim_1 * _M2.shape[1]
    _M2_reshaped = _M2.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M6.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M6.shape[0]
    _M6_reshaped = _M6.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_3_reshaped.T, _M2_reshaped.T, c=_M6_reshaped)
    _M6              = _M6_reshaped.reshape(*shape_backup)
    # step   4 iP,iV->PVi
    offset_now       = offset_0        
    _M0_offset       = offset_now      
    _M0              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M0_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_1.ctypes.data),
                                 ctypes.c_void_p(_INPUT_15.ctypes.data),
                                 ctypes.c_void_p(_M0.ctypes.data),
                                 ctypes.c_int(_INPUT_1.shape[0]),
                                 ctypes.c_int(_INPUT_1.shape[1]),
                                 ctypes.c_int(_INPUT_15.shape[1]))
    # step   5 kR,kW->RWk
    offset_now       = offset_2        
    _M3_offset       = offset_now      
    _M3              = np.ndarray((NTHC_INT, N_LAPLACE, NOCC), buffer = buffer, offset = _M3_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_7.ctypes.data),
                                 ctypes.c_void_p(_INPUT_20.ctypes.data),
                                 ctypes.c_void_p(_M3.ctypes.data),
                                 ctypes.c_int(_INPUT_7.shape[0]),
                                 ctypes.c_int(_INPUT_7.shape[1]),
                                 ctypes.c_int(_INPUT_20.shape[1]))
    # step   6 kT,RWk->TRW
    offset_now       = offset_3        
    _M14_offset      = offset_now      
    _M14             = np.ndarray((NTHC_INT, NTHC_INT, N_LAPLACE), buffer = buffer, offset = _M14_offset)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _INPUT_11.shape[0]
    _INPUT_11_reshaped = _INPUT_11.reshape(_size_dim_1,-1)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M3.shape[0]
    _size_dim_1      = _size_dim_1 * _M3.shape[1]
    _M3_reshaped = _M3.reshape(_size_dim_1,-1)
    shape_backup = copy.deepcopy(_M14.shape)
    _size_dim_1      = 1               
    _size_dim_1      = _size_dim_1 * _M14.shape[0]
    _M14_reshaped = _M14.reshape(_size_dim_1,-1)
    lib.ddot(_INPUT_11_reshaped.T, _M3_reshaped.T, c=_M14_reshaped)
    _M14             = _M14_reshaped.reshape(*shape_backup)
    # step   7 bP,bV->PVb
    offset_now       = offset_2        
    _M1_offset       = offset_now      
    _M1              = np.ndarray((NTHC_INT, N_LAPLACE, NVIR), buffer = buffer, offset = _M1_offset)
    fn_contraction_01_02_120_wob(ctypes.c_void_p(_INPUT_2.ctypes.data),
                                 ctypes.c_void_p(_INPUT_18.ctypes.data),
                                 ctypes.c_void_p(_M1.ctypes.data),
                                 ctypes.c_int(_INPUT_2.shape[0]),
                                 ctypes.c_int(_INPUT_2.shape[1]),
                                 ctypes.c_int(_INPUT_18.shape[1]))
    # step   8 start for loop with indices ('P',)
    for P_0, P_1 in lib.prange(P_begin,P_end,P_bunchsize):
        # step   9 start for loop with indices ('P', 'V')
        for V_0, V_1 in lib.prange(0,N_LAPLACE,V_bunchsize):
            # step  10 start for loop with indices ('P', 'V', 'W')
            for W_0, W_1 in lib.prange(0,N_LAPLACE,W_bunchsize):
                # step  11 slice _INPUT_19 with indices ['W']
                _INPUT_19_sliced_offset = offset_4        
                _INPUT_19_sliced = np.ndarray((NOCC, (W_1-W_0)), buffer = buffer, offset = _INPUT_19_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_19.ctypes.data),
                             ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_19.shape[0]),
                             ctypes.c_int(_INPUT_19.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  12 slice _M0 with indices ['P', 'V']
                _M0_sliced_offset = offset_5        
                _M0_sliced       = np.ndarray(((P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M0_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M0.ctypes.data),
                               ctypes.c_void_p(_M0_sliced.ctypes.data),
                               ctypes.c_int(_M0.shape[0]),
                               ctypes.c_int(_M0.shape[1]),
                               ctypes.c_int(_M0.shape[2]),
                               ctypes.c_int(P_0),
                               ctypes.c_int(P_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  13 iW,PVi->WPVi
                offset_now       = offset_6        
                _M4_offset       = offset_now      
                _M4              = np.ndarray(((W_1-W_0), (P_1-P_0), (V_1-V_0), NOCC), buffer = buffer, offset = _M4_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_19_sliced.ctypes.data),
                                               ctypes.c_void_p(_M0_sliced.ctypes.data),
                                               ctypes.c_void_p(_M4.ctypes.data),
                                               ctypes.c_int(_INPUT_19_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_19_sliced.shape[1]),
                                               ctypes.c_int(_M0_sliced.shape[0]),
                                               ctypes.c_int(_M0_sliced.shape[1]))
                # step  14 iU,WPVi->UWPV
                offset_now       = offset_4        
                _M18_offset      = offset_now      
                _M18             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M18_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_13.shape[0]
                _INPUT_13_reshaped = _INPUT_13.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M4.shape[0]
                _size_dim_1      = _size_dim_1 * _M4.shape[1]
                _size_dim_1      = _size_dim_1 * _M4.shape[2]
                _M4_reshaped = _M4.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M18.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M18.shape[0]
                _M18_reshaped = _M18.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_13_reshaped.T, _M4_reshaped.T, c=_M18_reshaped)
                _M18             = _M18_reshaped.reshape(*shape_backup)
                # step  15 slice _INPUT_21 with indices ['W']
                _INPUT_21_sliced_offset = offset_5        
                _INPUT_21_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_21_sliced_offset)
                fn_slice_2_1(ctypes.c_void_p(_INPUT_21.ctypes.data),
                             ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                             ctypes.c_int(_INPUT_21.shape[0]),
                             ctypes.c_int(_INPUT_21.shape[1]),
                             ctypes.c_int(W_0),
                             ctypes.c_int(W_1))
                # step  16 slice _M1 with indices ['P', 'V']
                _M1_sliced_offset = offset_6        
                _M1_sliced       = np.ndarray(((P_1-P_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M1_sliced_offset)
                fn_slice_3_0_1(ctypes.c_void_p(_M1.ctypes.data),
                               ctypes.c_void_p(_M1_sliced.ctypes.data),
                               ctypes.c_int(_M1.shape[0]),
                               ctypes.c_int(_M1.shape[1]),
                               ctypes.c_int(_M1.shape[2]),
                               ctypes.c_int(P_0),
                               ctypes.c_int(P_1),
                               ctypes.c_int(V_0),
                               ctypes.c_int(V_1))
                # step  17 bW,PVb->WPVb
                offset_now       = offset_7        
                _M5_offset       = offset_now      
                _M5              = np.ndarray(((W_1-W_0), (P_1-P_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M5_offset)
                fn_contraction_01_230_1230_wob(ctypes.c_void_p(_INPUT_21_sliced.ctypes.data),
                                               ctypes.c_void_p(_M1_sliced.ctypes.data),
                                               ctypes.c_void_p(_M5.ctypes.data),
                                               ctypes.c_int(_INPUT_21_sliced.shape[0]),
                                               ctypes.c_int(_INPUT_21_sliced.shape[1]),
                                               ctypes.c_int(_M1_sliced.shape[0]),
                                               ctypes.c_int(_M1_sliced.shape[1]))
                # step  18 bT,WPVb->TWPV
                offset_now       = offset_5        
                _M15_offset      = offset_now      
                _M15             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (V_1-V_0)), buffer = buffer, offset = _M15_offset)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _INPUT_12.shape[0]
                _INPUT_12_reshaped = _INPUT_12.reshape(_size_dim_1,-1)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M5.shape[0]
                _size_dim_1      = _size_dim_1 * _M5.shape[1]
                _size_dim_1      = _size_dim_1 * _M5.shape[2]
                _M5_reshaped = _M5.reshape(_size_dim_1,-1)
                shape_backup = copy.deepcopy(_M15.shape)
                _size_dim_1      = 1               
                _size_dim_1      = _size_dim_1 * _M15.shape[0]
                _M15_reshaped = _M15.reshape(_size_dim_1,-1)
                lib.ddot(_INPUT_12_reshaped.T, _M5_reshaped.T, c=_M15_reshaped)
                _M15             = _M15_reshaped.reshape(*shape_backup)
                # step  19 start for loop with indices ('P', 'V', 'W', 'R')
                for R_0, R_1 in lib.prange(0,NTHC_INT,R_bunchsize):
                    # step  20 slice _INPUT_0 with indices ['P']
                    _INPUT_0_sliced_offset = offset_6        
                    _INPUT_0_sliced  = np.ndarray(((P_1-P_0), NTHC_INT), buffer = buffer, offset = _INPUT_0_sliced_offset)
                    fn_slice_2_0(ctypes.c_void_p(_INPUT_0.ctypes.data),
                                 ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_0.shape[0]),
                                 ctypes.c_int(_INPUT_0.shape[1]),
                                 ctypes.c_int(P_0),
                                 ctypes.c_int(P_1))
                    # step  21 slice _M6 with indices ['R', 'V']
                    _M6_sliced_offset = offset_7        
                    _M6_sliced       = np.ndarray((NTHC_INT, (R_1-R_0), (V_1-V_0)), buffer = buffer, offset = _M6_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M6.ctypes.data),
                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                   ctypes.c_int(_M6.shape[0]),
                                   ctypes.c_int(_M6.shape[1]),
                                   ctypes.c_int(_M6.shape[2]),
                                   ctypes.c_int(R_0),
                                   ctypes.c_int(R_1),
                                   ctypes.c_int(V_0),
                                   ctypes.c_int(V_1))
                    # step  22 PQ,QRV->PRVQ
                    offset_now       = offset_8        
                    _M7_offset       = offset_now      
                    _M7              = np.ndarray(((P_1-P_0), (R_1-R_0), (V_1-V_0), NTHC_INT), buffer = buffer, offset = _M7_offset)
                    fn_contraction_01_123_0231_wob(ctypes.c_void_p(_INPUT_0_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M6_sliced.ctypes.data),
                                                   ctypes.c_void_p(_M7.ctypes.data),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[0]),
                                                   ctypes.c_int(_INPUT_0_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[1]),
                                                   ctypes.c_int(_M6_sliced.shape[2]))
                    # step  23 aQ,PRVQ->aPRV
                    offset_now       = offset_6        
                    _M8_offset       = offset_now      
                    _M8              = np.ndarray((NVIR, (P_1-P_0), (R_1-R_0), (V_1-V_0)), buffer = buffer, offset = _M8_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_4.shape[0]
                    _INPUT_4_reshaped = _INPUT_4.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M7.shape[0]
                    _size_dim_1      = _size_dim_1 * _M7.shape[1]
                    _size_dim_1      = _size_dim_1 * _M7.shape[2]
                    _M7_reshaped = _M7.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M8.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M8.shape[0]
                    _M8_reshaped = _M8.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_4_reshaped, _M7_reshaped.T, c=_M8_reshaped)
                    _M8              = _M8_reshaped.reshape(*shape_backup)
                    # step  24 slice _INPUT_17 with indices ['V']
                    _INPUT_17_sliced_offset = offset_7        
                    _INPUT_17_sliced = np.ndarray((NVIR, (V_1-V_0)), buffer = buffer, offset = _INPUT_17_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_17.ctypes.data),
                                 ctypes.c_void_p(_INPUT_17_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_17.shape[0]),
                                 ctypes.c_int(_INPUT_17.shape[1]),
                                 ctypes.c_int(V_0),
                                 ctypes.c_int(V_1))
                    # step  25 aV,aPRV->PRaV
                    offset_now       = offset_8        
                    _M9_offset       = offset_now      
                    _M9              = np.ndarray(((P_1-P_0), (R_1-R_0), NVIR, (V_1-V_0)), buffer = buffer, offset = _M9_offset)
                    fn_contraction_01_0231_2301_wob(ctypes.c_void_p(_INPUT_17_sliced.ctypes.data),
                                                    ctypes.c_void_p(_M8.ctypes.data),
                                                    ctypes.c_void_p(_M9.ctypes.data),
                                                    ctypes.c_int(_INPUT_17_sliced.shape[0]),
                                                    ctypes.c_int(_INPUT_17_sliced.shape[1]),
                                                    ctypes.c_int(_M8.shape[1]),
                                                    ctypes.c_int(_M8.shape[2]))
                    # step  26 PRaV->PRVa
                    _M9_perm_offset  = offset_6        
                    _M9_perm         = np.ndarray(((P_1-P_0), (R_1-R_0), (V_1-V_0), NVIR), buffer = buffer, offset = _M9_perm_offset)
                    fn_permutation_0123_0132_wob(ctypes.c_void_p(_M9.ctypes.data),
                                                 ctypes.c_void_p(_M9_perm.ctypes.data),
                                                 ctypes.c_int((P_1-P_0)),
                                                 ctypes.c_int((R_1-R_0)),
                                                 ctypes.c_int(NVIR),
                                                 ctypes.c_int((V_1-V_0)))
                    # step  27 aS,PRVa->SPRV
                    offset_now       = offset_7        
                    _M10_offset      = offset_now      
                    _M10             = np.ndarray((NTHC_INT, (P_1-P_0), (R_1-R_0), (V_1-V_0)), buffer = buffer, offset = _M10_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_8.shape[0]
                    _INPUT_8_reshaped = _INPUT_8.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M9_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M9_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M9_perm.shape[2]
                    _M9_perm_reshaped = _M9_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M10.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M10.shape[0]
                    _M10_reshaped = _M10.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_8_reshaped.T, _M9_perm_reshaped.T, c=_M10_reshaped)
                    _M10             = _M10_reshaped.reshape(*shape_backup)
                    # step  28 slice _INPUT_5 with indices ['R']
                    _INPUT_5_sliced_offset = offset_6        
                    _INPUT_5_sliced  = np.ndarray(((R_1-R_0), NTHC_INT), buffer = buffer, offset = _INPUT_5_sliced_offset)
                    fn_slice_2_0(ctypes.c_void_p(_INPUT_5.ctypes.data),
                                 ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_5.shape[0]),
                                 ctypes.c_int(_INPUT_5.shape[1]),
                                 ctypes.c_int(R_0),
                                 ctypes.c_int(R_1))
                    # step  29 RS,SPRV->PVRS
                    offset_now       = offset_8        
                    _M11_offset      = offset_now      
                    _M11             = np.ndarray(((P_1-P_0), (V_1-V_0), (R_1-R_0), NTHC_INT), buffer = buffer, offset = _M11_offset)
                    fn_contraction_01_1203_2301_wob(ctypes.c_void_p(_INPUT_5_sliced.ctypes.data),
                                                    ctypes.c_void_p(_M10.ctypes.data),
                                                    ctypes.c_void_p(_M11.ctypes.data),
                                                    ctypes.c_int(_INPUT_5_sliced.shape[0]),
                                                    ctypes.c_int(_INPUT_5_sliced.shape[1]),
                                                    ctypes.c_int(_M10.shape[1]),
                                                    ctypes.c_int(_M10.shape[3]))
                    # step  30 cS,PVRS->cPVR
                    offset_now       = offset_6        
                    _M12_offset      = offset_now      
                    _M12             = np.ndarray((NVIR, (P_1-P_0), (V_1-V_0), (R_1-R_0)), buffer = buffer, offset = _M12_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_9.shape[0]
                    _INPUT_9_reshaped = _INPUT_9.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M11.shape[0]
                    _size_dim_1      = _size_dim_1 * _M11.shape[1]
                    _size_dim_1      = _size_dim_1 * _M11.shape[2]
                    _M11_reshaped = _M11.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M12.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M12.shape[0]
                    _M12_reshaped = _M12.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_9_reshaped, _M11_reshaped.T, c=_M12_reshaped)
                    _M12             = _M12_reshaped.reshape(*shape_backup)
                    # step  31 slice _INPUT_22 with indices ['W']
                    _INPUT_22_sliced_offset = offset_7        
                    _INPUT_22_sliced = np.ndarray((NVIR, (W_1-W_0)), buffer = buffer, offset = _INPUT_22_sliced_offset)
                    fn_slice_2_1(ctypes.c_void_p(_INPUT_22.ctypes.data),
                                 ctypes.c_void_p(_INPUT_22_sliced.ctypes.data),
                                 ctypes.c_int(_INPUT_22.shape[0]),
                                 ctypes.c_int(_INPUT_22.shape[1]),
                                 ctypes.c_int(W_0),
                                 ctypes.c_int(W_1))
                    # step  32 cW,cPVR->WPVRc
                    offset_now       = offset_8        
                    _M13_offset      = offset_now      
                    _M13             = np.ndarray(((W_1-W_0), (P_1-P_0), (V_1-V_0), (R_1-R_0), NVIR), buffer = buffer, offset = _M13_offset)
                    fn_contraction_01_0234_12340_wob(ctypes.c_void_p(_INPUT_22_sliced.ctypes.data),
                                                     ctypes.c_void_p(_M12.ctypes.data),
                                                     ctypes.c_void_p(_M13.ctypes.data),
                                                     ctypes.c_int(_INPUT_22_sliced.shape[0]),
                                                     ctypes.c_int(_INPUT_22_sliced.shape[1]),
                                                     ctypes.c_int(_M12.shape[1]),
                                                     ctypes.c_int(_M12.shape[2]),
                                                     ctypes.c_int(_M12.shape[3]))
                    # step  33 cU,WPVRc->UWPVR
                    offset_now       = offset_6        
                    _M20_offset      = offset_now      
                    _M20             = np.ndarray((NTHC_INT, (W_1-W_0), (P_1-P_0), (V_1-V_0), (R_1-R_0)), buffer = buffer, offset = _M20_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_14.shape[0]
                    _INPUT_14_reshaped = _INPUT_14.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M13.shape[0]
                    _size_dim_1      = _size_dim_1 * _M13.shape[1]
                    _size_dim_1      = _size_dim_1 * _M13.shape[2]
                    _size_dim_1      = _size_dim_1 * _M13.shape[3]
                    _M13_reshaped = _M13.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M20.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M20.shape[0]
                    _M20_reshaped = _M20.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_14_reshaped.T, _M13_reshaped.T, c=_M20_reshaped)
                    _M20             = _M20_reshaped.reshape(*shape_backup)
                    # step  34 UWPVR->RUPVW
                    _M20_perm_offset = offset_7        
                    _M20_perm        = np.ndarray(((R_1-R_0), NTHC_INT, (P_1-P_0), (V_1-V_0), (W_1-W_0)), buffer = buffer, offset = _M20_perm_offset)
                    fn_permutation_01234_40231_wob(ctypes.c_void_p(_M20.ctypes.data),
                                                   ctypes.c_void_p(_M20_perm.ctypes.data),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((W_1-W_0)),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((V_1-V_0)),
                                                   ctypes.c_int((R_1-R_0)))
                    # step  35 slice _M14 with indices ['R', 'W']
                    _M14_sliced_offset = offset_6        
                    _M14_sliced      = np.ndarray((NTHC_INT, (R_1-R_0), (W_1-W_0)), buffer = buffer, offset = _M14_sliced_offset)
                    fn_slice_3_1_2(ctypes.c_void_p(_M14.ctypes.data),
                                   ctypes.c_void_p(_M14_sliced.ctypes.data),
                                   ctypes.c_int(_M14.shape[0]),
                                   ctypes.c_int(_M14.shape[1]),
                                   ctypes.c_int(_M14.shape[2]),
                                   ctypes.c_int(R_0),
                                   ctypes.c_int(R_1),
                                   ctypes.c_int(W_0),
                                   ctypes.c_int(W_1))
                    # step  36 TRW,TWPV->RPVTW
                    offset_now       = offset_8        
                    _M16_offset      = offset_now      
                    _M16             = np.ndarray(((R_1-R_0), (P_1-P_0), (V_1-V_0), NTHC_INT, (W_1-W_0)), buffer = buffer, offset = _M16_offset)
                    fn_contraction_012_0234_13402_wob(ctypes.c_void_p(_M14_sliced.ctypes.data),
                                                      ctypes.c_void_p(_M15.ctypes.data),
                                                      ctypes.c_void_p(_M16.ctypes.data),
                                                      ctypes.c_int(_M14_sliced.shape[0]),
                                                      ctypes.c_int(_M14_sliced.shape[1]),
                                                      ctypes.c_int(_M14_sliced.shape[2]),
                                                      ctypes.c_int(_M15.shape[2]),
                                                      ctypes.c_int(_M15.shape[3]))
                    # step  37 RPVTW->RPVWT
                    _M16_perm_offset = offset_6        
                    _M16_perm        = np.ndarray(((R_1-R_0), (P_1-P_0), (V_1-V_0), (W_1-W_0), NTHC_INT), buffer = buffer, offset = _M16_perm_offset)
                    fn_permutation_01234_01243_wob(ctypes.c_void_p(_M16.ctypes.data),
                                                   ctypes.c_void_p(_M16_perm.ctypes.data),
                                                   ctypes.c_int((R_1-R_0)),
                                                   ctypes.c_int((P_1-P_0)),
                                                   ctypes.c_int((V_1-V_0)),
                                                   ctypes.c_int(NTHC_INT),
                                                   ctypes.c_int((W_1-W_0)))
                    # step  38 TU,RPVWT->URPVW
                    offset_now       = offset_8        
                    _M17_offset      = offset_now      
                    _M17             = np.ndarray((NTHC_INT, (R_1-R_0), (P_1-P_0), (V_1-V_0), (W_1-W_0)), buffer = buffer, offset = _M17_offset)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _INPUT_10.shape[0]
                    _INPUT_10_reshaped = _INPUT_10.reshape(_size_dim_1,-1)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[0]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[1]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[2]
                    _size_dim_1      = _size_dim_1 * _M16_perm.shape[3]
                    _M16_perm_reshaped = _M16_perm.reshape(_size_dim_1,-1)
                    shape_backup = copy.deepcopy(_M17.shape)
                    _size_dim_1      = 1               
                    _size_dim_1      = _size_dim_1 * _M17.shape[0]
                    _M17_reshaped = _M17.reshape(_size_dim_1,-1)
                    lib.ddot(_INPUT_10_reshaped.T, _M16_perm_reshaped.T, c=_M17_reshaped)
                    _M17             = _M17_reshaped.reshape(*shape_backup)
                    # step  39 URPVW,UWPV->RUPVW
                    offset_now       = offset_6        
                    _M19_offset      = offset_now      
                    _M19             = np.ndarray(((R_1-R_0), NTHC_INT, (P_1-P_0), (V_1-V_0), (W_1-W_0)), buffer = buffer, offset = _M19_offset)
                    fn_contraction_01234_0423_10234_wob(ctypes.c_void_p(_M17.ctypes.data),
                                                        ctypes.c_void_p(_M18.ctypes.data),
                                                        ctypes.c_void_p(_M19.ctypes.data),
                                                        ctypes.c_int(_M17.shape[0]),
                                                        ctypes.c_int(_M17.shape[1]),
                                                        ctypes.c_int(_M17.shape[2]),
                                                        ctypes.c_int(_M17.shape[3]),
                                                        ctypes.c_int(_M17.shape[4]))
                    # step  40 RUPVW,RUPVW->
                    output_tmp       = ctypes.c_double(0.0)
                    fn_dot(ctypes.c_void_p(_M19.ctypes.data),
                           ctypes.c_void_p(_M20_perm.ctypes.data),
                           ctypes.c_int(_M19.size),
                           ctypes.pointer(output_tmp))
                    output_tmp = output_tmp.value
                    _M21 += output_tmp
                # step  41 end   for loop with indices ('P', 'V', 'W', 'R')
            # step  42 end   for loop with indices ('P', 'V', 'W')
        # step  43 end   for loop with indices ('P', 'V')
    # step  44 end   for loop with indices ('P',)
    # clean the final forloop
    # MPI finalize
    if use_mpi:
        _M21 = reduce(_M21, root=0)
        _M21 = bcast(_M21, root=0)
    return _M21

if __name__ == "__main__":
    NVIR = np.random.randint(8, 16)
    NOCC = np.random.randint(8, 16)
    N_LAPLACE = np.random.randint(8, 16)
    NTHC_INT = np.random.randint(8, 16)
    NTHC_AMPLITUDE = np.random.randint(8, 16)
    Z                = np.random.random((NTHC_INT, NTHC_INT))
    X_o              = np.random.random((NOCC, NTHC_INT))
    X_v              = np.random.random((NVIR, NTHC_INT))
    T                = np.random.random((NTHC_AMPLITUDE, NTHC_AMPLITUDE))
    TAU_o            = np.random.random((NOCC, NTHC_AMPLITUDE))
    TAU_v            = np.random.random((NVIR, NTHC_AMPLITUDE))
    tau_o            = np.random.random((NOCC, N_LAPLACE))
    tau_v            = np.random.random((NVIR, N_LAPLACE))
    T1               = np.random.random((NOCC, NVIR))
    buffer           = np.random.random((16))
    Z = (Z + Z.T)/2 
    # test for RMP3_XX_1_forloop_P_R and RMP3_XX_1_forloop_P_R_naive
    benchmark        = RMP3_XX_1_forloop_P_R_naive(Z               ,
                                                   X_o             ,
                                                   X_v             ,
                                                   tau_o           ,
                                                   tau_v           )
    output           = RMP3_XX_1_forloop_P_R(Z               ,
                                             X_o             ,
                                             X_v             ,
                                             tau_o           ,
                                             tau_v           )
    assert np.allclose(output, benchmark)
    print(output)   
    print(benchmark)
    # test for RMP3_XX_1_forloop_P_R_forloop_P_R
    output3          = RMP3_XX_1_forloop_P_R_forloop_P_R(Z               ,
                                                         X_o             ,
                                                         X_v             ,
                                                         tau_o           ,
                                                         tau_v           ,
                                                         buffer          )
    assert np.allclose(output3, benchmark)
    print(output3)  
    # test for RMP3_XX_1_forloop_P_U and RMP3_XX_1_forloop_P_U_naive
    benchmark        = RMP3_XX_1_forloop_P_U_naive(Z               ,
                                                   X_o             ,
                                                   X_v             ,
                                                   tau_o           ,
                                                   tau_v           )
    output           = RMP3_XX_1_forloop_P_U(Z               ,
                                             X_o             ,
                                             X_v             ,
                                             tau_o           ,
                                             tau_v           )
    assert np.allclose(output, benchmark)
    print(output)   
    print(benchmark)
    # test for RMP3_XX_1_forloop_P_U_forloop_P_U
    output3          = RMP3_XX_1_forloop_P_U_forloop_P_U(Z               ,
                                                         X_o             ,
                                                         X_v             ,
                                                         tau_o           ,
                                                         tau_v           ,
                                                         buffer          )
    assert np.allclose(output3, benchmark)
    print(output3)  
    # test for RMP3_XX_1_forloop_Q_S and RMP3_XX_1_forloop_Q_S_naive
    benchmark        = RMP3_XX_1_forloop_Q_S_naive(Z               ,
                                                   X_o             ,
                                                   X_v             ,
                                                   tau_o           ,
                                                   tau_v           )
    output           = RMP3_XX_1_forloop_Q_S(Z               ,
                                             X_o             ,
                                             X_v             ,
                                             tau_o           ,
                                             tau_v           )
    assert np.allclose(output, benchmark)
    print(output)   
    print(benchmark)
    # test for RMP3_XX_1_forloop_Q_S_forloop_Q_S
    output3          = RMP3_XX_1_forloop_Q_S_forloop_Q_S(Z               ,
                                                         X_o             ,
                                                         X_v             ,
                                                         tau_o           ,
                                                         tau_v           ,
                                                         buffer          )
    assert np.allclose(output3, benchmark)
    print(output3)  
    # test for RMP3_XX_1_forloop_Q_U and RMP3_XX_1_forloop_Q_U_naive
    benchmark        = RMP3_XX_1_forloop_Q_U_naive(Z               ,
                                                   X_o             ,
                                                   X_v             ,
                                                   tau_o           ,
                                                   tau_v           )
    output           = RMP3_XX_1_forloop_Q_U(Z               ,
                                             X_o             ,
                                             X_v             ,
                                             tau_o           ,
                                             tau_v           )
    assert np.allclose(output, benchmark)
    print(output)   
    print(benchmark)
    # test for RMP3_XX_1_forloop_Q_U_forloop_Q_U
    output3          = RMP3_XX_1_forloop_Q_U_forloop_Q_U(Z               ,
                                                         X_o             ,
                                                         X_v             ,
                                                         tau_o           ,
                                                         tau_v           ,
                                                         buffer          )
    assert np.allclose(output3, benchmark)
    print(output3)  
    # test for RMP3_XX_1_forloop_R_T and RMP3_XX_1_forloop_R_T_naive
    benchmark        = RMP3_XX_1_forloop_R_T_naive(Z               ,
                                                   X_o             ,
                                                   X_v             ,
                                                   tau_o           ,
                                                   tau_v           )
    output           = RMP3_XX_1_forloop_R_T(Z               ,
                                             X_o             ,
                                             X_v             ,
                                             tau_o           ,
                                             tau_v           )
    assert np.allclose(output, benchmark)
    print(output)   
    print(benchmark)
    # test for RMP3_XX_1_forloop_R_T_forloop_T_R
    output3          = RMP3_XX_1_forloop_R_T_forloop_T_R(Z               ,
                                                         X_o             ,
                                                         X_v             ,
                                                         tau_o           ,
                                                         tau_v           ,
                                                         buffer          )
    assert np.allclose(output3, benchmark)
    print(output3)  
    # test for RMP3_XX_1_forloop_S_T and RMP3_XX_1_forloop_S_T_naive
    benchmark        = RMP3_XX_1_forloop_S_T_naive(Z               ,
                                                   X_o             ,
                                                   X_v             ,
                                                   tau_o           ,
                                                   tau_v           )
    output           = RMP3_XX_1_forloop_S_T(Z               ,
                                             X_o             ,
                                             X_v             ,
                                             tau_o           ,
                                             tau_v           )
    assert np.allclose(output, benchmark)
    print(output)   
    print(benchmark)
    # test for RMP3_XX_1_forloop_S_T_forloop_T_S
    output3          = RMP3_XX_1_forloop_S_T_forloop_T_S(Z               ,
                                                         X_o             ,
                                                         X_v             ,
                                                         tau_o           ,
                                                         tau_v           ,
                                                         buffer          )
    assert np.allclose(output3, benchmark)
    print(output3)  
    # test for RMP3_XX_2_forloop_P_S and RMP3_XX_2_forloop_P_S_naive
    benchmark        = RMP3_XX_2_forloop_P_S_naive(Z               ,
                                                   X_o             ,
                                                   X_v             ,
                                                   tau_o           ,
                                                   tau_v           )
    output           = RMP3_XX_2_forloop_P_S(Z               ,
                                             X_o             ,
                                             X_v             ,
                                             tau_o           ,
                                             tau_v           )
    assert np.allclose(output, benchmark)
    print(output)   
    print(benchmark)
    # test for RMP3_XX_2_forloop_P_S_forloop_P_S
    output3          = RMP3_XX_2_forloop_P_S_forloop_P_S(Z               ,
                                                         X_o             ,
                                                         X_v             ,
                                                         tau_o           ,
                                                         tau_v           ,
                                                         buffer          )
    assert np.allclose(output3, benchmark)
    print(output3)  
    # test for RMP3_XX_3_forloop_P_S and RMP3_XX_3_forloop_P_S_naive
    benchmark        = RMP3_XX_3_forloop_P_S_naive(Z               ,
                                                   X_o             ,
                                                   X_v             ,
                                                   tau_o           ,
                                                   tau_v           )
    output           = RMP3_XX_3_forloop_P_S(Z               ,
                                             X_o             ,
                                             X_v             ,
                                             tau_o           ,
                                             tau_v           )
    assert np.allclose(output, benchmark)
    print(output)   
    print(benchmark)
    # test for RMP3_XX_3_forloop_P_S_forloop_P_S
    output3          = RMP3_XX_3_forloop_P_S_forloop_P_S(Z               ,
                                                         X_o             ,
                                                         X_v             ,
                                                         tau_o           ,
                                                         tau_v           ,
                                                         buffer          )
    assert np.allclose(output3, benchmark)
    print(output3)  
    # test for RMP3_XX_4_forloop_P_R and RMP3_XX_4_forloop_P_R_naive
    benchmark        = RMP3_XX_4_forloop_P_R_naive(Z               ,
                                                   X_o             ,
                                                   X_v             ,
                                                   tau_o           ,
                                                   tau_v           )
    output           = RMP3_XX_4_forloop_P_R(Z               ,
                                             X_o             ,
                                             X_v             ,
                                             tau_o           ,
                                             tau_v           )
    assert np.allclose(output, benchmark)
    print(output)   
    print(benchmark)
    # test for RMP3_XX_4_forloop_P_R_forloop_P_R
    output3          = RMP3_XX_4_forloop_P_R_forloop_P_R(Z               ,
                                                         X_o             ,
                                                         X_v             ,
                                                         tau_o           ,
                                                         tau_v           ,
                                                         buffer          )
    assert np.allclose(output3, benchmark)
    print(output3)  
    # test for RMP3_XX_5_forloop_P_S and RMP3_XX_5_forloop_P_S_naive
    benchmark        = RMP3_XX_5_forloop_P_S_naive(Z               ,
                                                   X_o             ,
                                                   X_v             ,
                                                   tau_o           ,
                                                   tau_v           )
    output           = RMP3_XX_5_forloop_P_S(Z               ,
                                             X_o             ,
                                             X_v             ,
                                             tau_o           ,
                                             tau_v           )
    assert np.allclose(output, benchmark)
    print(output)   
    print(benchmark)
    # test for RMP3_XX_5_forloop_P_S_forloop_P_S
    output3          = RMP3_XX_5_forloop_P_S_forloop_P_S(Z               ,
                                                         X_o             ,
                                                         X_v             ,
                                                         tau_o           ,
                                                         tau_v           ,
                                                         buffer          )
    assert np.allclose(output3, benchmark)
    print(output3)  
    # test for RMP3_XX_6_forloop_P_S and RMP3_XX_6_forloop_P_S_naive
    benchmark        = RMP3_XX_6_forloop_P_S_naive(Z               ,
                                                   X_o             ,
                                                   X_v             ,
                                                   tau_o           ,
                                                   tau_v           )
    output           = RMP3_XX_6_forloop_P_S(Z               ,
                                             X_o             ,
                                             X_v             ,
                                             tau_o           ,
                                             tau_v           )
    assert np.allclose(output, benchmark)
    print(output)   
    print(benchmark)
    # test for RMP3_XX_6_forloop_P_S_forloop_P_S
    output3          = RMP3_XX_6_forloop_P_S_forloop_P_S(Z               ,
                                                         X_o             ,
                                                         X_v             ,
                                                         tau_o           ,
                                                         tau_v           ,
                                                         buffer          )
    assert np.allclose(output3, benchmark)
    print(output3)  
    # test for RMP3_XX_7_forloop_P_R and RMP3_XX_7_forloop_P_R_naive
    benchmark        = RMP3_XX_7_forloop_P_R_naive(Z               ,
                                                   X_o             ,
                                                   X_v             ,
                                                   tau_o           ,
                                                   tau_v           )
    output           = RMP3_XX_7_forloop_P_R(Z               ,
                                             X_o             ,
                                             X_v             ,
                                             tau_o           ,
                                             tau_v           )
    assert np.allclose(output, benchmark)
    print(output)   
    print(benchmark)
    # test for RMP3_XX_7_forloop_P_R_forloop_P_R
    output3          = RMP3_XX_7_forloop_P_R_forloop_P_R(Z               ,
                                                         X_o             ,
                                                         X_v             ,
                                                         tau_o           ,
                                                         tau_v           ,
                                                         buffer          )
    assert np.allclose(output3, benchmark)
    print(output3)  
    # test for RMP3_XX_8_forloop_P_R and RMP3_XX_8_forloop_P_R_naive
    benchmark        = RMP3_XX_8_forloop_P_R_naive(Z               ,
                                                   X_o             ,
                                                   X_v             ,
                                                   tau_o           ,
                                                   tau_v           )
    output           = RMP3_XX_8_forloop_P_R(Z               ,
                                             X_o             ,
                                             X_v             ,
                                             tau_o           ,
                                             tau_v           )
    assert np.allclose(output, benchmark)
    print(output)   
    print(benchmark)
    # test for RMP3_XX_8_forloop_P_R_forloop_P_R
    output3          = RMP3_XX_8_forloop_P_R_forloop_P_R(Z               ,
                                                         X_o             ,
                                                         X_v             ,
                                                         tau_o           ,
                                                         tau_v           ,
                                                         buffer          )
    assert np.allclose(output3, benchmark)
    print(output3)  
