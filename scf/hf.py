#!/usr/bin/env python
#
# Author: Qiming Sun <osirpt.sun@gmail.com>
#

'''
Hartree-Fock
'''

import sys
import tempfile
import time
from functools import reduce
import numpy
import scipy.linalg
import pyscf.gto
import pyscf.lib
from pyscf.lib import logger
from pyscf.scf import chkfile
from pyscf.scf import diis
from pyscf.scf import _vhf



def kernel(mf, conv_tol=1e-10, conv_tol_grad=None,
           dump_chk=True, dm0=None, callback=None, **kwargs):
    '''kernel: the SCF driver.

    Args:
        mf : an instance of SCF class
            To hold the flags to control SCF.  Besides the control parameters,
            one can modify its function members to change the behavior of SCF.
            The member functions which are called in kernel are

            | mf.get_init_guess
            | mf.get_hcore
            | mf.get_ovlp
            | mf.get_fock
            | mf.get_grad
            | mf.eig
            | mf.get_occ
            | mf.make_rdm1
            | mf.energy_tot
            | mf.dump_chk

    Kwargs:
        conv_tol : float
            converge threshold.
        conv_tol_grad : float
            gradients converge threshold.
        dump_chk : bool
            Whether to save SCF intermediate results in the checkpoint file
        dm0 : ndarray
            Initial guess density matrix.  If not given (the default), the kernel
            takes the density matrix generated by ``mf.get_init_guess``.
        callback : function(envs_dict) => None
            callback function takes one dict as the argument which is
            generated by the builtin function :func:`locals`, so that the
            callback function can access all local variables in the current
            envrionment.

    Returns:
        A list :   scf_conv, hf_energy, mo_energy, mo_coeff, mo_occ

        scf_conv : bool
            True means SCF converged
        hf_energy : float
            Hartree-Fock energy of last iteration
        mo_energy : 1D float array
            Orbital energies.  Depending the eig function provided by mf
            object, the orbital energies may NOT be sorted.
        mo_coeff : 2D array
            Orbital coefficients.
        mo_occ : 1D array
            Orbital occupancies.  The occupancies may NOT be sorted from large
            to small.

    Examples:

    >>> from pyscf import gto, scf
    >>> mol = gto.M(atom='H 0 0 0; H 0 0 1.1', basis='cc-pvdz')
    >>> conv, e, mo_e, mo, mo_occ = scf.hf.kernel(scf.hf.SCF(mol), dm0=numpy.eye(mol.nao_nr()))
    >>> print('conv = %s, E(HF) = %.12f' % (conv, e))
    conv = True, E(HF) = -1.081170784378
    '''
    if 'init_dm' in kwargs:
        raise RuntimeError('''
You see this error message because of the API updates in pyscf v0.11.
Keyword argument "init_dm" is replaced by "dm0"''')
    cput0 = (time.clock(), time.time())
    if conv_tol_grad is None:
        conv_tol_grad = numpy.sqrt(conv_tol)
        logger.info(mf, 'Set gradient conv threshold to %g', conv_tol_grad)

    mol = mf.mol
    if dm0 is None:
        dm = mf.get_init_guess(mol, mf.init_guess)
    else:
        dm = dm0

    h1e = mf.get_hcore(mol)
    s1e = mf.get_ovlp(mol)

    cond = numpy.linalg.cond(s1e)
    if cond*1e-17 > conv_tol:
        logger.warn(mf, 'Singularity detected in overlap matrix (condition number = %4.3g).'
                    'SCF may be inaccurate and hard to converge.', cond)

    if mf.diis and mf.DIIS:
        adiis = mf.DIIS(mf, mf.diis_file)
        adiis.space = mf.diis_space
        adiis.rollback = mf.diis_space_rollback
    else:
        adiis = None

    vhf = mf.get_veff(mol, dm)
    hf_energy = mf.energy_tot(dm, h1e, vhf)
    logger.info(mf, 'init E= %.15g', hf_energy)

    if dump_chk:
        # dump mol after reading initialized DM
        chkfile.save_mol(mol, mf.chkfile)

    scf_conv = False
    cycle = 0
    cput1 = logger.timer(mf, 'initialize scf', *cput0)
    while not scf_conv and cycle < max(1, mf.max_cycle):
        dm_last = dm
        last_hf_e = hf_energy

        fock = mf.get_fock(h1e, s1e, vhf, dm, cycle, adiis)
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        dm = mf.make_rdm1(mo_coeff, mo_occ)
        vhf = mf.get_veff(mol, dm, dm_last, vhf)
        hf_energy = mf.energy_tot(dm, h1e, vhf)

        norm_gorb = numpy.linalg.norm(mf.get_grad(mo_coeff, mo_occ, h1e+vhf))
        norm_ddm = numpy.linalg.norm(dm-dm_last)
        logger.info(mf, 'cycle= %d E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',
                    cycle+1, hf_energy, hf_energy-last_hf_e, norm_gorb, norm_ddm)

        if (abs(hf_energy-last_hf_e) < conv_tol and norm_gorb < conv_tol_grad):
            scf_conv = True

        if dump_chk:
            mf.dump_chk(locals())

        if callable(callback):
            callback(locals())

        cput1 = logger.timer(mf, 'cycle= %d'%(cycle+1), *cput1)
        cycle += 1

    # An extra diagonalization, to remove level shift
    fock = mf.get_fock(h1e, s1e, vhf, dm, cycle, None, 0, 0, 0)
    mo_energy, mo_coeff = mf.eig(fock, s1e)
    mo_occ = mf.get_occ(mo_energy, mo_coeff)
    logger.timer(mf, 'scf_cycle', *cput0)
    return scf_conv, hf_energy, mo_energy, mo_coeff, mo_occ


def energy_elec(mf, dm, h1e=None, vhf=None):
    r'''Electronic part of Hartree-Fock energy, for given core hamiltonian and
    HF potential

    ... math::

        E = \sum_{ij}h_{ij} \gamma_{ji}
          + \frac{1}{2}\sum_{ijkl} \gamma_{ji}\gamma_{lk} \langle ik||jl\rangle

    Args:
        mf : an instance of SCF class

        dm : 2D ndarray
            one-partical density matrix

    Kwargs:
        h1e : 2D ndarray
            Core hamiltonian
        vhf : 2D ndarray
            HF potential

    Returns:
        Hartree-Fock electronic energy and the Coulomb energy

    Examples:

    >>> from pyscf import gto, scf
    >>> mol = gto.M(atom='H 0 0 0; H 0 0 1.1')
    >>> mf = scf.RHF(mol)
    >>> mf.scf()
    >>> dm = mf.make_rdm1()
    >>> scf.hf.energy_elec(mf, dm)
    (-1.5176090667746334, 0.60917167853723675)
    '''
    if h1e is None: h1e = mf.get_hcore()
    if vhf is None: vhf = mf.get_veff(mf.mol, dm)
    e1 = numpy.einsum('ji,ji', h1e.conj(), dm).real
    e_coul = numpy.einsum('ji,ji', vhf.conj(), dm).real * .5
    logger.debug(mf, 'E_coul = %.15g', e_coul)
    return e1+e_coul, e_coul


def energy_tot(mf, dm, h1e=None, vhf=None):
    r'''Total Hartree-Fock energy, electronic part plus nuclear repulstion
    See :func:`scf.hf.energy_elec` for the electron part
    '''
    return energy_elec(mf, h1e, vhf, dm)[0] + mf.mol.energy_nuc()


def get_hcore(mol):
    '''Core Hamiltonian

    Examples:

    >>> from pyscf import gto, scf
    >>> mol = gto.M(atom='H 0 0 0; H 0 0 1.1')
    >>> scf.hf.get_hcore(mol)
    array([[-0.93767904, -0.59316327],
           [-0.59316327, -0.93767904]])
    '''
    h = mol.intor_symmetric('cint1e_kin_sph') \
      + mol.intor_symmetric('cint1e_nuc_sph')
    return h


def get_ovlp(mol):
    '''Overlap matrix
    '''
    return mol.intor_symmetric('cint1e_ovlp_sph')


def init_guess_by_minao(mol):
    '''Generate initial guess density matrix based on ANO basis, then project
    the density matrix to the basis set defined by ``mol``

    Returns:
        Density matrix, 2D ndarray

    Examples:

    >>> from pyscf import gto, scf
    >>> mol = gto.M(atom='H 0 0 0; H 0 0 1.1')
    >>> scf.hf.init_guess_by_minao(mol)
    array([[ 0.94758917,  0.09227308],
           [ 0.09227308,  0.94758917]])
    '''
    from pyscf.scf import atom_hf
    from pyscf.scf import addons

    def minao_basis(symb):
        basis_add = pyscf.gto.basis.load('ano', symb)
        occ = []
        basis_new = []
        for l in range(4):
            ndocc, nfrac = atom_hf.frac_occ(symb, l)
            if ndocc > 0:
                occ.extend([2]*ndocc*(2*l+1))
            if nfrac > 1e-15:
                occ.extend([nfrac]*(2*l+1))
                ndocc += 1
            if ndocc > 0:
                basis_new.append([l] + [b[:ndocc+1] for b in basis_add[l][1:]])
        return occ, basis_new

    atmlst = set([pyscf.gto.mole._rm_digit(pyscf.gto.mole._symbol(k))
                  for k in mol._basis.keys()])
    basis = {}
    occdic = {}
    for symb in atmlst:
        if symb != 'GHOST':
            occ_add, basis_add = minao_basis(symb)
            occdic[symb] = occ_add
            basis[symb] = basis_add
    occ = []
    new_atom = []
    for ia in range(mol.natm):
        symb = mol.atom_pure_symbol(ia)
        if symb != 'GHOST':
            occ.append(occdic[symb])
            new_atom.append(mol._atom[ia])
    occ = numpy.hstack(occ)

    pmol = pyscf.gto.Mole()
    pmol._atm, pmol._bas, pmol._env = pmol.make_env(new_atom, basis, [])
    c = addons.project_mo_nr2nr(pmol, 1, mol)

    dm = numpy.dot(c*occ, c.T)
# normalize eletron number
#    s = mol.intor_symmetric('cint1e_ovlp_sph')
#    dm *= mol.nelectron / (dm*s).sum()
    return dm


def init_guess_by_1e(mol):
    '''Generate initial guess density matrix from core hamiltonian

    Returns:
        Density matrix, 2D ndarray
    '''
    mf = RHF(mol)
    return mf.init_guess_by_1e(mol)


def init_guess_by_atom(mol):
    '''Generate initial guess density matrix from superposition of atomic HF
    density matrix.  The atomic HF is occupancy averaged RHF

    Returns:
        Density matrix, 2D ndarray
    '''
    from pyscf.scf import atom_hf
    atm_scf = atom_hf.get_atm_nrhf(mol)
    nbf = mol.nao_nr()
    dm = numpy.zeros((nbf, nbf))
    p0 = 0
    for ia in range(mol.natm):
        symb = mol.atom_symbol(ia)
        if symb in atm_scf:
            e_hf, mo_e, mo_c, mo_occ = atm_scf[symb]
        else:
            symb = mol.atom_pure_symbol(ia)
            e_hf, mo_e, mo_c, mo_occ = atm_scf[symb]
        p1 = p0 + mo_e.__len__()
        dm[p0:p1,p0:p1] = numpy.dot(mo_c*mo_occ, mo_c.T.conj())
        p0 = p1

    for k, v in atm_scf.items():
        logger.debug1(mol, 'Atom %s, E = %.12g', k, v[0])
    return dm


def init_guess_by_chkfile(mol, chkfile_name, project=True):
    '''Read the HF results from checkpoint file, then project it to the
    basis defined by ``mol``

    Returns:
        Density matrix, 2D ndarray
    '''
    from pyscf.scf import addons
    chk_mol, scf_rec = chkfile.load_scf(chkfile_name)

    def fproj(mo):
        if project:
            return addons.project_mo_nr2nr(chk_mol, mo, mol)
        else:
            return mo
    if scf_rec['mo_coeff'].ndim == 2:
        mo = scf_rec['mo_coeff']
        mo_occ = scf_rec['mo_occ']
        if numpy.iscomplexobj(mo):
            raise RuntimeError('TODO: project DHF orbital to RHF orbital')
        dm = make_rdm1(fproj(mo), mo_occ)
    else:  # UHF
        mo = scf_rec['mo_coeff']
        mo_occ = scf_rec['mo_occ']
        dm = make_rdm1(fproj(mo[0]), mo_occ[0]) \
           + make_rdm1(fproj(mo[1]), mo_occ[1])
    return dm


def get_init_guess(mol, key='minao'):
    '''Pick a init_guess method

    Kwargs:
        key : str
            One of 'minao', 'atom', '1e', 'chkfile'.
    '''
    if callable(key):
        return key(mol)
    elif key.lower() == '1e':
        return init_guess_by_1e(mol)
    elif key.lower() == 'atom':
        return init_guess_by_atom(mol)
    elif key.lower() == 'chkfile':
        raise RuntimeError('Call pyscf.scf.hf.init_guess_by_chkfile instead')
    else:
        return init_guess_by_minao(mol)


# eigenvalue of d is 1
def level_shift(s, d, f, factor):
    r'''Apply level shift :math:`\Delta` to virtual orbitals

    .. math::
       :nowrap:

       \begin{align}
         FC &= SCE \\
         F &= F + SC \Lambda C^\dagger S \\
         \Lambda_{ij} &=
         \begin{cases}
            \delta_{ij}\Delta & i \in \text{virtual} \\
            0 & \text{otherwise}
         \end{cases}
       \end{align}

    Returns:
        New Fock matrix, 2D ndarray
    '''
    if abs(factor) < 1e-4:
        return f
    else:
        dm_vir = s - reduce(numpy.dot, (s, d, s))
        return f + dm_vir * factor


def damping(s, d, f, factor):
    if abs(factor) < 1e-4:
        return f
    else:
        #dm_vir = s - reduce(numpy.dot, (s,d,s))
        #sinv = numpy.linalg.inv(s)
        #f0 = reduce(numpy.dot, (dm_vir, sinv, f, d, s))
        dm_vir = numpy.eye(s.shape[0]) - numpy.dot(s, d)
        f0 = reduce(numpy.dot, (dm_vir, f, d, s))
        f0 = (f0+f0.T.conj()) * (factor/(factor+1.))
        return f - f0


# full density matrix for RHF
def make_rdm1(mo_coeff, mo_occ):
    '''One-particle densit matrix

    Args:
        mo_coeff : 2D ndarray
            Orbital coefficients. Each column is one orbital.
        mo_occ : 1D ndarray
            Occupancy
    '''
    mocc = mo_coeff[:,mo_occ>0]
    return numpy.dot(mocc*mo_occ[mo_occ>0], mocc.T.conj())


################################################
# for general DM
# hermi = 0 : arbitary
# hermi = 1 : hermitian
# hermi = 2 : anti-hermitian
################################################
def dot_eri_dm(eri, dm, hermi=0):
    '''Compute J, K matrices in terms of the given 2-electron integrals and
    density matrix

    Args:
        eri : ndarray
            8-fold or 4-fold ERIs
        dm : ndarray or list of ndarrays
            A density matrix or a list of density matrices

    Kwargs:
        hermi : int
            Whether J, K matrix is hermitian

            | 0 : no hermitian or symmetric
            | 1 : hermitian
            | 2 : anti-hermitian

    Returns:
        Depending on the given dm, the function returns one J and one K matrix,
        or a list of J matrices and a list of K matrices, corresponding to the
        input density matrices.

    Examples:

    >>> from pyscf import gto, scf
    >>> from pyscf.scf import _vhf
    >>> mol = gto.M(atom='H 0 0 0; H 0 0 1.1')
    >>> eri = _vhf.int2e_sph(mol._atm, mol._bas, mol._env)
    >>> dms = numpy.random.random((3,mol.nao_nr(),mol.nao_nr()))
    >>> j, k = scf.hf.dot_eri_dm(eri, dms, hermi=0)
    >>> print(j.shape)
    (3, 2, 2)
    '''
    if isinstance(dm, numpy.ndarray) and dm.ndim == 2:
        vj, vk = _vhf.incore(eri, dm, hermi=hermi)
    else:
        vjk = [_vhf.incore(eri, dmi, hermi=hermi) for dmi in dm]
        vj = numpy.array([v[0] for v in vjk])
        vk = numpy.array([v[1] for v in vjk])
    return vj, vk


def get_jk(mol, dm, hermi=1, vhfopt=None):
    '''Compute J, K matrices for the given density matrix

    Args:
        mol : an instance of :class:`Mole`

        dm : ndarray or list of ndarrays
            A density matrix or a list of density matrices

    Kwargs:
        hermi : int
            Whether J, K matrix is hermitian

            | 0 : no hermitian or symmetric
            | 1 : hermitian
            | 2 : anti-hermitian

        vhfopt :
            A class which holds precomputed quantities to optimize the
            computation of J, K matrices

    Returns:
        Depending on the given dm, the function returns one J and one K matrix,
        or a list of J matrices and a list of K matrices, corresponding to the
        input density matrices.

    Examples:

    >>> from pyscf import gto, scf
    >>> from pyscf.scf import _vhf
    >>> mol = gto.M(atom='H 0 0 0; H 0 0 1.1')
    >>> dms = numpy.random.random((3,mol.nao_nr(),mol.nao_nr()))
    >>> j, k = scf.hf.get_jk(mol, dms, hermi=0)
    >>> print(j.shape)
    (3, 2, 2)
    '''
    vj, vk = _vhf.direct(numpy.array(dm, copy=False),
                         mol._atm, mol._bas, mol._env,
                         vhfopt=vhfopt, hermi=hermi)
    return vj, vk


def get_veff(mol, dm, dm_last=None, vhf_last=None, hermi=1, vhfopt=None):
    '''Hartree-Fock potential matrix for the given density matrix

    Args:
        mol : an instance of :class:`Mole`

        dm : ndarray or list of ndarrays
            A density matrix or a list of density matrices

    Kwargs:
        dm_last : ndarray or a list of ndarrays or 0
            The density matrix baseline.  If not 0, this function computes the
            increment of HF potential w.r.t. the reference HF potential matrix.
        vhf_last : ndarray or a list of ndarrays or 0
            The reference HF potential matrix.
        hermi : int
            Whether J, K matrix is hermitian

            | 0 : no hermitian or symmetric
            | 1 : hermitian
            | 2 : anti-hermitian

        vhfopt :
            A class which holds precomputed quantities to optimize the
            computation of J, K matrices

    Returns:
        matrix Vhf = 2*J - K.  Vhf can be a list matrices, corresponding to the
        input density matrices.

    Examples:

    >>> import numpy
    >>> from pyscf import gto, scf
    >>> from pyscf.scf import _vhf
    >>> mol = gto.M(atom='H 0 0 0; H 0 0 1.1')
    >>> dm0 = numpy.random.random((mol.nao_nr(),mol.nao_nr()))
    >>> vhf0 = scf.hf.get_veff(mol, dm0, hermi=0)
    >>> dm1 = numpy.random.random((mol.nao_nr(),mol.nao_nr()))
    >>> vhf1 = scf.hf.get_veff(mol, dm1, hermi=0)
    >>> vhf2 = scf.hf.get_veff(mol, dm1, dm_last=dm0, vhf_last=vhf0, hermi=0)
    >>> numpy.allclose(vhf1, vhf2)
    True
    '''
    if dm_last is None:
        ddm = numpy.asarray(dm)
    else:
        ddm = numpy.asarray(dm) - numpy.array(dm_last)
    vj, vk = get_jk(mol, ddm, hermi=hermi, vhfopt=vhfopt)
    if vhf_last is None:
        return vj - vk * .5
    else:
        return vj - vk * .5 + numpy.asarray(vhf_last)

def get_fock_(mf, h1e, s1e, vhf, dm, cycle=-1, adiis=None,
              diis_start_cycle=0, level_shift_factor=0, damp_factor=0):
    '''F = h^{core} + V^{HF}

    Args:
        h1e : 2D ndarray
            Core hamiltonian
        s1e : 2D ndarray
            Overlap matrix, for DIIS
        vhf : 2D ndarray
            HF potential matrix
        dm : 2D ndarray
            Density matrix, for DIIS

    Kwargs:
        cycle : int
            Then present SCF iteration step, for DIIS
        adiis : an instance of :attr:`SCF.DIIS` class
            the object to hold intermediate Fock and error vectors
        diis_start_cycle : int
            The step to start DIIS.  Default is 0.
        level_shift_factor : float or int
            Level shift (in AU) for virtual space.  Default is 0.
    '''
    f = h1e + vhf
    if 0 <= cycle < diis_start_cycle-1:
        f = damping(s1e, dm*.5, f, damp_factor)
    if adiis and cycle >= diis_start_cycle:
        f = adiis.update(s1e, dm, f)
    f = level_shift(s1e, dm*.5, f, level_shift_factor)
    return f

def get_grad(mo_coeff, mo_occ, fock_ao):
    '''RHF Gradients

    Args:
        mo_coeff : 2D ndarray
            Obital coefficients
        mo_occ : 1D ndarray
            Orbital occupancy
        fock_ao : 2D ndarray
            Fock matrix in AO representation

    Returns:
        Gradients in MO representation.  It's a num_occ*num_vir vector.
    '''
    occidx = numpy.where(mo_occ> 0)[0]
    viridx = numpy.where(mo_occ==0)[0]

    fock = reduce(numpy.dot, (mo_coeff.T.conj(), fock_ao, mo_coeff))
    g = fock[viridx[:,None],occidx] * 2
    return g.reshape(-1)


def analyze(mf, verbose=logger.DEBUG):
    '''Analyze the given SCF object:  print orbital energies, occupancies;
    print orbital coefficients; Mulliken population analysis
    '''
    from pyscf.tools import dump_mat
    mo_energy = mf.mo_energy
    mo_occ = mf.mo_occ
    mo_coeff = mf.mo_coeff
    if isinstance(verbose, logger.Logger):
        log = verbose
    else:
        log = logger.Logger(mf.stdout, verbose)

    log.info('**** MO energy ****')
    for i in range(len(mo_energy)):
        if mo_occ[i] > 0:
            log.info('occupied MO #%d energy= %.15g occ= %g',
                     i+1, mo_energy[i], mo_occ[i])
        else:
            log.info('virtual MO #%d energy= %.15g occ= %g',
                     i+1, mo_energy[i], mo_occ[i])
    if verbose >= logger.DEBUG:
        log.debug(' ** MO coefficients **')
        label = mf.mol.spheric_labels(True)
        dump_mat.dump_rec(mf.stdout, mo_coeff, label, start=1)
    dm = mf.make_rdm1(mo_coeff, mo_occ)
    return mf.mulliken_meta(mf.mol, dm, s=mf.get_ovlp(), verbose=log)


def mulliken_pop(mol, dm, s=None, verbose=logger.DEBUG):
    r'''Mulliken population analysis

    .. math:: M_{ij} = D_{ij} S_{ji}

    Mulliken charges

    .. math:: \delta_i = \sum_j M_{ij}

    '''
    if s is None:
        s = get_ovlp(mol)
    if isinstance(verbose, logger.Logger):
        log = verbose
    else:
        log = logger.Logger(mol.stdout, verbose)
    if isinstance(dm, numpy.ndarray) and dm.ndim == 2:
        pop = numpy.einsum('ij->i', dm*s).real
    else: # ROHF
        pop = numpy.einsum('ij->i', (dm[0]+dm[1])*s).real
    label = mol.spheric_labels(False)

    log.info(' ** Mulliken pop  **')
    for i, s in enumerate(label):
        log.info('pop of  %s %10.5f', '%d%s %s%-4s'%s, pop[i])

    log.info(' ** Mulliken atomic charges  **')
    chg = numpy.zeros(mol.natm)
    for i, s in enumerate(label):
        chg[s[0]] += pop[i]
    for ia in range(mol.natm):
        symb = mol.atom_symbol(ia)
        nuc = mol.atom_charge(ia)
        chg[ia] = nuc - chg[ia]
        log.info('charge of  %d%s =   %10.5f', ia, symb, chg[ia])
    return pop, chg


def mulliken_pop_meta_lowdin_ao(mol, dm, verbose=logger.DEBUG,
                                pre_orth_method='ANO', s=None):
    return mulliken_meta(mol, dm, verbose, pre_orth_method, s)
def mulliken_meta(mol, dm, verbose=logger.DEBUG, pre_orth_method='ANO',
                  s=None):
    '''Mulliken population analysis, based on meta-Lowdin AOs.
    In the meta-lowdin, the AOs are grouped in three sets: core, valence and
    Rydberg, the orthogonalization are carreid out within each subsets.

    Args:
        mol : an instance of :class:`Mole`

        dm : ndarray or 2-item list of ndarray
            Density matrix.  ROHF dm is a 2-item list of 2D array

    Kwargs:
        verbose : int or instance of :class:`lib.logger.Logger`

        pre_orth_method : str
            Pre-orthogonalization, which localized GTOs for each atom.
            To obtain the occupied and unoccupied atomic shells, there are
            three methods

            | 'ano'   : Project GTOs to ANO basis
            | 'minao' : Project GTOs to MINAO basis
            | 'scf'   : Fraction-averaged RHF

    '''
    from pyscf.lo import orth
    if s is None:
        s = get_ovlp(mol)
    if isinstance(verbose, logger.Logger):
        log = verbose
    else:
        log = logger.Logger(mol.stdout, verbose)
    c = orth.pre_orth_ao(mol, pre_orth_method)
    orth_coeff = orth.orth_ao(mol, 'meta_lowdin', pre_orth_ao=c, s=s)
    c_inv = numpy.dot(orth_coeff.T, s)
    if isinstance(dm, numpy.ndarray) and dm.ndim == 2:
        dm = reduce(numpy.dot, (c_inv, dm, c_inv.T.conj()))
    else:  # ROHF
        dm = reduce(numpy.dot, (c_inv, dm[0]+dm[1], c_inv.T.conj()))

    log.info(' ** Mulliken pop on meta-lowdin orthogonal AOs  **')
    return mulliken_pop(mol, dm, numpy.eye(orth_coeff.shape[0]), log)


def eig(h, s):
    '''Solver for generalized eigenvalue problem

    .. math:: HC = SCE
    '''
    e, c = scipy.linalg.eigh(h, s)
    idx = numpy.argmax(abs(c.real), axis=0)
    c[:,c[idx,numpy.arange(len(e))].real<0] *= -1
    return e, c


def uniq_var_indices(mo_occ):
    occaidx = mo_occ>0
    occbidx = mo_occ==2
    virbidx = numpy.logical_not(occbidx)
    openidx = numpy.where(mo_occ==1)[0]

    mask = virbidx[:,None]&occaidx
    if len(openidx) > 0:
        mask[openidx[:,None],openidx] = False
    return mask

def pack_uniq_var(x1, mo_occ):
    idx = uniq_var_indices(mo_occ)
    return x1[idx]

def unpack_uniq_var(dx, mo_occ):
    nmo = len(mo_occ)
    idx = uniq_var_indices(mo_occ)

    x1 = numpy.zeros((nmo,nmo))
    x1[idx] = dx
    return x1 - x1.T



class SCF(object):
    '''SCF base class.   non-relativistic RHF.

    Attributes:
        verbose : int
            Print level.  Default value equals to :class:`Mole.verbose`
        max_memory : float or int
            Allowed memory in MB.  Default equals to :class:`Mole.max_memory`
        chkfile : str
            checkpoint file to save MOs, orbital energies etc.
        conv_tol : float
            converge threshold.  Default is 1e-10
        conv_tol_grad : float
            gradients converge threshold.  Default is sqrt(conv_tol)
        max_cycle : int
            max number of iterations.  Default is 50
        init_guess : str
            initial guess method.  It can be one of 'minao', 'atom', '1e', 'chkfile'.
            Default is 'minao'
        DIIS : class listed in :mod:`scf.diis`
            Default is :class:`diis.SCF_DIIS`. Set it to None to turn off DIIS.
        diis : bool
            whether to do DIIS.  Default is True.
        diis_space : int
            DIIS space size.  By default, 8 Fock matrices and errors vector are stored.
        diis_start_cycle : int
            The step to start DIIS.  Default is 1.
        diis_file: 'str'
            File to store DIIS vectors and error vectors.
        level_shift_factor : float or int
            Level shift (in AU) for virtual space.  Default is 0.
        direct_scf : bool
            Direct SCF is used by default.
        direct_scf_tol : float
            Direct SCF cutoff threshold.  Default is 1e-13.
        callback : function(envs_dict) => None
            callback function takes one dict as the argument which is
            generated by the builtin function :func:`locals`, so that the
            callback function can access all local variables in the current
            envrionment.

    Saved results

        converged : bool
            SCF converged or not
        hf_energy : float
            Total HF energy (electronic energy plus nuclear repulsion)
        mo_energy :
            Orbital energies
        mo_occ
            Orbital occupancy
        mo_coeff
            Orbital coefficients

    Examples:

    >>> mol = gto.M(atom='H 0 0 0; H 0 0 1.1', basis='cc-pvdz')
    >>> mf = scf.hf.SCF(mol)
    >>> mf.verbose = 0
    >>> mf.level_shift_factor = .4
    >>> mf.scf()
    -1.0811707843775884
    '''
    def __init__(self, mol):
        if not mol._built:
            sys.stderr.write('Warning: mol.build() is not called in input\n')
            mol.build()
        self.mol = mol
        self.verbose = mol.verbose
        self.max_memory = mol.max_memory
        self.stdout = mol.stdout

# the chkfile will be removed automatically, to save the chkfile, assign a
# filename to self.chkfile
        self._chkfile = tempfile.NamedTemporaryFile()
        self.chkfile = self._chkfile.name
        self.conv_tol = 1e-9
        self.conv_tol_grad = None
        self.max_cycle = 50
        self.init_guess = 'minao'
        self.DIIS = diis.SCF_DIIS
        self.diis = True
        self.diis_space = 8
        self.diis_start_cycle = 1 # need > 0 if initial DM is numpy.zeros array
        self.diis_file = None
# Give diis_space_rollback=True a trial if other efforts not converge
        self.diis_space_rollback = False
        self.damp_factor = 0
        self.level_shift_factor = 0
        self.direct_scf = True
        self.direct_scf_tol = 1e-13
##################################################
# don't modify the following attributes, they are not input options
        self.mo_energy = None
        self.mo_coeff = None
        self.mo_occ = None
        self.hf_energy = 0
        self.converged = False
        self.callback = None

        self.opt = None
        self._eri = None
        self._keys = set(self.__dict__.keys())

    def build(self, mol=None):
        return self.build_(mol)
    def build_(self, mol=None):
        if self.verbose > logger.QUIET:
            pyscf.gto.mole.check_sanity(self, self._keys, self.stdout)

        if mol is None: mol = self.mol
        if (self.direct_scf and not mol.incore_anyway and
            not self._is_mem_enough()):
# Should I lazy initialize direct SCF?
            self.opt = self.init_direct_scf(mol)

    def dump_flags(self):
        logger.info(self, '\n')
        logger.info(self, '******** SCF flags ********')
        logger.info(self, 'method = %s', self.__class__.__name__)
        logger.info(self, 'initial guess = %s', self.init_guess)
        logger.info(self, 'damping factor = %g', self.damp_factor)
        logger.info(self, 'level shift factor = %g', self.level_shift_factor)
        logger.info(self, 'Do DIIS = %s', self.diis)
        logger.info(self, 'DIIS start cycle = %d', self.diis_start_cycle)
        logger.info(self, 'DIIS space = %d', self.diis_space)
        logger.info(self, 'SCF tol = %g', self.conv_tol)
        logger.info(self, 'SCF gradient tol = %s', self.conv_tol_grad)
        logger.info(self, 'max. SCF cycles = %d', self.max_cycle)
        logger.info(self, 'direct_scf = %s', self.direct_scf)
        if self.direct_scf:
            logger.info(self, 'direct_scf_tol = %g', self.direct_scf_tol)
        if self.chkfile:
            logger.info(self, 'chkfile to save SCF result = %s', self.chkfile)
        logger.info(self, 'max_memory %d MB (current use %d MB)',
                    self.max_memory, pyscf.lib.current_memory()[0])


    def eig(self, h, s):
        return eig(h, s)

    def get_hcore(self, mol=None):
        if mol is None: mol = self.mol
        return get_hcore(mol)

    def get_ovlp(self, mol=None):
        if mol is None: mol = self.mol
        return get_ovlp(mol)

    def get_fock(self, h1e, s1e, vhf, dm, cycle=-1, adiis=None,
                 diis_start_cycle=None, level_shift_factor=None,
                 damp_factor=None):
        return self.get_fock_(h1e, s1e, vhf, dm, cycle, adiis,
                              diis_start_cycle, level_shift_factor, damp_factor)
    def get_fock_(self, h1e, s1e, vhf, dm, cycle=-1, adiis=None,
                  diis_start_cycle=None, level_shift_factor=None,
                  damp_factor=None):
        if diis_start_cycle is None:
            diis_start_cycle = self.diis_start_cycle
        if level_shift_factor is None:
            level_shift_factor = self.level_shift_factor
        if damp_factor is None:
            damp_factor = self.damp_factor
        return get_fock_(self, h1e, s1e, vhf, dm, cycle, adiis,
                         diis_start_cycle, level_shift_factor, damp_factor)

    def get_grad(self, mo_coeff, mo_occ, fock=None):
        if fock is None:
            dm1 = self.make_rdm1(mo_coeff, mo_occ)
            fock = self.get_hcore(self.mol) + self.get_veff(self.mol, dm1)
        return get_grad(mo_coeff, mo_occ, fock)

    def dump_chk(self, envs):
        if self.chkfile:
            chkfile.dump_scf(self.mol, self.chkfile,
                             envs['hf_energy'], envs['mo_energy'],
                             envs['mo_coeff'], envs['mo_occ'])

    def init_guess_by_minao(self, mol=None):
        if mol is None: mol = self.mol
        return init_guess_by_minao(mol)

    def init_guess_by_atom(self, mol=None):
        if mol is None: mol = self.mol
        logger.info(self, 'Initial guess from superpostion of atomic densties.')
        return init_guess_by_atom(mol)

    def init_guess_by_1e(self, mol=None):
        if mol is None: mol = self.mol
        logger.info(self, 'Initial guess from hcore.')
        h1e = self.get_hcore(mol)
        s1e = self.get_ovlp(mol)
        mo_energy, mo_coeff = self.eig(h1e, s1e)
        mo_occ = self.get_occ(mo_energy, mo_coeff)
        return self.make_rdm1(mo_coeff, mo_occ)

    def init_guess_by_chkfile(self, chk=None, project=True):
        if isinstance(chk, pyscf.gto.Mole):
            raise RuntimeError('''
    You see this error message because of the API updates.
    The first argument is chk file name.''')
        if chk is None: chk = self.chkfile
        return init_guess_by_chkfile(self.mol, chk, project=project)
    def from_chk(self, chk=None, project=True):
        return self.init_guess_by_chkfile(chk, project)

    def get_init_guess(self, mol=None, key='minao'):
        if callable(key):
            dm = key(mol)
        elif key.lower() == '1e':
            dm = self.init_guess_by_1e(mol)
        elif key.lower() == 'atom':
            dm = self.init_guess_by_atom(mol)
        elif key.lower() == 'chkfile':
            try:
                dm = self.init_guess_by_chkfile()
            except (IOError, KeyError):
                logger.warn(self, 'Fail in reading %s. Use MINAO initial guess',
                            self.chkfile)
                dm = self.init_guess_by_minao(mol)
        else:
            dm = self.init_guess_by_minao(mol)
        if self.verbose >= logger.DEBUG1:
            logger.debug1(self, 'Nelec from initial guess = %g',
                          (dm*self.get_ovlp()).sum())
        return dm

    def get_occ(self, mo_energy=None, mo_coeff=None):
        '''Label the occupancies for each orbital

        Kwargs:
            mo_energy : 1D ndarray
                Obital energies

            mo_coeff : 2D ndarray
                Obital coefficients

        Examples:

        >>> from pyscf import gto, scf
        >>> mol = gto.M(atom='H 0 0 0; F 0 0 1.1')
        >>> mf = scf.hf.SCF(mol)
        >>> mf.get_occ(numpy.arange(mol.nao_nr()))
        array([2, 2, 2, 2, 2, 0])
        '''
        if mo_energy is None: mo_energy = self.mo_energy
        mo_occ = numpy.zeros_like(mo_energy)
        nocc = self.mol.nelectron // 2
        mo_occ[:nocc] = 2
        if nocc < mo_occ.size:
            logger.info(self, 'HOMO = %.12g  LUMO = %.12g',
                        mo_energy[nocc-1], mo_energy[nocc])
            if mo_energy[nocc-1]+1e-3 > mo_energy[nocc]:
                logger.warn(self, '!! HOMO %.12g == LUMO %.12g',
                            mo_energy[nocc-1], mo_energy[nocc])
        else:
            logger.info(self, 'HOMO = %.12g', mo_energy[nocc-1])
        if self.verbose >= logger.DEBUG:
            numpy.set_printoptions(threshold=len(mo_energy))
            logger.debug(self, '  mo_energy = %s', mo_energy)
            numpy.set_printoptions()
        return mo_occ

    # full density matrix for RHF
    def make_rdm1(self, mo_coeff=None, mo_occ=None):
        if mo_occ is None: mo_occ = self.mo_occ
        if mo_coeff is None: mo_coeff = self.mo_coeff
        return make_rdm1(mo_coeff, mo_occ)

    def energy_elec(self, dm=None, h1e=None, vhf=None):
        if dm is None: dm = self.make_rdm1()
        return energy_elec(self, dm, h1e, vhf)

    def energy_tot(self, dm=None, h1e=None, vhf=None):
        if dm is None: dm = self.make_rdm1()
        return self.energy_elec(dm, h1e, vhf)[0] + self.mol.energy_nuc()

    def kernel(self, dm0=None):
        return self.scf(dm0)
    def scf(self, dm0=None):
        '''main routine for SCF

        Kwargs:
            dm0 : ndarray
                If given, it will be used as the initial guess density matrix

        Examples:

        >>> import numpy
        >>> from pyscf import gto, scf
        >>> mol = gto.M(atom='H 0 0 0; F 0 0 1.1')
        >>> mf = scf.hf.SCF(mol)
        >>> dm_guess = numpy.eye(mol.nao_nr())
        >>> mf.kernel(dm_guess)
        converged SCF energy = -98.5521904482821
        -98.552190448282104
        '''
        cput0 = (time.clock(), time.time())

        self.build(self.mol)
        self.dump_flags()
        self.converged, self.hf_energy, \
                self.mo_energy, self.mo_coeff, self.mo_occ = \
                kernel(self, self.conv_tol, self.conv_tol_grad,
                       dm0=dm0, callback=self.callback)

        logger.timer(self, 'SCF', *cput0)
        self._finalize_()
        return self.hf_energy

    def _finalize_(self):
        if self.converged:
            logger.note(self, 'converged SCF energy = %.15g', self.hf_energy)
        else:
            logger.note(self, 'SCF not converge.')
            logger.note(self, 'SCF energy = %.15g after %d cycles',
                        self.hf_energy, self.max_cycle)

    def init_direct_scf(self, mol=None):
        if mol is None: mol = self.mol
        opt = _vhf.VHFOpt(mol, 'cint2e_sph', 'CVHFnrs8_prescreen',
                          'CVHFsetnr_direct_scf',
                          'CVHFsetnr_direct_scf_dm')
        opt.direct_scf_tol = self.direct_scf_tol
        return opt

    def get_jk(self, mol=None, dm=None, hermi=1):
        return self.get_jk_(mol, dm, hermi)
    def get_jk_(self, mol=None, dm=None, hermi=1):
        '''Compute J, K matrices for the given density matrix.
        See :func:`scf.hf.get_jk`
        '''
        if mol is None: mol = self.mol
        if dm is None: dm = self.make_rdm1()
        cpu0 = (time.clock(), time.time())
        if self.direct_scf and self.opt is None:
            self.opt = self.init_direct_scf(mol)
        vj, vk = get_jk(mol, dm, hermi, self.opt)
        logger.timer(self, 'vj and vk', *cpu0)
        return vj, vk

    def get_j(self, mol=None, dm=None, hermi=1):
        '''Compute J matrix for the given density matrix.
        '''
        return self.get_jk(mol, dm, hermi)[0]

    def get_k(self, mol=None, dm=None, hermi=1):
        '''Compute K matrix for the given density matrix.
        '''
        return self.get_jk(mol, dm, hermi)[1]

    def get_veff(self, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1):
        '''Hartree-Fock potential matrix for the given density matrix.
        See :func:`scf.hf.get_veff`

        Note the effects of :attr:`SCF.direct_scf` on this function
        '''
        if mol is None: mol = self.mol
        if dm is None: dm = self.make_rdm1()
        if self.direct_scf:
            ddm = numpy.asarray(dm) - numpy.asarray(dm_last)
            vj, vk = self.get_jk(mol, ddm, hermi=hermi)
            return numpy.array(vhf_last, copy=False) + vj - vk * .5
        else:
            vj, vk = self.get_jk(mol, dm, hermi=hermi)
            return vj - vk * .5

    def analyze(self, verbose=logger.DEBUG):
        return analyze(self, verbose)

    def mulliken_pop(self, mol=None, dm=None, s=None, verbose=logger.DEBUG):
        if mol is None: mol = self.mol
        if dm is None: dm = self.make_rdm1()
        if s is None: s = self.get_ovlp(mol)
        return mulliken_pop(mol, dm, s=s, verbose=verbose)

    def mulliken_pop_meta_lowdin_ao(self, mol=None, dm=None,
                                    verbose=logger.DEBUG,
                                    pre_orth_method='ANO', s=None):
        if mol is None: mol = self.mol
        if dm is None: dm = self.make_rdm1()
        return mulliken_pop_meta_lowdin_ao(mol, dm, s=s, verbose=verbose,
                                           pre_orth_method=pre_orth_method)
    def mulliken_meta(self, *args, **kwargs):
        return self.mulliken_pop_meta_lowdin_ao(*args, **kwargs)

    def _is_mem_enough(self):
        nbf = self.mol.nao_nr()
        return nbf**4/1e6+pyscf.lib.current_memory()[0] < self.max_memory*.95

    def density_fit(self, auxbasis='weigend'):
        import pyscf.scf.dfhf
        return pyscf.scf.dfhf.density_fit(self, auxbasis)


############

class HF1e(SCF):
    def scf(self, *args):
        logger.info(self, '\n')
        logger.info(self, '******** 1 electron system ********')
        self.converged = True
        h1e = self.get_hcore(self.mol)
        s1e = self.get_ovlp(self.mol)
        self.mo_energy, self.mo_coeff = self.eig(h1e, s1e)
        self.mo_occ = numpy.zeros_like(self.mo_energy)
        self.mo_occ[0] = 1
        self.hf_energy = self.mo_energy[0] + self.mol.energy_nuc()
        return self.hf_energy


class RHF(SCF):
    __doc__ = SCF.__doc__

    def __init__(self, mol):
        if mol.nelectron != 1 and (mol.nelectron % 2) != 0:
            raise ValueError('Invalid electron number %i.' % mol.nelectron)
# Note: self._eri requires large amount of memory
        SCF.__init__(self, mol)

    def get_jk_(self, mol=None, dm=None, hermi=1):
        '''Hartree-Fock potential matrix for the given density matrix.
        See :func:`scf.hf.get_veff`

        Note the incore version, which initializes an _eri array in memory.
        '''
        if mol is None: mol = self.mol
        if dm is None: dm = self.make_rdm1()
        cpu0 = (time.clock(), time.time())
        if self._eri is not None or mol.incore_anyway or self._is_mem_enough():
            if self._eri is None:
                self._eri = _vhf.int2e_sph(mol._atm, mol._bas, mol._env)
            vj, vk = dot_eri_dm(self._eri, dm, hermi)
        else:
            if self.direct_scf:
                self.opt = self.init_direct_scf(mol)
            vj, vk = get_jk(mol, dm, hermi, self.opt)
        logger.timer(self, 'vj and vk', *cpu0)
        return vj, vk

    def get_veff(self, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1):
        '''Hartree-Fock potential matrix for the given density matrix.
        See :func:`scf.hf.get_veff`
        '''
        if mol is None: mol = self.mol
        if dm is None: dm = self.make_rdm1()
        if (self._eri is not None or not self.direct_scf or
            mol.incore_anyway or self._is_mem_enough()):
            vj, vk = self.get_jk(mol, dm, hermi)
            return vj - vk * .5
        else:
            return SCF.get_veff(self, mol, dm, dm_last, vhf_last, hermi)


if __name__ == '__main__':
    mol = pyscf.gto.Mole()
    mol.verbose = 5
    mol.output = None

    mol.atom = [['He', (0, 0, 0)], ]
    mol.basis = 'ccpvdz'
    mol.build()

##############
# SCF result
    method = RHF(mol)
    method.init_guess = '1e'
    energy = method.scf()
    print(energy)
